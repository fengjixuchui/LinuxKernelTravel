<!DOCTYPE html>
<head>
	<meta http-equiv='Content-Type' content='text/html;charset=utf-8'>
	<meta name='viewport' content='width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no'>
	<title>
		Linux kernel的中断子系统之（二）：IRQ Domain介绍
	</title>
	<script src='https://cdn.bootcss.com/jquery/1.10.2/jquery.min.js'>
	</script>
	<style>
		a {color: #607fa6;text-decoration:none;word-wrap:break-word;word-break:break-all;}.rich_media_title{padding-bottom:10px;margin-bottom:14px;border-bottom:1px solid #e7e7eb;font-weight:400;} .rich_media_meta_list{font-size:14px;margin-bottom: 22px;}
		.rich_media_meta{display:inline-block;vertical-align:middle;margin-right:8px;margin-bottom:10px;font-size:14px;}.rich_media_meta_text{color:#8c8c8c;color:rgba(0, 0, 0, 0.3)}.rich_media_meta_list
		em {font-style: normal;}@media screen and (max-width:768px){.rich_media{position:
		relative;padding: 20px 15px 15px;background-color: #fff;}}.rich_media_content{text-align:justify;} .rich_media_content * {max-width:100%!important;box-sizing: border-box!important;-webkit-box-sizing:
		border-box!important;word-wrap: break-word!important;}.rich_media_content
		blockquote {margin: 0;padding-left: 10px;border-left: 3px solid #dbdbdb;}.rich_media_content
		.list-paddingleft-2 {padding-left: 2.2em;}a.rich_media_meta_nickname{display: none;}@media screen and (min-width:1025px){.rich_media{position:relative;}a.rich_media_meta_nickname{display:inline-block!important;}span.rich_media_meta_nickname
		{display: inline-block!important;}.rich_media {width:677px;margin-left:auto;margin-right:auto;}}a.fwjm{font-size: 12px;color: #ececec;}.tenvideo_player {position: relative;width:
		100 %;height: 100 %;margin: auto;background: #000;}* {margin:0px;padding:0px;} body{line-height: 1.6;letter-spacing: .034em;}
		.dy_all {text-align: center;margin: 30px 0;} .dy_all a {display: inline-block;height:
		38px;line-height: 38px;padding: 0 18px;background-color: #009688;color:
		#fff;white-space: nowrap;font-size: 14px;border: none;border-radius: 2px;cursor:
		pointer;text-align: center;outline: 0;-webkit-appearance: none;transition:
		all .3s;-webkit-transition: all .3s;box-sizing: border-box;} img{max-width: 677px!important;}

		.crawler-info{padding: 8px 0;} .article-link>img{margin-left: 20px;width: 16px;}
		.comment-item::before,.comment-item::after{content:'';display:block;height:0;visibility:hidden;clear:both;*zoom:1;} .comment-item{margin-bottom:30px;}
		.avatar{width:12%; padding-right:10px;float:left;box-sizing:border-box;} .avatar img{width:100%;}
		.comment-body{float:left;width:88%;} .comment-body .comment-info{color:#b3b3b3;margin-bottom:4px;margin-top: -5px;} .comment-body .comment-info>span:last-child{float:right;} 
		.comment-author{border-left:4px solid green;padding-left:6px;margin:8px 0;}

		@media screen and (max-width: 420px) {.article-link>img {margin-left: 0px;}}
		@media screen and (min-width: 480px) {.avatar {width: 9%;}.comment-body {width: 91%;}}
	</style>
</head>
<body>
	<div id='js_article' class='rich_media'>
		<div class="crawler-info">
			<a href='https://www.52pojie.cn' class='fwjm' target='_blank'>
				提供的爬取软件来源于：52pojie.cn@夜泉 免费下载使用
			</a>
			<a href='https://mp.weixin.qq.com/s?__biz=MzI3NzA5MzUxNA==&amp;mid=2664604869&amp;idx=1&amp;sn=c5b39aa5cdc384785197de0230b37afe&amp;chksm=f04d8920c73a0036d30c1d81b0f940b4416692c633c83dc407fe644635941e9eec8689c5722d&amp;scene=27#wechat_redirect&cpage=29' target='_blank' class="article-link">
				<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAMAAABA3o1rAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjk4QUEzQzVDNkNGQjExRTk5NzNBQ0VBMjgzMjY1NjkwIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjk4QUEzQzVENkNGQjExRTk5NzNBQ0VBMjgzMjY1NjkwIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OThBQTNDNUE2Q0ZCMTFFOTk3M0FDRUEyODMyNjU2OTAiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OThBQTNDNUI2Q0ZCMTFFOTk3M0FDRUEyODMyNjU2OTAiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5TKSKsAAAAclBMVEUuLi77+/stLS1VVVXx8fFOTk7s7Ozt7e1qamp5eXlNTU2WlpZFRUU6Ojrq6urn5+d/f3/8/Pw9PT0/Pz+YmJg8PDyZmZlAQECfn5+QkJBBQUFra2vo6OhDQ0OSkpKenp5WVlY+Pj7r6+tpaWksLCz///9o6ILHAAAAJnRSTlP/////////////////////////////////////////////////AKd6gbwAAACNSURBVHjajJHpEoIwDISDVMotcnuCmLz/K9KCdlqO6v7p7Mw3yW4KxG85fnUkIVfZ5J0SsCtqcgRw0HzjQYY2AAOIdRuaK4ReAPJ5nmglL5qICahpU60C0uXguQ9TgIwGJoDnT9z/ABmxt60ot0N2CsDLfb9mvBxs9ql+n5o9bEDBgbif7/1F4g80CjAAqrVAnnsm5f8AAAAASUVORK5CYII=" />
			</a>
		</div>
		<div id="img-content">

                
                <h2 class="rich_media_title" id="activity-name">Linux kernel的中断子系统之（二）：IRQ Domain介绍</h2>
                <div id="meta_content" class="rich_media_meta_list">
                                                                                
                                        <span class="rich_media_meta rich_media_meta_nickname" id="profileBt"><a href="javascript:void(0);">Linux内核之旅</a>
                      <div id="js_profile_qrcode" class="profile_container" style="display:none;">
                          <div class="profile_inner">
                              <strong class="profile_nickname">Linux内核之旅</strong>
                              <img class="profile_avatar" id="js_profile_qrcode_img" src="" alt="">

                              <p class="profile_meta">
                              <label class="profile_meta_label">微信号</label>
                              <span class="profile_meta_value">LinuxKernelTravel</span>
                              </p>

                              <p class="profile_meta">
                              <label class="profile_meta_label">功能介绍</label>
                              <span class="profile_meta_value">Linux内核之旅</span>
                              </p>
                              
                          </div>
                          <span class="profile_arrow_wrp" id="js_profile_arrow_wrp">
                              <i class="profile_arrow arrow_out"></i>
                              <i class="profile_arrow arrow_in"></i>
                          </span>
                      </div>
                    </span>


                    <em id="publish_time" class="rich_media_meta rich_media_meta_text">2017-11-02</em>





                </div>

                
                
                                
                
                
                
                                                
                                                                
                                
                
                <div class="rich_media_content " id="js_content">
                    

                    

                    
                    
                    <p style="padding-bottom: 15px;max-width: 100%;min-height: 1em;white-space: normal;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 18px;color: rgb(255, 76, 65);box-sizing: border-box !important;word-wrap: break-word !important;">转载自：蜗窝科技（博客）</span></strong></p><p style="padding-bottom: 15px;max-width: 100%;min-height: 1em;white-space: normal;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><strong style="max-width: 100%;box-sizing: border-box !important;word-wrap: break-word !important;"><span style="max-width: 100%;font-size: 18px;color: rgb(255, 76, 65);box-sizing: border-box !important;word-wrap: break-word !important;">作者：linuxer</span></strong></p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);"><br  /></p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">一、概述</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">在linux kernel中，我们使用下面两个ID来标识一个来自外设的中断：</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">1、IRQ number。CPU需要为每一个外设中断编号，我们称之IRQ Number。这个IRQ number是一个虚拟的interrupt ID，和硬件无关，仅仅是被CPU用来标识一个外设中断。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">2、HW interrupt ID。对于interrupt controller而言，它收集了多个外设的interrupt request line并向上传递，因此，interrupt controller需要对外设中断进行编码。Interrupt controller用HW interrupt ID来标识外设的中断。在interrupt controller级联的情况下，仅仅用HW interrupt ID已经不能唯一标识一个外设中断，还需要知道该HW interrupt ID所属的interrupt controller（HW interrupt ID在不同的Interrupt controller上是会重复编码的）。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">这样，CPU和interrupt controller在标识中断上就有了一些不同的概念，但是，对于驱动工程师而言，我们和CPU视角是一样的，我们只希望得到一个IRQ number，而不关系具体是那个interrupt controller上的那个HW interrupt ID。这样一个好处是在中断相关的硬件发生变化的时候，驱动软件不需要修改。因此，linux kernel中的中断子系统需要提供一个将HW interrupt ID映射到IRQ number上来的机制，这就是本文主要的内容。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">&nbsp;</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">二、历史</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">关于HW interrupt ID映射到IRQ number上 这事，在过去系统只有一个interrupt controller的时候还是很简单的，中断控制器上实际的HW interrupt line的编号可以直接变成IRQ number。例如我们大家都熟悉的SOC内嵌的interrupt controller，这种controller多半有中断状态寄存器，这个寄存器可能有64个bit（也可能更多），每个bit就是一个IRQ number，可以直接进行映射。这时候，GPIO的中断在中断控制器的状态寄存器中只有一个bit，因此所有的GPIO中断只有一个IRQ number，在该通用GPIO中断的irq handler中进行deduplex，将各个具体的GPIO中断映射到其相应的IRQ number上。如果你是一个足够老的工程师，应该是经历过这个阶段的。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">随着linux kernel的发展，将interrupt controller抽象成irqchip这个概念越来越流行，甚至GPIO controller也可以被看出一个interrupt controller chip，这样，系统中至少有两个中断控制器了，一个传统意义的中断控制器，一个是GPIO controller type的中断控制器。随着系统复杂度加大，外设中断数据增加，实际上系统可以需要多个中断控制器进行级联，面对这样的趋势，linux kernel工程师如何应对？答案就是irq domain这个概念。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">我们听说过很多的domain，power domain，clock domain等等，所谓domain，就是领域，范围的意思，也就是说，任何的定义出了这个范围就没有意义了。系统中所有的interrupt controller会形成树状结构，对于每个interrupt controller都可以连接若干个外设的中断请求（我们称之interrupt source），interrupt controller会对连接其上的interrupt source（根据其在Interrupt controller中物理特性）进行编号（也就是HW interrupt ID了）。但这个编号仅仅限制在本interrupt controller范围内。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">&nbsp;</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">三、接口</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">1、向系统注册irq domain</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">具体如何进行映射是interrupt controller自己的事情，不过，有软件架构思想的工程师更愿意对形形色色的interrupt controller进行抽象，对如何进行HW interrupt ID到IRQ number映射关系上进行进一步的抽象。因此，通用中断处理模块中有一个irq domain的子模块，该模块将这种映射关系分成了三类：</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（1）线性映射。其实就是一个lookup table，HW interrupt ID作为index，通过查表可以获取对应的IRQ number。对于Linear map而言，interrupt controller对其HW interrupt ID进行编码的时候要满足一定的条件：hw ID不能过大，而且ID排列最好是紧密的。对于线性映射，其接口API如下：</p><blockquote style="margin-right: 20px;margin-bottom: 20px;margin-left: 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">static inline struct irq_domain *irq_domain_add_linear(struct device_node *of_node,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int size,－－－－－－－－－该interrupt domain支持多少IRQ&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct irq_domain_ops *ops,－－－callback函数&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *host_data)－－－－－driver私有数据&nbsp;<br data-filtered="filtered"  />{&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; return __irq_domain_add(of_node, size, size, 0, ops, host_data);&nbsp;<br data-filtered="filtered"  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（2）Radix Tree map。建立一个Radix Tree来维护HW interrupt ID到IRQ number映射关系。HW interrupt ID作为lookup key，在Radix Tree检索到IRQ number。如果的确不能满足线性映射的条件，可以考虑Radix Tree map。实际上，内核中使用Radix Tree map的只有powerPC和MIPS的硬件平台。对于Radix Tree map，其接口API如下：</p><blockquote style="margin-right: 20px;margin-bottom: 20px;margin-left: 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">static inline struct irq_domain *irq_domain_add_tree(struct device_node *of_node,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct irq_domain_ops *ops,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *host_data)&nbsp;<br data-filtered="filtered"  />{&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; return __irq_domain_add(of_node, 0, ~0, 0, ops, host_data);&nbsp;<br data-filtered="filtered"  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（3）no map。有些中断控制器很强，可以通过寄存器配置HW interrupt ID而不是由物理连接决定的。例如PowerPC 系统使用的MPIC (Multi-Processor Interrupt Controller)。在这种情况下，不需要进行映射，我们直接把IRQ number写入HW interrupt ID配置寄存器就OK了，这时候，生成的HW interrupt ID就是IRQ number，也就不需要进行mapping了。对于这种类型的映射，其接口API如下：</p><blockquote style="margin-right: 20px;margin-bottom: 20px;margin-left: 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">static inline struct irq_domain *irq_domain_add_nomap(struct device_node *of_node,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int max_irq,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct irq_domain_ops *ops,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *host_data)&nbsp;<br data-filtered="filtered"  />{&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; return __irq_domain_add(of_node, 0, max_irq, max_irq, ops, host_data);&nbsp;<br data-filtered="filtered"  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">这类接口的逻辑很简单，根据自己的映射类型，初始化struct irq_domain中的各个成员，调用__irq_domain_add将该irq domain挂入irq_domain_list的全局列表。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">2、为irq domain创建映射</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">上节的内容主要是向系统注册一个irq domain，具体HW interrupt ID和IRQ number的映射关系都是空的，因此，具体各个irq domain如何管理映射所需要的database还是需要建立的。例如：对于线性映射的irq domain，我们需要建立线性映射的lookup table，对于Radix Tree map，我们要把那个反应IRQ number和HW interrupt ID的Radix tree建立起来。创建映射有四个接口函数：</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（1）调用irq_create_mapping函数建立HW interrupt ID和IRQ number的映射关系。该接口函数以irq domain和HW interrupt ID为参数，返回IRQ number（这个IRQ number是动态分配的）。该函数的原型定义如下：</p><blockquote style="margin-right: 20px;margin-bottom: 20px;margin-left: 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">extern unsigned int irq_create_mapping(struct irq_domain *host,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq_hw_number_t hwirq);</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">驱动调用该函数的时候必须提供HW interrupt ID，也就是意味着driver知道自己使用的HW interrupt ID，而一般情况下，HW interrupt ID其实对具体的driver应该是不可见的，不过有些场景比较特殊，例如GPIO类型的中断，它的HW interrupt ID和GPIO有着特定的关系，driver知道自己使用那个GPIO，也就是知道使用哪一个HW interrupt ID了。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（2）irq_create_strict_mappings。这个接口函数用来为一组HW interrupt ID建立映射。具体函数的原型定义如下：</p><blockquote style="margin-right: 20px;margin-bottom: 20px;margin-left: 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">extern int irq_create_strict_mappings(struct irq_domain *domain,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int irq_base,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq_hw_number_t hwirq_base, int count);</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（3）irq_create_of_mapping。看到函数名字中的of（open firmware），我想你也可以猜到了几分，这个接口当然是利用device tree进行映射关系的建立。具体函数的原型定义如下：</p><blockquote style="margin-right: 20px;margin-bottom: 20px;margin-left: 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">extern unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data);</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">通常，一个普通设备的device tree node已经描述了足够的中断信息，在这种情况下，该设备的驱动在初始化的时候可以调用irq_of_parse_and_map这个接口函数进行该device node中和中断相关的内容（interrupts和interrupt-parent属性）进行分析，并建立映射关系，具体代码如下：</p><blockquote style="margin-right: 20px;margin-bottom: 20px;margin-left: 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">unsigned int irq_of_parse_and_map(struct device_node *dev, int index)&nbsp;<br data-filtered="filtered"  />{&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; struct of_phandle_args oirq;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; if (of_irq_parse_one(dev, index, &amp;oirq))－－－－分析device node中的interrupt相关属性&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; return irq_create_of_mapping(&amp;oirq);－－－－－创建映射，并返回对应的IRQ number&nbsp;<br data-filtered="filtered"  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">对于一个使用Device tree的普通驱动程序（我们推荐这样做），基本上初始化需要调用irq_of_parse_and_map获取IRQ number，然后调用request_threaded_irq申请中断handler。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（4）irq_create_direct_mapping。这是给no map那种类型的interrupt controller使用的，这里不再赘述。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">&nbsp;</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">四、数据结构描述</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">1、irq domain的callback接口</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">struct irq_domain_ops抽象了一个irq domain的callback函数，定义如下：</p><blockquote style="margin-right: 20px;margin-bottom: 20px;margin-left: 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">struct irq_domain_ops {&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; int (*match)(struct irq_domain *d, struct device_node *node);&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; int (*map)(struct irq_domain *d, unsigned int virq, irq_hw_number_t hw);&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; void (*unmap)(struct irq_domain *d, unsigned int virq);&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; int (*xlate)(struct irq_domain *d, struct device_node *node,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const u32 *intspec, unsigned int intsize,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long *out_hwirq, unsigned int *out_type);&nbsp;<br data-filtered="filtered"  />};</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">我们先看xlate函数，语义是翻译（translate）的意思，那么到底翻译什么呢？在DTS文件中，各个使用中断的device node会通过一些属性（例如interrupts和interrupt-parent属性）来提供中断信息给kernel以便kernel可以正确的进行driver的初始化动作。这里，interrupts属性所表示的interrupt specifier只能由具体的interrupt controller（也就是irq domain）来解析。而xlate函数就是将指定的设备（node参数）上若干个（intsize参数）中断属性（intspec参数）翻译成HW interrupt ID（out_hwirq参数）和trigger类型（out_type）。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">match是判断一个指定的interrupt controller（node参数）是否和一个irq domain匹配（d参数），如果匹配的话，返回1。实际上，内核中很少定义这个callback函数，实际上struct irq_domain中有一个of_node指向了对应的interrupt controller的device node，因此，如果不提供该函数，那么default的匹配函数其实就是判断irq domain的of_node成员是否等于传入的node参数。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">map和unmap是操作相反的函数，我们描述其中之一就OK了。调用map函数的时机是在创建（或者更新）HW interrupt ID（hw参数）和IRQ number（virq参数）关系的时候。其实，从发生一个中断到调用该中断的handler仅仅调用一个request_threaded_irq是不够的，还需要针对该irq number设定：</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（1）设定该IRQ number对应的中断描述符（struct irq_desc）的irq chip</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（2）设定该IRQ number对应的中断描述符的highlevel irq-events handler</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（3）设定该IRQ number对应的中断描述符的 irq chip data</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">这些设定不适合由具体的硬件驱动来设定，因此在Interrupt controller，也就是irq domain的callback函数中设定。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">2、irq domain</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">在内核中，irq domain的概念由struct irq_domain表示：</p><blockquote style="margin-right: 20px;margin-bottom: 20px;margin-left: 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">struct irq_domain {&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; struct list_head link;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; const char *name;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; const struct irq_domain_ops *ops; －－－－callback函数&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; void *host_data;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; /* Optional data */&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; struct device_node *of_node; －－－－该interrupt domain对应的interrupt controller的device node&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; struct irq_domain_chip_generic *gc; －－－generic irq chip的概念，本文暂不描述</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; /* reverse map data. The linear map gets appended to the irq_domain */&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; irq_hw_number_t hwirq_max; －－－－该domain中最大的那个HW interrupt ID&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; unsigned int revmap_direct_max_irq; －－－－&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; unsigned int revmap_size; －－－线性映射的size，for Radix Tree map和no map，该值等于0&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; struct radix_tree_root revmap_tree; －－－－Radix Tree map使用到的radix tree root node&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; unsigned int linear_revmap[]; －－－－－线性映射使用的lookup table&nbsp;<br data-filtered="filtered"  />};</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">linux内核中，所有的irq domain被挂入一个全局链表，链表头定义如下：</p><blockquote style="margin-right: 20px;margin-bottom: 20px;margin-left: 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">static LIST_HEAD(irq_domain_list);</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">struct irq_domain中的link成员就是挂入这个队列的节点。通过irq_domain_list这个指针，可以获取整个系统中HW interrupt ID和IRQ number的mapping DB。host_data定义了底层interrupt controller使用的私有数据，和具体的interrupt controller相关（对于GIC，该指针指向一个struct gic_chip_data数据结构）。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">对于线性映射：</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（1）linear_revmap保存了一个线性的lookup table，index是HW interrupt ID，table中保存了IRQ number值</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（2）revmap_size等于线性的lookup table的size。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（3）hwirq_max保存了最大的HW interrupt ID</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（4）revmap_direct_max_irq没有用，设定为0。revmap_tree没有用。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">对于Radix Tree map：</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（1）linear_revmap没有用，revmap_size等于0。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（2）hwirq_max没有用，设定为一个最大值。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（3）revmap_direct_max_irq没有用，设定为0。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（4）revmap_tree指向Radix tree的root node。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">&nbsp;</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">五、中断相关的Device Tree知识回顾</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">想要进行映射，首先要了解interrupt controller的拓扑结构。系统中的interrupt controller的拓扑结构以及其interrupt request line的分配情况（分配给哪一个具体的外设）都在Device Tree Source文件中通过下面的属性给出了描述。这些内容在Device Tree的三份文档中给出了一些描述，这里简单总结一下：</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">对于那些产生中断的外设，我们需要定义interrupt-parent和interrupts属性：</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（1）interrupt-parent。表明该外设的interrupt request line物理的连接到了哪一个中断控制器上</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（2）interrupts。这个属性描述了具体该外设产生的interrupt的细节信息（也就是传说中的interrupt specifier）。例如：HW interrupt ID（由该外设的device node中的interrupt-parent指向的interrupt controller解析）、interrupt触发类型等。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">对于Interrupt controller，我们需要定义interrupt-controller和#interrupt-cells的属性：</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（1）interrupt-controller。表明该device node就是一个中断控制器</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（2）#interrupt-cells。该中断控制器用多少个cell（一个cell就是一个32-bit的单元）描述一个外设的interrupt request line。？具体每个cell表示什么样的含义由interrupt controller自己定义。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（3）interrupts和interrupt-parent。对于那些不是root 的interrupt controller，其本身也是作为一个产生中断的外设连接到其他的interrupt controller上，因此也需要定义interrupts和interrupt-parent的属性。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">&nbsp;</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">六、Mapping DB的建立</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">1、概述</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">系统中HW interrupt ID和IRQ number的mapping DB是在整个系统初始化的过程中建立起来的，过程如下：</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（1）DTS文件描述了系统中的interrupt controller以及外设IRQ的拓扑结构，在linux kernel启动的时候，由bootloader传递给kernel（实际传递的是DTB）。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（2）在Device Tree初始化的时候，形成了系统内所有的device node的树状结构，当然其中包括所有和中断拓扑相关的数据结构（所有的interrupt controller的node和使用中断的外设node）</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（3）在machine driver初始化的时候会调用of_irq_init函数，在该函数中会扫描所有interrupt controller的节点，并调用适合的interrupt controller driver进行初始化。毫无疑问，初始化需要注意顺序，首先初始化root，然后first level，second level，最好是leaf node。在初始化的过程中，一般会调用上节中的接口函数向系统增加irq domain。有些interrupt controller会在其driver初始化的过程中创建映射</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（4）在各个driver初始化的过程中，创建映射</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">&nbsp;</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">2、 interrupt controller初始化的过程中，注册irq domain</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">我们以GIC的代码为例。具体代码在gic_of_init-&gt;gic_init_bases中，如下：</p><blockquote style="margin-right: 20px;margin-bottom: 20px;margin-left: 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">void __init gic_init_bases(unsigned int gic_nr, int irq_start,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void __iomem *dist_base, void __iomem *cpu_base,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u32 percpu_offset, struct device_node *node)&nbsp;<br data-filtered="filtered"  />{&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; irq_hw_number_t hwirq_base;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; struct gic_chip_data *gic;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; int gic_irqs, irq_base, i;</p><p style="padding-bottom: 15px;line-height: 20px;">……&nbsp;<br data-filtered="filtered"  />对于root GIC&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwirq_base = 16;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gic_irqs = 系统支持的所有的中断数目－16。之所以减去16主要是因为root GIC的0～15号HW interrupt 是for IPI的，因此要去掉。也正因为如此hwirq_base从16开始</p><p style="padding-bottom: 15px;line-height: 20px;"><br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; irq_base = irq_alloc_descs(irq_start, 16, gic_irqs, numa_node_id());申请gic_irqs个IRQ资源，从16号开始搜索IRQ number。由于是root GIC，申请的IRQ基本上会从16号开始</p><p style="padding-bottom: 15px;line-height: 20px;"><br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; gic-&gt;domain = irq_domain_add_legacy(node, gic_irqs, irq_base,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwirq_base, &amp;gic_irq_domain_ops, gic);－－－向系统注册irq domain并创建映射</p><p style="padding-bottom: 15px;line-height: 20px;">……&nbsp;<br data-filtered="filtered"  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">很遗憾，在GIC的代码中没有调用标准的注册irq domain的接口函数。要了解其背后的原因，我们需要回到过去。在旧的linux kernel中，ARM体系结构的代码不甚理想。在arch/arm目录充斥了很多board specific的代码，其中定义了很多具体设备相关的静态表格，这些表格规定了各个device使用的资源，当然，其中包括IRQ资源。在这种情况下，各个外设的IRQ是固定的（如果作为驱动程序员的你足够老的话，应该记得很长篇幅的针对IRQ number的宏定义），也就是说，HW interrupt ID和IRQ number的关系是固定的。一旦关系固定，我们就可以在interupt controller的代码中创建这些映射关系。具体代码如下：</p><blockquote style="margin-right: 20px;margin-bottom: 20px;margin-left: 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">struct irq_domain *irq_domain_add_legacy(struct device_node *of_node,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int size,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int first_irq,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq_hw_number_t first_hwirq,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct irq_domain_ops *ops,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *host_data)&nbsp;<br data-filtered="filtered"  />{&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; struct irq_domain *domain;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; domain = __irq_domain_add(of_node, first_hwirq + size,－－－－注册irq domain&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; first_hwirq + size, 0, ops, host_data);&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; if (!domain)&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; irq_domain_associate_many(domain, first_irq, first_hwirq, size); －－－创建映射</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; return domain;&nbsp;<br data-filtered="filtered"  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">这时候，对于这个版本的GIC driver而言，初始化之后，HW interrupt ID和IRQ number的映射关系已经建立，保存在线性lookup table中，size等于GIC支持的中断数目，具体如下：</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">index 0～15对应的IRQ无效</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">16号IRQ&nbsp; &lt;------------------&gt;16号HW interrupt ID</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">17号IRQ&nbsp; &lt;------------------&gt;17号HW interrupt ID</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">……</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">如果想充分发挥Device Tree的威力，3.14版本中的GIC 代码需要修改。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">&nbsp;</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">3、在各个硬件外设的驱动初始化过程中，创建HW interrupt ID和IRQ number的映射关系</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">我们上面的描述过程中，已经提及：设备的驱动在初始化的时候可以调用irq_of_parse_and_map这个接口函数进行该device node中和中断相关的内容（interrupts和interrupt-parent属性）进行分析，并建立映射关系，具体代码如下：</p><blockquote style="margin-right: 20px;margin-bottom: 20px;margin-left: 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">unsigned int irq_of_parse_and_map(struct device_node *dev, int index)&nbsp;<br data-filtered="filtered"  />{&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; struct of_phandle_args oirq;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; if (of_irq_parse_one(dev, index, &amp;oirq))－－－－分析device node中的interrupt相关属性&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; return irq_create_of_mapping(&amp;oirq);－－－－－创建映射&nbsp;<br data-filtered="filtered"  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">我们再来看看irq_create_of_mapping函数如何创建映射：</p><blockquote style="margin-right: 20px;margin-bottom: 20px;margin-left: 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data)&nbsp;<br data-filtered="filtered"  />{&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; struct irq_domain *domain;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; irq_hw_number_t hwirq;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; unsigned int type = IRQ_TYPE_NONE;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; unsigned int virq;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; domain = irq_data-&gt;np ? irq_find_host(irq_data-&gt;np) : irq_default_domain;－－A&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; if (!domain) {&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; }</p><p style="padding-bottom: 15px;line-height: 20px;"><br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; if (domain-&gt;ops-&gt;xlate == NULL)－－－－－－－－－－－－－－B&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwirq = irq_data-&gt;args[0];&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; else {&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (domain-&gt;ops-&gt;xlate(domain, irq_data-&gt;np, irq_data-&gt;args,－－－－C&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq_data-&gt;args_count, &amp;hwirq, &amp;type))&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; }</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; /* Create mapping */&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; virq = irq_create_mapping(domain, hwirq);－－－－－－－－D&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; if (!virq)&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return virq;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; /* Set type if specified and different than the current one */&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; if (type != IRQ_TYPE_NONE &amp;&amp;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type != irq_get_trigger_type(virq))&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq_set_irq_type(virq, type);－－－－－－－－－E&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; return virq;&nbsp;<br data-filtered="filtered"  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">A：这里的代码主要是找到irq domain。这是根据传递进来的参数irq_data的np成员来寻找的，具体定义如下：</p><blockquote style="margin-right: 20px;margin-bottom: 20px;margin-left: 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">struct of_phandle_args {&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; struct device_node *np;－－－指向了外设对应的interrupt controller的device node&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; int args_count;－－－－－－－该外设定义的interrupt相关属性的个数&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; uint32_t args[MAX_PHANDLE_ARGS];－－－－具体的interrupt相当属性的定义&nbsp;<br data-filtered="filtered"  />};</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">B：如果没有定义xlate函数，那么取interrupts属性的第一个cell作为HW interrupt ID。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">C：解铃还需系铃人，interrupts属性最好由interrupt controller（也就是irq domain）解释。如果xlate函数能够完成属性解析，那么将输出参数hwirq和type，分别表示HW interrupt ID和interupt type（触发方式等）。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">D：解析完了，最终还是要调用irq_create_mapping函数来创建HW interrupt ID和IRQ number的映射关系。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">E：如果有需要，调用irq_set_irq_type函数设定trigger type</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">irq_create_mapping函数建立HW interrupt ID和IRQ number的映射关系。该接口函数以irq domain和HW interrupt ID为参数，返回IRQ number。具体的代码如下：</p><blockquote style="margin-right: 20px;margin-bottom: 20px;margin-left: 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">unsigned int irq_create_mapping(struct irq_domain *domain,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq_hw_number_t hwirq)&nbsp;<br data-filtered="filtered"  />{&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; unsigned int hint;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; int virq;</p><p style="padding-bottom: 15px;line-height: 20px;">如果映射已经存在，那么不需要映射，直接返回&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; virq = irq_find_mapping(domain, hwirq);&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; if (virq) {&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return virq;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; }</p><p style="padding-bottom: 15px;line-height: 20px;"><br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; hint = hwirq % nr_irqs;－－－－－－－分配一个IRQ 描述符以及对应的irq number&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; if (hint == 0)&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hint++;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; virq = irq_alloc_desc_from(hint, of_node_to_nid(domain-&gt;of_node));&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; if (virq &lt;= 0)&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virq = irq_alloc_desc_from(1, of_node_to_nid(domain-&gt;of_node));&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; if (virq &lt;= 0) {&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pr_debug("-&gt; virq allocation failed\n");&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; }</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; if (irq_domain_associate(domain, virq, hwirq)) {－－－建立mapping&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq_free_desc(virq);&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; }</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; return virq;&nbsp;<br data-filtered="filtered"  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">对于分配中断描述符这段代码，后续的文章会详细描述。这里简单略过，反正，指向完这段代码，我们就可以或者一个IRQ number以及其对应的中断描述符了。程序注释中没有使用IRQ number而是使用了virtual interrupt number这个术语。virtual interrupt number还是重点理解“virtual”这个词，所谓virtual，其实就是说和具体的硬件连接没有关系了，仅仅是一个number而已。具体建立映射的函数是irq_domain_associate函数，代码如下：</p><blockquote style="margin-right: 20px;margin-bottom: 20px;margin-left: 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">int irq_domain_associate(struct irq_domain *domain, unsigned int virq,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq_hw_number_t hwirq)&nbsp;<br data-filtered="filtered"  />{&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; struct irq_data *irq_data = irq_get_irq_data(virq);&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; int ret;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; mutex_lock(&amp;irq_domain_mutex);&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; irq_data-&gt;hwirq = hwirq;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; irq_data-&gt;domain = domain;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; if (domain-&gt;ops-&gt;map) {&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = domain-&gt;ops-&gt;map(domain, virq, hwirq);－－－调用irq domain的map callback函数&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; }</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; if (hwirq &lt; domain-&gt;revmap_size) {&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; domain-&gt;linear_revmap[hwirq] = virq;－－－－填写线性映射lookup table的数据&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; } else {&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mutex_lock(&amp;revmap_trees_mutex);&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radix_tree_insert(&amp;domain-&gt;revmap_tree, hwirq, irq_data);－－向radix tree插入一个node&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mutex_unlock(&amp;revmap_trees_mutex);&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; }&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; mutex_unlock(&amp;irq_domain_mutex);</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; irq_clear_status_flags(virq, IRQ_NOREQUEST); －－－该IRQ已经可以申请了，因此clear相关flag</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; return 0;&nbsp;<br data-filtered="filtered"  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">&nbsp;</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">七、将HW interrupt ID转成IRQ number</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">创建了庞大的HW interrupt ID到IRQ number的mapping DB，最终还是要使用。具体的使用场景是在CPU相关的处理函数中，程序会读取硬件interrupt ID，并转成IRQ number，调用对应的irq event handler。在本章中，我们以一个级联的GIC系统为例，描述转换过程</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">1、GIC driver初始化</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">上面已经描述了root GIC的的初始化，我们再来看看second GIC的初始化。具体代码在gic_of_init-&gt;gic_init_bases中，如下：</p><blockquote style="margin-right: 20px;margin-bottom: 20px;margin-left: 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">void __init gic_init_bases(unsigned int gic_nr, int irq_start,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void __iomem *dist_base, void __iomem *cpu_base,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u32 percpu_offset, struct device_node *node)&nbsp;<br data-filtered="filtered"  />{&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; irq_hw_number_t hwirq_base;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; struct gic_chip_data *gic;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; int gic_irqs, irq_base, i;</p><p style="padding-bottom: 15px;line-height: 20px;">……&nbsp;<br data-filtered="filtered"  />对于second GIC&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwirq_base = 32;&nbsp;&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gic_irqs = 系统支持的所有的中断数目－32。之所以减去32主要是因为对于second GIC，其0～15号HW interrupt 是for IPI的，因此要去掉。而16～31号HW interrupt 是for PPI的，也要去掉。也正因为如此hwirq_base从32开始</p><p style="padding-bottom: 15px;line-height: 20px;"><br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; irq_base = irq_alloc_descs(irq_start, 16, gic_irqs, numa_node_id());申请gic_irqs个IRQ资源，从16号开始搜索IRQ number。由于是second GIC，申请的IRQ基本上会从root GIC申请的最后一个IRQ号＋1开始</p><p style="padding-bottom: 15px;line-height: 20px;"><br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; gic-&gt;domain = irq_domain_add_legacy(node, gic_irqs, irq_base,&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwirq_base, &amp;gic_irq_domain_ops, gic);－－－向系统注册irq domain并创建映射</p><p style="padding-bottom: 15px;line-height: 20px;">……&nbsp;<br data-filtered="filtered"  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">second GIC初始化之后，该irq domain的HW interrupt ID和IRQ number的映射关系已经建立，保存在线性lookup table中，size等于GIC支持的中断数目，具体如下：</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">index 0～32对应的IRQ无效</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">root GIC申请的最后一个IRQ号＋1&nbsp; &lt;------------------&gt;32号HW interrupt ID</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">root GIC申请的最后一个IRQ号＋2&nbsp; &lt;------------------&gt;33号HW interrupt ID</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">……</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">OK，我们回到gic的初始化函数，对于second GIC，还有其他部分的初始化内容：</p><blockquote style="margin-right: 20px;margin-bottom: 20px;margin-left: 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">int __init gic_of_init(struct device_node *node, struct device_node *parent)&nbsp;<br data-filtered="filtered"  />{</p><p style="padding-bottom: 15px;line-height: 20px;">……</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; if (parent) {&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; irq = irq_of_parse_and_map(node, 0);－－解析second GIC的interrupts属性，并进行mapping，返回IRQ number&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gic_cascade_irq(gic_cnt, irq);－－－设置handler&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; }&nbsp;<br data-filtered="filtered"  />……&nbsp;<br data-filtered="filtered"  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">上面的初始化函数去掉和级联无关的代码。对于root GIC，其传入的parent是NULL，因此不会执行级联部分的代码。对于second GIC，它是作为其parent（root GIC）的一个普通的irq source，因此，也需要注册该IRQ的handler。由此可见，非root的GIC的初始化分成了两个部分：一部分是作为一个interrupt controller，执行和root GIC一样的初始化代码。另外一方面，GIC又作为一个普通的interrupt generating device，需要象一个普通的设备驱动一样，注册其中断handler。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">irq_of_parse_and_map函数相信大家已经熟悉了，这里不再描述。gic_cascade_irq函数如下：</p><blockquote style="margin-right: 20px;margin-bottom: 20px;margin-left: 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">void __init gic_cascade_irq(unsigned int gic_nr, unsigned int irq)&nbsp;<br data-filtered="filtered"  />{&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; if (irq_set_handler_data(irq, &amp;gic_data[gic_nr]) != 0)－－－设置handler data&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BUG();&nbsp;<br data-filtered="filtered"  />&nbsp;&nbsp;&nbsp; irq_set_chained_handler(irq, gic_handle_cascade_irq);－－－设置handler&nbsp;<br data-filtered="filtered"  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">2、具体如何在中断处理过程中，将HW interrupt ID转成IRQ number</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">在系统的启动过程中，经过了各个interrupt controller以及各个外设驱动的努力，整个interrupt系统的database（将HW interrupt ID转成IRQ number的数据库，这里的数据库不是指SQL lite或者oracle这样通用数据库软件）已经建立。一旦发生硬件中断，经过CPU architecture相关的中断代码之后，会调用irq handler，该函数的一般过程如下：</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（1）首先找到root interrupt controller对应的irq domain。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（2）根据HW 寄存器信息和irq domain信息获取HW interrupt ID</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（3）调用irq_find_mapping找到HW interrupt ID对应的irq number</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">（4）调用handle_IRQ（对于ARM平台）来处理该irq number</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;white-space: normal;background-color: rgb(255, 255, 255);">对于级联的情况，过程类似上面的描述，但是需要注意的是在步骤4中不是直接调用该IRQ的hander来处理该irq number因为，这个irq需要各个interrupt controller level上的解析。举一个简单的二阶级联情况：假设系统中有两个interrupt controller，A和B，A是root interrupt controller，B连接到A的13号HW interrupt ID上。在B interrupt controller初始化的时候，除了初始化它作为interrupt controller的那部分内容，还有初始化它作为root interrupt controller A上的一个普通外设这部分的内容。最重要的是调用irq_set_chained_handler设定handler。这样，在上面的步骤4的时候，就会调用13号HW interrupt ID对应的handler（也就是B的handler），在该handler中，会重复上面的（1）～（4）。</p><p><br  /></p>
                </div>
                

                
  <div class="ct_mpda_wrp" id="js_sponsor_ad_area" style="display: none;"></div>


                
                <div class="read-more__area" id="js_more_read_area" style="display:none;">
                    
                </div>

                
                                <div class="reward_area tc reward_area_primary" id="js_preview_reward_author" style="display:none;">
                    <div class="reward-avatar" style="display: none;" id="js_preview_reward_author_avatar">
                        <img src="" alt="" id="js_preview_reward_author_head">
                    </div>
                    
                                        <div class="reward-author" id="js_preview_reward_author_name"></div>
                                        <p class="reward_tips" id="js_preview_reward_author_wording" style="display:none;"></p>
                    <p class="reward_button_wrp">
                    
                      <span class="reward_pop_panel">
                        <img src="https://res.wx.qq.com/mpres/zh_CN/htmledition/pages/home/index/pic_mp_app4290ba.png" alt="">
                        <strong>扫一扫下载订阅号助手，用手机发文章</strong>
                      </span>
                        <a class="reward_button" id='js_preview_reward_author_link' href="##"><span id="js_preview_reward_link_text">赞赏</span></a>
                    </p>
                </div>

                <div class="reward_qrcode_area reward_area tc" id="js_preview_reward_qrcode" style="display:none;">
                    <p class="tips_global">长按二维码向我转账</p>
                    <p id="js_preview_reward_ios_wording" class="reward_tips" style="display:none;"></p>
                    <span class="reward_qrcode_img_wrp"><img class="reward_qrcode_img" src="res.wx.qq.com/mmbizwap/zh_CN/htmledition/images/pic/appmsg/pic_reward_qrcode.2x42f400.png"></span>
                    <p class="tips_global">受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。</p>
                </div>
                            </div>
		<div class="comment">
			<h3 style="margin:26px 0;font-weight:100;padding-bottom:4px;border-bottom:1px solid #ccc;">精选留言</h3>
		    暂无...
		</div>
	</div>
	<div class='dy_all'>
		<a href='http://www.wowotech.net/irq_subsystem/irq-domain.html' target='_blank'>
			阅读全文
		</a>
	</div>
</body>