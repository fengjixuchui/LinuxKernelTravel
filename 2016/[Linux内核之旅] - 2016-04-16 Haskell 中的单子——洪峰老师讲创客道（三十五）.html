<!DOCTYPE html>
<head>
	<meta http-equiv='Content-Type' content='text/html;charset=utf-8'>
	<meta name='viewport' content='width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no'>
	<title>
		Haskell 中的单子——洪峰老师讲创客道（三十五）
	</title>
	<script src='https://cdn.bootcss.com/jquery/1.10.2/jquery.min.js'>
	</script>
	<style>
		a {color: #607fa6;text-decoration:none;word-wrap:break-word;word-break:break-all;}.rich_media_title{padding-bottom:10px;margin-bottom:14px;border-bottom:1px solid #e7e7eb;font-weight:400;} .rich_media_meta_list{font-size:14px;margin-bottom: 22px;}
		.rich_media_meta{display:inline-block;vertical-align:middle;margin-right:8px;margin-bottom:10px;font-size:14px;}.rich_media_meta_text{color:#8c8c8c;color:rgba(0, 0, 0, 0.3)}.rich_media_meta_list
		em {font-style: normal;}@media screen and (max-width:768px){.rich_media{position:
		relative;padding: 20px 15px 15px;background-color: #fff;}}.rich_media_content{text-align:justify;} .rich_media_content * {max-width:100%!important;box-sizing: border-box!important;-webkit-box-sizing:
		border-box!important;word-wrap: break-word!important;}.rich_media_content
		blockquote {margin: 0;padding-left: 10px;border-left: 3px solid #dbdbdb;}.rich_media_content
		.list-paddingleft-2 {padding-left: 2.2em;}a.rich_media_meta_nickname{display: none;}@media screen and (min-width:1025px){.rich_media{position:relative;}a.rich_media_meta_nickname{display:inline-block!important;}span.rich_media_meta_nickname
		{display: inline-block!important;}.rich_media {width:677px;margin-left:auto;margin-right:auto;}}a.fwjm{font-size: 12px;color: #ececec;}.tenvideo_player {position: relative;width:
		100 %;height: 100 %;margin: auto;background: #000;}* {margin:0px;padding:0px;} body{line-height: 1.6;letter-spacing: .034em;}
		.dy_all {text-align: center;margin: 30px 0;} .dy_all a {display: inline-block;height:
		38px;line-height: 38px;padding: 0 18px;background-color: #009688;color:
		#fff;white-space: nowrap;font-size: 14px;border: none;border-radius: 2px;cursor:
		pointer;text-align: center;outline: 0;-webkit-appearance: none;transition:
		all .3s;-webkit-transition: all .3s;box-sizing: border-box;} img{max-width: 677px!important;}

		.crawler-info{padding: 8px 0;} .article-link>img{margin-left: 20px;width: 16px;}
		.comment-item::before,.comment-item::after{content:'';display:block;height:0;visibility:hidden;clear:both;*zoom:1;} .comment-item{margin-bottom:30px;}
		.avatar{width:12%; padding-right:10px;float:left;box-sizing:border-box;} .avatar img{width:100%;}
		.comment-body{float:left;width:88%;} .comment-body .comment-info{color:#b3b3b3;margin-bottom:4px;margin-top: -5px;} .comment-body .comment-info>span:last-child{float:right;} 
		.comment-author{border-left:4px solid green;padding-left:6px;margin:8px 0;}

		@media screen and (max-width: 420px) {.article-link>img {margin-left: 0px;}}
		@media screen and (min-width: 480px) {.avatar {width: 9%;}.comment-body {width: 91%;}}
	</style>
</head>
<body>
	<div id='js_article' class='rich_media'>
		<div class="crawler-info">
			<a href='https://www.52pojie.cn' class='fwjm' target='_blank'>
				提供的爬取软件来源于：52pojie.cn@夜泉 免费下载使用
			</a>
			<a href='https://mp.weixin.qq.com/s?__biz=MzI3NzA5MzUxNA==&amp;mid=2664601805&amp;idx=1&amp;sn=aa012fda88eaf2758f24ff58b6b2e028&amp;chksm=f04db528c73a3c3eddea0d77b5b9c039b164a85c0e9aa01d312577a611ed9d305c59828656ba&amp;scene=27#wechat_redirect&cpage=74' target='_blank' class="article-link">
				<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAMAAABA3o1rAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjk4QUEzQzVDNkNGQjExRTk5NzNBQ0VBMjgzMjY1NjkwIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjk4QUEzQzVENkNGQjExRTk5NzNBQ0VBMjgzMjY1NjkwIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OThBQTNDNUE2Q0ZCMTFFOTk3M0FDRUEyODMyNjU2OTAiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OThBQTNDNUI2Q0ZCMTFFOTk3M0FDRUEyODMyNjU2OTAiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5TKSKsAAAAclBMVEUuLi77+/stLS1VVVXx8fFOTk7s7Ozt7e1qamp5eXlNTU2WlpZFRUU6Ojrq6urn5+d/f3/8/Pw9PT0/Pz+YmJg8PDyZmZlAQECfn5+QkJBBQUFra2vo6OhDQ0OSkpKenp5WVlY+Pj7r6+tpaWksLCz///9o6ILHAAAAJnRSTlP/////////////////////////////////////////////////AKd6gbwAAACNSURBVHjajJHpEoIwDISDVMotcnuCmLz/K9KCdlqO6v7p7Mw3yW4KxG85fnUkIVfZ5J0SsCtqcgRw0HzjQYY2AAOIdRuaK4ReAPJ5nmglL5qICahpU60C0uXguQ9TgIwGJoDnT9z/ABmxt60ot0N2CsDLfb9mvBxs9ql+n5o9bEDBgbif7/1F4g80CjAAqrVAnnsm5f8AAAAASUVORK5CYII=" />
			</a>
		</div>
		<div id="img-content">

                
                <h2 class="rich_media_title" id="activity-name">Haskell 中的单子——洪峰老师讲创客道（三十五）</h2>
                <div id="meta_content" class="rich_media_meta_list">
                                                                                                            <span class="rich_media_meta rich_media_meta_text">
                                                        洪峰
                                                    </span>
                                                                
                                        <span class="rich_media_meta rich_media_meta_nickname" id="profileBt"><a href="javascript:void(0);">Linux内核之旅</a>
                      <div id="js_profile_qrcode" class="profile_container" style="display:none;">
                          <div class="profile_inner">
                              <strong class="profile_nickname">Linux内核之旅</strong>
                              <img class="profile_avatar" id="js_profile_qrcode_img" src="" alt="">

                              <p class="profile_meta">
                              <label class="profile_meta_label">微信号</label>
                              <span class="profile_meta_value">LinuxKernelTravel</span>
                              </p>

                              <p class="profile_meta">
                              <label class="profile_meta_label">功能介绍</label>
                              <span class="profile_meta_value">Linux内核之旅</span>
                              </p>
                              
                          </div>
                          <span class="profile_arrow_wrp" id="js_profile_arrow_wrp">
                              <i class="profile_arrow arrow_out"></i>
                              <i class="profile_arrow arrow_in"></i>
                          </span>
                      </div>
                    </span>


                    <em id="publish_time" class="rich_media_meta rich_media_meta_text">2016-04-16</em>





                </div>

                
                
                                
                
                
                
                                                
                                                                
                                
                
                <div class="rich_media_content " id="js_content">
                    

                    

                    
                    
                    <p style="text-indent:28px"><span style=""><iframe class="video_iframe" style="   z-index:1; " height="375" width="500" frameborder="0" src="https://v.qq.com/iframe/preview.html?vid=d019178gq8u&amp;width=500&amp;height=375&amp;auto=0" allowfullscreen=""></iframe><br  /></span></p><p style="text-indent:28px"><span style="">在上一讲中，我给大家介绍了范畴论中的范畴和函子的概念，大家已经看到有了范畴和函子的概念以后，</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">语言的类型系统变得丰富起来。我们拥有类型类，通过类型类定义范畴到范畴之间的态射。范畴到范畴之间的态射实际上也是形影关系，所以它也可以用一个箭头来表示。与原来定义在集合之间的函数关系不一样的是，这个时候我们可以把重点放在从一个范畴中的箭头到另外一个范畴中的箭头的形影关系上。</span></p><p style="text-indent:28px"><span style="">在此基础上，</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">语言的设计师对于范畴论的内容进行了深入的研究，根据范畴论的基础提出了单子的概念。这里有听众会问，</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">语言引入单子的目的究竟是什么？根据我的理解，我认为引入单子的目的有两个：一个是要在</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">语言中支持函数的多态性；另外一个是利用单子解决对纯与不纯混合的状态的支持，因为</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">语言是纯函数式编程语言。这两个理由我认为是</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">语言的设计师引入单子的根本原因，这两个方面的设计，相互之间也产生了新的有趣的现象。下面我就顺着这两条线索进行解说。<span style="font-family:Arial">&nbsp;</span></span></p><p style="text-indent:28px"><span style="">在开始这一讲的内容之前，我这里向大家打个招呼，这一讲的内容时间上比较长，请大家保持耐心听下去。而且你一旦听懂了这个讲座中我说的内容的话，你会在自己的编程生涯中，终身受益。前面我已经提到了掌握运用范畴论是我们理解</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">语言的关键，从范畴论的角度掌握理解</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">语言有事半功倍的效果。在我前面提到的斯普林格出版社出版的范畴论的著作中，<span style="font-family:Arial">Saunders&nbsp;Mac&nbsp;Lane</span><span style="">是怎么定义单子的呢？我们先看看他给出的数学定义，在这本书中</span><span style="font-family:Arial">&nbsp;Mac&nbsp;Lane</span><span style="">教授并没有很快的给出单子的概念，他迟在第六章，就是</span><span style="font-family:Arial">Monads&nbsp;and&nbsp;Algebras</span><span style="">这一章才给出了单子的定义。要介绍单子的定义，首先要搞清楚一个概念叫</span><span style="font-family:Arial">&nbsp;EndoFunctor</span><span style="">。它是一个特殊的函子，表示范畴</span><span style="font-family:Arial">X</span><span style="">到范畴</span><span style="font-family:Arial">X</span><span style="">自身的态射。有了这个</span><span style="font-family:Arial">EndoFunctor</span><span style="">之后呢，就有这么一个定义。一个单子是一个四元组，它是由范畴</span><span style="font-family:Arial">X</span><span style="">，态射</span><span style="font-family:Arial">T</span><span style="">，还有两个自然变换η和μ构成的四元组。也就是说在一个范畴</span><span style="font-family:Arial">X</span><span style="">中的函子，我们叫做</span><span style="font-family:Arial">T</span><span style="">，</span><span style="font-family:Arial">T</span><span style="">是</span><span style="font-family:Arial">X</span><span style="">到</span><span style="font-family:Arial">X</span><span style="">自身的态射。而且η和μ是两个自然变换，一个变换——η是一个自然变换，另外一个变化——μ是</span><span style="font-family:Arial">T</span><span style="">平方，也就是</span><span style="font-family:Arial">T</span><span style="">与</span><span style="font-family:Arial">T</span><span style="">的复合的自然变换。自然变换就是从一个函子到另外一个函子的形影关系。这两个自然变换一个叫η一个叫μ，它们在</span><span style="font-family:Arial">T</span><span style="">的三次方也就是</span><span style="font-family:Arial">T</span><span style="">的三次复合、</span><span style="font-family:Arial">T</span><span style="">的平方也就是</span><span style="font-family:Arial">T</span><span style="">的二次复合与</span><span style="font-family:Arial">T</span><span style="">之间建立了一个四边形的关系，以及由另个四边形拼起来的图解。</span><span style="font-family:Arial">&nbsp;</span></span></p><p style="text-indent:28px"><span style="">这个图解在这本书的<span style="font-family:Arial">137</span><span style="">页给出了清晰的说明。在</span><span style="font-family:Arial">Mac&nbsp;Lane</span><span style="">教授给出的定义中，我们看到出现了</span><span style="font-family:Arial">EndoFunctor</span><span style="">——一种具有自反关系的函子。这里我们有必要回顾一下，我们在</span><span style="font-family:Arial">PM1/2/3</span><span style="">的</span><span style="font-family:Arial">3</span><span style="">中讲集合论的时候关于自反关系的一些内容。我们知道自反关系是一种特殊的二元关系，也就是一个元素自己与自己的关系。在图论里面，用一个箭头指向自身来表示自反关系。当我们把映射、态射或者是自反关系当做一个动作的时候，在汉语里面找不到反声动词来表达态射。而在其他的语言里面，比如说俄语里面有所谓的反声动词来表示自己与自己的关系。俄语中的</span></span><span style=";font-size:16px">одеватьатье</span><span style="">和<span style="font-family:Arial">&nbsp;&nbsp;</span></span><span style=";font-size:16px">одеваться</span><span style="">&nbsp;&nbsp;<span style="">这两个词，就有词义上的微妙差异。</span><span style="font-family:Arial">&nbsp;&nbsp;</span></span><span style=";font-size:16px">одеватьатье</span><span style="">&nbsp;<span style="">是给别人穿衣，比如说妈妈给小孩穿衣，就是</span></span><span style=";font-size:16px">одеватьатье</span><span style="">。如果是妈妈自己给自己穿衣服就是，</span><span style=";font-size:16px">одеваться</span><span style="font-size: 16px; font-family: Arial; color: rgb(255, 76, 0);">（这两句俄语小编尽力了，ORZ...<span style="">）</span></span><span style="">。俄语中这种词很多，比如说：脱衣、洗澡、穿戴、洗脸、刮脸、理发、梳头、穿鞋、擦手、擦脸还有隐藏等等。俄语对于中国人之所以难学是因为他有很多的曲折变化，包括一些汉语中没有的语法。现代汉语是一种词素语言，所以我们需要用新增加单词来表示自反关系。比如说我刚才讲的妈妈给自己穿衣服，给自己穿衣服就是新增加的词汇来表达反声的概念。当然了，汉语的神奇和伟大在他的词汇里面也得到了反应。比如说内省这个词，这个词就是表示自反关系。在儒家经典著作《论语》中有这样的话：曾子曰，吾日三省吾身，为人谋而不忠乎？与朋友交而不信乎？传不习乎？这里的吾日三省吾身中的省就是内省的意思。<span style="font-family:Arial">&nbsp;</span></span></p><p><span style="">&nbsp;&nbsp;&nbsp;&nbsp;在艺术的领域里，自己与自己有关的有很多的作品。我这里列举一例，在我上大学的时期（八几年的时候）曾经流行过法国的吉他演奏家尼古拉·德·安捷罗斯<span style="font-family:Arial">&nbsp;(Nicolas&nbsp;de&nbsp;Angelis)</span><span style="">他演奏的一首非常有名的吉他曲目，叫做《镜中的安娜》。尼古拉是伟大的西班牙集团演奏家安德列斯&nbsp;塞戈维亚（</span><span style="font-family:Arial">Andres&nbsp;Segovia</span><span style="">）的学生，塞戈维亚一生有很多教学活动，所以他的桃李满天下。《镜中的安娜》曲目的法文原名是《</span><span style="font-family:Arial">Quelques&nbsp;Notes&nbsp;Pour&nbsp;Anna</span><span style="">》，翻译成中文应该是《几张写给安娜的便条》。我问过我许多的朋友，他们听了这个曲目后有什么样的感受，每个人的回答都是不尽相同的。我听了这首曲目后我的感受是安娜应该是作曲者的女朋友，作者无法向安娜倾诉心中的爱慕之意，所以作者在自己的心中和自己对话，表达对安娜的爱慕之意，整个曲目听起来罗曼蒂克非常浪漫。有时候有一些听众问我，如何让程序员具有艺术修养。我的答案很简单，多听听像镜中的安娜这样的罗曼蒂克的曲目，会有助于提高你的艺术修养。</span><span style="font-family:Arial">&nbsp;</span></span></p><p style="text-indent:28px"><span style="">佛教里的佛也是讲觉悟了的人，觉悟了就含有内省的意思。我们知道佛教的流派很多，但是不论哪一派哪一宗教，基本思想都是一样的。从学的角度来看，那就是信、解、行、正，从教的角度来看，就是教、礼、行、苟这四个方面。无论那个流派，在具体实践的时候，第一步就是要让修行者内省，从而发现自我。如果他发现不了自我，就做不到忘我。忘我首先要有一个我，有自我的存在，才能做到忘我。不能忘我，也就进入不了诸法无我的状态。这也是三法印之一。我以前跟一个朋友讨论佛法的关系的时候，我跟他写过一首诗。诗是这样写的：五蕴不空有极善，性色明深转义链。万千大众诸此界，飘萍浮梗业因缘。立地成佛一念间，内省方得悟真界。古今如来多少法，自反关系第一关。</span></p><p><span style="">这里已经有同学坐不住了，他说洪老师你说了这么多关于自反关系，那么自反关系跟我们的</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">语言究竟有什么关系呢？别急，洪老师讲课一贯是三兼顾的，我谈哲理和数理最终的目的还是要把机理方面的事说清楚，最后一定会回到我们具体的机理层次上来。</span></p><p style="text-indent:28px"><span style="">在前面的讲座中我在介绍</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">的类型系统的时候，我已经给大家介绍过</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">的类型系统有一个很重要的特征就是：它的类型系统是静态（<span style="font-family:Arial">Static</span><span style="">）的。从</span></span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">的编译器的角度来看，</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">编译器所维护的符号表里面，在关于类型的子表中，一条记录插入以后，在这个程序相关类型所存在的生命周期里，他是不会发生变化的。我这里说的不会变化指的是这条记录在这个类型子表中的存在不会发生变化。只要这条记录所刻画的类型被程序所需要，也就是说它的生命周期还没有结束，它就会作为一条记录一直存放在子表中。</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">语言的类型系统最为微妙的地方也就是这里，我刚才说了，记录在它的生命周期里会存在下去，但是并不等于记录是单一的。实际上，记录所刻画的类型里面还可能有其他的很多子类型在里面。我们把这个称为类型的多态。所以要全面准确的理解</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">的类型系统，我们必须对多态性（<span style="font-family:Arial">Polymorphic</span><span style="">）进行详细的考察。</span></span></p><p style="text-indent:28px"><span style="">在北宋的时候，有一位伟大的诗人叫苏轼（苏东坡），这个大家都知道。他文采飞扬，才气过人。关于他的传说有很多，其中有一个是这样讲的。有一天北方某一个邻国的一位使者来到了北宋王朝，在宫廷上当着皇上的面，给他出了一副对联的上联，让北宋的文武百官对出下联。上联是这么写的：三光日月星。这个对联非常难对。为什么呢？因为日月星把天上所有发光的东西都说完了，下联必须要根据这个特点说，而且下联必须在气势上超过上联，要不然就被北方的使者羞辱了。当时很多人一时想不出好的办法，这个时候苏东坡出场了。他对出了下联，叫做：四诗风雅颂。下联在字数上跟上联完全一样，都是五个字，但是下联的内容要比上联来的多。因为上联是三光，下联是四诗，多一个。这里有一个什么窍门呢？苏东坡知道诗经里面有风雅颂，而雅有大雅和小雅，因此诗经由原来的风雅颂三种变成了四种。苏东坡的下联非常好的回击了北方来使的嚣张气焰，因为这幅下联说了风雅颂，地上的所有的诗的典范都收录在诗三百里边，而风雅颂是我们中原人民的发明创造，不是你们北方的蛮荒民族写出来的。所以下联在气势上完全压住了上联。苏东坡在对联里面巧妙利用了大雅和小雅都是雅的多态性，战胜了北方的使者。</span></p><p style="text-indent:28px"><span style="">在编程语言中，编程语言对类型多态性的支持很早就有了。比方说在<span style="font-family:Arial">Lisp</span><span style="">语言里面可以通过一个空的函数，我们叫做分类对策的函数，你可以写很多分叉，每一个分叉你可以根据外面传进来的参数绑定到一个</span><span style="font-family:Arial">Lambda</span><span style="">表达式上去，这样同一个函数的名称在</span><span style="font-family:Arial">default</span><span style="">特殊表里面就可以根据传入的参数类型选择所对应的绑定。大家看，</span><span style="font-family:Arial">Lisp</span><span style="">语言我们前面讲过，是人类历史上第二门被发明出来的高级语言，在五十年代末期就已经被发明出来。&nbsp;从那个时代开始，函数的多态性在</span><span style="font-family:Arial">Lisp</span><span style="">里面已经存在而且的到了很好的支持。这里可以看出数学家们发明的语言，比工程师们发明的编程语言在概念上要先进很多、领先很多。为了让大家明白我的这个说法，这里来分析一下</span><span style="font-family:Arial">C/C++</span><span style="">语言是如何支持函数的多态性的。</span></span></p><p><span style="">我们知道<span style="font-family:Arial">C/C++</span><span style="">语言的发明人都是贝尔实验室的工程师。我们先看看</span><span style="font-family:Arial">C</span><span style="">语言如何支持函数的多态性的，令人吃惊的是，在</span><span style="font-family:Arial">C</span><span style="">语言的语言规范里面没有所谓的函数多态性的说法，他实际上变成了黑客的一个编程的技巧，而这个技巧通过指向函数的指针达成的。具体到编程实践上讲就是，你可以先声明一个指向函数的指针，用我们现在的语言讲就是给出了一个函数的签名，然后根据函数的签名实现多种版本，而且有一个限制，所有的函数版本的函数名是不一样的。因为如果函数名是一样的话就位于内存中的同一个地址。</span><span style="font-family:Arial">C</span><span style="">语言中在默认的情况下，所有的函数指针是存放在同一段内存区间的。如果你的函数名称一样的话他是不是会指向这个区间的同一个起始地址呢？这样就造成冲突了。所以必须在声明函数的时候，使得每一个函数的名称都不一样，但是它们支持同一个函数签名。这时，你可以通过对指向函数指针赋值，来达到实现对多态函数的支持。比如说计算圆周率的值，在数学上有很多不同的算法，根据算法可以做出一个函数来实现，而函数的实现满足同一函数的签名，当然这个函数签名是有约定的。但是具体计算细节也就是函数的函数体不一样。这是在</span><span style="font-family:Arial">C</span><span style="">语言里面对多态性支持的第一个技巧。这个技巧显然有很多限制，比如：函数签名必须是一样的，虽然函数体实现可以不一样。为了支持不一样的函数签名，应该怎么办呢？这里也有很多的技巧，其中的一种技巧就是声明一个</span><span style="font-family:Arial">struct</span><span style="">，在结构里面写很多的字段，每一个字段都是指向函数的指针，有多少字段就有多少指向函数的指针，通过这个办法可以实现对多态函数的支持。然而，这一切的一切都是黑客的编程技巧，而不是编程语言本身所支持的语言特性。这里我还要指出，刚才说的技巧，全部都是编译时的多态，也就是说根据程序源代码制造出来的多态。</span></span></p><p style="text-indent:28px"><span style="">在理解了<span style="font-family:Arial">C</span><span style="">语言对函数多态支持之后，我们开看看</span><span style="font-family:Arial">C++</span><span style="">语言是如何实现对函数多态支持的。我们已经知道</span><span style="font-family:Arial">C++</span><span style="">语言对</span><span style="font-family:Arial">C</span><span style="">语言的扩展基本上有三个方面：一个是类，通过封装性，把一堆逻辑上相关联的代码封装到类里面，从而从计算的力度上改善了</span><span style="font-family:Arial">C</span><span style="">的语言特点；第二个是继承性，可以用类的继承机制达到代码的某种重用；这两个特点我们</span><span style="font-family:Arial">C</span><span style="">语言里面可以通过技巧实现，而</span><span style="font-family:Arial">C++</span><span style="">语言对</span><span style="font-family:Arial">C</span><span style="">语言的根本性扩展是应该在多态性的支持上。为什么这么讲呢？因为</span><span style="font-family:Arial">C++</span><span style="">语言对函数多态性的支持，既有编译时多态性支持也有运行时多态性支持。关于这两点，我下面稍微详细展开一下。</span></span></p><p style="text-indent:28px"><span style="">C++<span style="">中在编译时对函数多态性的支持是比较好理解的，如果大家有</span><span style="font-family:Arial">C</span><span style="">语言的基础的话。</span><span style="font-family:Arial">C++</span><span style="">直接支持函数的重载（</span><span style="font-family:Arial">Overloading&nbsp;of&nbsp;Functions</span><span style="">），也就是说对同一个函数他的返回值不一样、传入参数表中的参数个数或者类型不一样，我们都可以用同一个函数名声明和构造函数。这个用法非常好，在</span><span style="font-family:Arial">C++</span><span style="">里面对一个类的构造函数的编写我们可以大量使用重载函数。对一个类而言，我们有多种方法从类中构造出不同的对象来。不同的对象就是通过使用不同的构造函数得来的，构造函数名称和类名相同。在这个特殊函数中，我们可以向构造函数提供不同的参数，从而让类得到不同的实例化，得到不同的对象。函数重载在</span><span style="font-family:Arial">C++</span><span style="">中非常常见，不光是用在类的构造函数中，对于其他函数也可以重载。在类的继承性中，子类对于超类的某一个</span><span style="font-family:Arial">virtual</span><span style="">函数字段，在子类中我们可以重新定义，这个叫对函数的重叠（</span><span style="font-family:Arial">Overrading</span><span style="">），这也是编译时多态性的支持。除此之外</span><span style="font-family:Arial">C++</span><span style="">提供了对函数运行时多态性的支持，这个是怎么实现的呢？在类中放入一个纯虚函数，比如说这个函数叫</span><span style="font-family:Arial">fuba</span><span style="">，定义一个</span><span style="font-family:Arial">virtual&nbsp;fuba&nbsp;=&nbsp;0</span><span style="">，通过这种形式构造一个类，这个类是不能被实例化的。含有纯虚函数的类，在</span><span style="font-family:Arial">C++</span><span style="">里面我们称之为抽象类。在</span><span style="font-family:Arial">Java</span><span style="">语言里面，把这个概念也推广了，延伸到了</span><span style="font-family:Arial">Interface</span><span style="">上。同时</span><span style="font-family:Arial">Java</span><span style="">语言本身直接提供了对抽象类的支持，可以使用</span><span style="font-family:Arial">Abstract</span><span style="">这个关键词来修饰</span><span style="font-family:Arial">class</span><span style="">这种方式定义一个抽象类。当</span><span style="font-family:Arial">C++</span><span style="">编译器遇到了含有纯虚函数的抽象类的时候，会把这个类编译成为指向表的入口的占位符，表中有许多条记录。记录究竟对应到一个什么样的函数实现上去呢？这个是在运行时才会发生真正的绑定。运行时与一个具体的函数的绑定，需要借助操作系统文件系统的帮助才能实现。这就是说在</span><span style="font-family:Arial">C++</span><span style="">的发展历史上，对动态链接库（</span><span style="font-family:Arial">Unix</span><span style="">社团里面叫</span><span style="font-family:Arial">shared&nbsp;Object</span><span style="">）的支持一直有好坏两种争论。为什么呢？因为一个软件会存在许多的版本，一旦使用了动态链接库或者我们叫做共享文件，对于共享文件的版本管理成为一个让人很头痛的问题。这个问题为什么让人如此头痛呢？因为原来的老版本会使用一个接口，然后使用老版本的函数实现。而新版本发布以后，仍然会编译到同一个接口上去。这个时候文件系统对这个版本的变换并不知情，在安装的时候就有可能把新的函数实现作为新的动态链接库增加到操作系统中去。程序运行的时候就有不知道要绑定老版本函数的实现还是绑定新版本函数的实现，这就是许多软件</span><span style="font-family:Arial">bug</span><span style="">的来源。针对这个问题，有许多的补救措施。补救措施大部分围绕文件系统，利用文件系统对不同的版本实施版本编号，通过版本编号的不同区分不同实现的动态链接库，从而解决这个迷惑。还有一些方案是使用静态链接库，就是说我把软件版本所需要所有的共享文件作为一个静态链接库打包到应用程序中，一同发布。然而，种种此类补救措施都不能弥补</span><span style="font-family:Arial">C++</span><span style="">编译器对运行时多态支持上的缺陷。</span></span></p><p style="text-indent:28px"><span style="">从我刚才分析的情况来看，通过对比<span style="font-family:Arial">Lisp</span><span style="">语言发明和</span><span style="font-family:Arial">C/C++</span><span style="">的语言发明，我们看出工程师们发明出来的语言虽然在工程上可行，但是在语言的优美和简洁方面是不如数学家们发明的语言的。</span></span></p><p style="text-indent:28px"><span style="">现在我们回过头来看看</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">，在我的讲座里面面，当我谈论</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">的时候，我一直是把它作为一个<span style="font-family:Arial">Lisp</span><span style="">语言的现代版本看待的，为什么呢？因为</span></span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">语言是纯函数式编程语言，纯函数式编程语言是<span style="font-family:Arial">Lisp</span><span style="">语言的一个显著特征，另外</span><span style="font-family:Arial">Lisp</span><span style="">语言依赖的</span><span style="font-family:Arial">Lambda</span><span style="">演算在</span></span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">里面也得到了直接的支持和应用。而且</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">语言和<span style="font-family:Arial">Lisp</span><span style="">语言相比，在许许多多的问题上，比如它做事的时候、在设计的时候，它显得更加具有原则性。我这里说的原则性主要是指类型和类型系统方面，关于类型的构造、检查和自动推导方面。而且</span></span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">的编译器非常聪明，它会把原来<span style="font-family:Arial">Lisp</span><span style="">系统在类型中所做的关于类型检查方面的工作、类型构造方面的工作全推到编译时完成。说的在明白一些就是</span></span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">语言的编译器会在程序编译时，利用类型类和我们前面提到的函子以及我现在正在讲的单子的概念，把对于类型的构造以及对于构造出来的类型的使用放在程序的编译中完成。这个构成了</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">语言的函数多态性丰富的内容。后面我会讲到</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">语言函数多态性这套机制比<span style="font-family:Arial">C++</span><span style="">以及其他语言这套机制简洁优美很多。这也是</span></span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">语言能在当今的软件界掀起一场生产力革命的一个根本原因。</span></p><p style="text-indent:28px"><span style="">这里要讲到的单子的概念与函数的多态性是密切相关的。刚才通过举例说明了什么叫多态性，什么叫函数的多态性。在</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">中，单子首先定义成为一个范畴到他自身的态射，数学的术语叫<span style="font-family:Arial">EndoFunctor</span><span style="">。这里为什么要用具有自反关系的态射呢？答案现在看起来是非常简单的，因为我需要利用</span><span style="font-family:Arial">EndoFuncror</span><span style="">对我们编译器所维护的符号表中关于类型的子表中的某一条记录进行某种操作，换句话说就是让这条记录内部可以运作的空间变得非常大，从而可以容纳更多的类型，也就是达到我们所讲的函数的多态，为了在一条类型记录里面，我们不妨把类型里面的这一条记录视为一个范畴，为了在这一范畴里面增加新的类型，那么我们就需要在这个范畴里面设计一个机制，让这个机制可以构造新的类型，也就是说我们要有一种机制在记录进入内部它可以有一种</span><span style="font-family:Arial">Type&nbsp;Constructor(</span><span style="">类型构造器</span><span style="font-family:Arial">)</span><span style="">，前面我已经说过多次，在</span></span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">语言里函数是一个类型，也就是说一旦我们能够在<span style="font-family:Arial">type&nbsp;class</span><span style="">里面能够找到一种机制让这个函数作为一种新的类型被构造出来，那我们就达到了我们的目的，而要做到这一点，就有必要向大家介绍一个概念，叫做</span><span style="font-family:Arial">Aplication&nbsp;of&nbsp;Functor</span><span style="">（应用函子）</span><span style="font-family:Arial">,</span><span style="">请大家注意，这个应用函子可以被单子所利用，也可以不被单子利用单独的存在，也就是说</span><span style="font-family:Arial">Aplication&nbsp;of&nbsp;Functor</span><span style="">既可以作为一个范畴到另外一个范畴之间的态射，也可以像单子那样用于一个范畴到它自身的态射，这个</span><span style="font-family:Arial">Aplication&nbsp;of&nbsp;Functor</span><span style="">听起来神乎其神但实际上它是</span><span style="font-family:Arial">Lisp</span><span style="">语言和</span><span style="font-family:Arial">Racket</span><span style="">语言里</span><span style="font-family:Arial">map</span><span style="">函数的一个推广</span><span style="font-family:Arial">.</span><span style="">我们知道在</span><span style="font-family:Arial">Lisp</span><span style="">和</span><span style="font-family:Arial">Racket</span><span style="">里边</span><span style="font-family:Arial">map</span><span style="">是把一个函数施加到一个链表上去</span><span style="font-family:Arial">,</span><span style="">然后构造出一个新的链表，这个新的链表中的每一个元素都已经被给的那个函数作用过。这就是</span><span style="font-family:Arial">map</span><span style="">高阶旋子的一个本质。</span><span style="font-family:Arial">Aplication&nbsp;of&nbsp;Functor</span><span style="">我们称为</span><span style="font-family:Arial">Fmap</span><span style="">，这个</span><span style="font-family:Arial">Fmap</span><span style="">实际上是</span><span style="font-family:Arial">Racket</span><span style="">里</span><span style="font-family:Arial">map</span><span style="">的一个升级版，和</span><span style="font-family:Arial">map</span><span style="">非常相似，它也要提供一个函数，比如说</span><span style="font-family:Arial">a</span></span><span style="">-&gt;</span><span style="">b<span style="">。</span></span></p><p style="text-indent:28px"><span style="">它的第二个参数不是像<span style="font-family:Arial">map</span><span style="">那样是一个链表，而是一个函数，我们写成</span><span style="font-family:Arial">f(a)</span><span style="">，这个</span><span style="font-family:Arial">Fmap</span><span style="">的返回值也是一个函数我们写成</span><span style="font-family:Arial">f(b)</span><span style="">，我在黑客道教学实践中讲述</span></span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">语言时发现许多学员在这里卡了，为什么呢？因为他们没有理解函数的签名和这个函数的应用这两者之间存在的重大的差别，其实这个差别一旦说清楚了也很好理解，以<span style="font-family:Arial">Fmap</span><span style="">为例，</span><span style="font-family:Arial">Fmap</span><span style="">里边的第一个参数就是一个函数，这个函数是以签名的形式给出来的，那就是</span><span style="font-family:Arial">a-&gt;b</span><span style="">的形式给出的，而后面的</span><span style="font-family:Arial">f(a)</span><span style="">以及它的返回值</span><span style="font-family:Arial">f(b)</span><span style="">都是以函数应用的形式给出来的，回忆一下前面我给大家讲</span><span style="font-family:Arial">Lambda</span><span style="">演算的时候，我给大家讲过</span><span style="font-family:Arial">Lambda</span><span style="">演算的定义有四种形式，第一个代表一个常量，第二个代表一个变量，第三个是代表一个表达式对另一个表达式施加一种作用，最后一个就是</span><span style="font-family:Arial">Lambda</span><span style="">表达式本身的定义，它可以定义成一个参数，一个点后边带一个</span><span style="font-family:Arial">Lambda</span><span style="">表达式，说明对</span><span style="font-family:Arial">Lambda</span><span style="">表达式的实现，我们刚才提到的</span><span style="font-family:Arial">f(a)</span><span style="">或者</span><span style="font-family:Arial">f(b)</span><span style="">实际上就是把一个函数施加到一个你提供给它的数据上面去，比方说</span><span style="font-family:Arial">a</span><span style="">或者</span><span style="font-family:Arial">b</span><span style="">上面去，我们可以类比</span><span style="font-family:Arial">C++</span><span style="">中的构造函数，我们知道在</span><span style="font-family:Arial">C++</span><span style="">中的构造函数是你需要向构造函数提供构造对象的初始值，你向构造函数提供不同的初始值和不同的类型的话，那么你这时候从同一个类中调用构造函数所构造出的对象是不一样的。</span></span></p><p style="text-indent:28px"><span style="">在我们<span style="font-family:Arial">Fmap</span><span style="">里面</span><span style="font-family:Arial">f(a)</span><span style="">和</span><span style="font-family:Arial">f(b)</span><span style="">会向你提供一个值或者表达式叫做</span><span style="font-family:Arial">a</span><span style="">，那么你这个</span><span style="font-family:Arial">f(a)</span><span style="">会施加到所给的这个值上面去，也就是</span><span style="font-family:Arial">a</span><span style="">上面去，然后你会构造出一个新的类型，对于返回值那就是</span><span style="font-family:Arial">f(b)</span><span style="">，也就是说我会对</span><span style="font-family:Arial">b</span><span style="">值施加</span><span style="font-family:Arial">f</span><span style="">函数的作用，然后把类型构造出来，我们可以从函数复合的角度看待</span><span style="font-family:Arial">Fmap</span><span style="">，如果我们刚才定义中出现的</span><span style="font-family:Arial">f(a)</span><span style="">可以写成一个函数，比方说</span><span style="font-family:Arial">r-&gt;a</span><span style="">，返回值</span><span style="font-family:Arial">f(b)</span><span style="">可以写成另外一个函数</span><span style="font-family:Arial">r-&gt;b</span><span style="">，那么这个时候</span><span style="font-family:Arial">Fmap</span><span style="">所做的工作就是把两个函数复合成一个新的函数，哪两个函数？一个是</span><span style="font-family:Arial">r-&gt;a,</span><span style="">另外一个是</span><span style="font-family:Arial">a-&gt;b,</span><span style="">这两个函数中间是不是都有</span><span style="font-family:Arial">a</span><span style="">，中间这个</span><span style="font-family:Arial">a</span><span style="">可以通过结合法则把它去掉，那就变成了</span><span style="font-family:Arial">r-&gt;b</span><span style="">，所以说</span><span style="font-family:Arial">Fmap</span><span style="">这是一个函子，是</span><span style="font-family:Arial">map</span><span style="">的升级版，从函数复合的角度看它就是普通的函数的复合，我们还可以知道函数的复合本质上是形影关系的一种复合，那么这一种思路我们也可以推广到函数与函子的复合，函子与函子的复合等等这些所有关于形影关系的操作上去</span><span style="font-family:Arial">.</span></span></p><p style="text-indent:28px"><span style="">刚才<span style="font-family:Arial">Fmap</span><span style="">这个函子的定义中，</span><span style="font-family:Arial">Aplication&nbsp;of&nbsp;Functor</span><span style="">的定义中出现的</span><span style="font-family:Arial">f(a)</span><span style="">和</span><span style="font-family:Arial">f(b)</span><span style="">中的</span><span style="font-family:Arial">f</span><span style="">我们既可以把它看成一个函数也可以把它视为一个函子，具体把它视为什么取决于程序设计的定义，不管怎样，从类型构造的角度来看我们都是提供了一个值，把这个值提供给一个类型构造函数，我们叫做</span><span style="font-family:Arial">Type&nbsp;Constructor</span><span style="">，这个</span><span style="font-family:Arial">Type&nbsp;Constructor</span><span style="">也就是我们在</span><span style="font-family:Arial">Fmap</span><span style="">函数里提到的</span><span style="font-family:Arial">f</span><span style="">，它会吸纳闭包</span></span><span style=""><span style="">的值，然后进行类型的构造，这就是类型构造函数的本质，在有些讲解</span></span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">的书里，有些作者把这个<span style="font-family:Arial">f</span><span style="">形象化的比喻成一个盒子，或者说成一种环境，我认为这种比方都是恰当的，为什么呢？因为把它当成一个盒子也好，一个环境也好，本质上都是一个</span></span><span style=";font-size:16px;font-family:Arial">闭包</span><span style="">，我们就是说把一个值传给一个</span><span style=";font-size:16px;font-family:Arial">闭包</span><span style="">，让这个</span><span style=";font-size:16px;font-family:Arial">闭包吸纳</span><span style="">这个值以后进行的类型构造，这就是<span style="font-family:Arial">Fmap</span><span style="">工作的本质，所以说</span><span style="font-family:Arial">Fmap</span><span style="">看起来神秘兮兮的，但是我们从函数的复合和类型的构造这个角度来看的话，它的本质是一目了然的，所以这个拦道虎可以很轻松的干掉</span><span style="font-family:Arial">.</span></span></p><p style="text-indent:28px"><span style="">相比第一头被干掉的拦道虎下边第二头拦道虎难度会大一点，因为什么呢？因为这个涉及到</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">类型系统里边类型构造的时候是可以带参数的，比方说</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">里边用的很多<span style="font-family:Arial">Maybe</span><span style="">，</span><span style="font-family:Arial">Maybe</span><span style="">可以视为</span><span style="font-family:Arial">Type&nbsp;Constructor</span><span style="">，就是类型的构造函数，它可以构造出一个失败的类型，我们叫做</span><span style="font-family:Arial">Nothing</span><span style="">，也可以构造出一个成功的类型，我们把它称之为</span><span style="font-family:Arial">Just&nbsp;a</span><span style="">，说到这里请大家回顾一下我讲</span><span style="font-family:Arial">Lisp</span><span style="">语言的时候，讲非确定计算的时候我给大家讲过一首词，就是三国演义这部小说开头的《临江仙》，滚滚长江东逝水，浪花淘尽英雄，是非成败转头空。青山依旧在，几度夕阳红。你看看在这个词里面，是非成败转头空，这个是非成败是不是含有两种状态啊，它既有成功的状态也有失败的状态，那么对于我的类型构造函数而言也可以考虑成功的状态和失败的状态，这个都体现在</span><span style="font-family:Arial">Maybe</span><span style="">这个类型构造函数里面，换句话讲，函子的</span><span style="font-family:Arial">Aplication</span><span style="">里边</span><span style="font-family:Arial">Fmap</span><span style="">的定义让计算具有回朔性，而我前边讲希腊故事的时候讲过这个回朔具有线的概念，也就是连续的概念，所以回到我们</span></span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">里边讲单子的时候当我们把一个值放到一个<span style="font-family:Arial">Lambda</span><span style="">表达式里面去，把它放到一个函数里面去、放到一个盒子里面去或者放到一个环境里面去的时候，对它的类型构造有可能成功也有可能失败，那么如何去应对这一种情况呢？</span></span></p><p style="text-indent:28px"><span style="">我们在单子的定义里面出现了大于、大于等于的概念，也就是说对于提供了一个值的一个环境，比方说<span style="font-family:Arial">m(a)</span><span style="">就是一个类型构造的函数，我们同时还会提供一个函数，这个函数是从</span><span style="font-family:Arial">a</span><span style="">这个值映射到（</span><span style="font-family:Arial">-&gt;</span><span style="">）</span><span style="font-family:Arial">m(b)</span><span style="">上面去，也就是把一个值</span><span style="font-family:Arial">b</span><span style="">放到一个环境中去，然后它的返回值就是把</span><span style="font-family:Arial">b</span><span style="">放到这个环境中去，这叫做连续这个函数，这个是单子的第二个要件。前面我讲的把一个值放给一个环境，传递一个</span></span><span style=";font-size:16px;font-family:Arial">闭包</span><span style="">，这个在单子的定义里被定义为<span style="font-family:Arial">Return</span><span style="">，注意</span></span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">里面的</span><span style=";font-size:16px;font-family:Arial">r</span><span style="">eturn<span style="">和其它语言比如说</span><span style="font-family:Arial">C</span><span style="">或者</span><span style="font-family:Arial">C++</span><span style="">里面</span></span><span style=";font-size:16px;font-family:Arial">r</span><span style="">return<span style="">是完全不一样的，</span></span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">里面的</span><span style=";font-size:16px;font-family:Arial">r</span><span style="">eturn<span style="">是针对你给定的值，为这个值施加一个环境，也就是提供一个</span><span style="font-family:Arial">Lambda</span><span style="">，提供一个</span></span><span style=";font-size:16px;font-family:Arial">闭包</span><span style="">给这个提供的值施加到这个值上面去，单子的第二个构成的要件就是要运算或者函数与函数之间产生函数的复合，具有某种连续，这个连续是通过</span><span style=";font-size:16px;font-family:Arial">幺半群</span><span style="">来实现的，这个地方我要提醒大家注意这个</span><span style=";font-size:16px;font-family:Arial">幺半群</span><span style="">的使用，我前面讲过这个是针对一种运算而言，这个运算要满足封闭性，满足结合律，同时它还要具有单位元，要有这三个运算才称为幺半群，单子的定义里面关于第二个要件它就一定会和我们的幺半群发生关联，只是这个地方我们原来的运算范围已经扩大到了一个范畴。</span></p><p style="text-indent:28px"><span style="">定义单子的第三个要件实际上就是为我刚才提到的函数的复合提供某种保证，让它在它失败的情况下也能成功，具体来讲就是一个<span style="font-family:Arial">a</span><span style="">我们把它放到一个</span></span><span style=";font-size:16px;font-family:Arial">闭包</span><span style="">里面去，就是<span style="font-family:Arial">m(a),</span><span style="">这是第一件，然后第二件就是对于一个值</span><span style="font-family:Arial">b</span><span style="">我们也把它放到一个</span></span><span style=";font-size:16px;font-family:Arial">闭包</span><span style="">里面去<span style="font-family:Arial">,</span><span style="">叫做</span><span style="font-family:Arial">m(b),</span><span style="">那么这两个参数会有一个返回值，那就是我们得到把</span><span style="font-family:Arial">b</span><span style="">放回到</span></span><span style=";font-size:16px;font-family:Arial">闭包</span><span style="">m<span style="">里面去，这个是由两个大于符号写在一起表示的，表示某种连续性，也就是说我会确认你对这一个类型构造成功性我会进行某种确认，保证你一定回朔会成功，这就是单子的第三个要件。</span></span></p><p style="text-indent:28px"><span style="">最后一个要件就是一旦我出错的时候会有出错的一些信息来以字符串的形式告诉程序员，这个作为第四个要件我们可以把它写到单子里面。所以说总体来看单子作为它的定义来讲，作为它在</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">语言里面的定义来讲，和单子在范畴论里面的定义是有一些差异的，但是无论它则么复杂，我刚才提到关于单子的四个要件从我们范畴论的角度理解都是十分容易的，这一点我向大家说明一下。那么到此为止关于</span><span style=";font-size:16px;font-family:Arial">Haskell</span><span style="">语言第二个轮回讲解它动的部分，也就是函数、函子和单子的概念我就到此全部结束了，在这一讲中我们已经清楚的看到单子就是一种特殊的<span style="font-family:Arial">En</span><span style="">，</span><span style="font-family:Arial">EndoFunctor</span><span style="">是一种特殊的函子，引入单子的目的之一关于函数多态性的概念我在这一讲已经花了很多的时间去讲解，那么在下一讲我会介绍如何使用单子去模拟状态的变化，这是下一讲的主题。</span></span></p><p><span style="">&nbsp;</span></p><p><br  /></p>
                </div>
                

                
  <div class="ct_mpda_wrp" id="js_sponsor_ad_area" style="display: none;"></div>


                
                <div class="read-more__area" id="js_more_read_area" style="display:none;">
                    
                </div>

                
                                <div class="reward_area tc reward_area_primary" id="js_preview_reward_author" style="display:none;">
                    <div class="reward-avatar" style="display: none;" id="js_preview_reward_author_avatar">
                        <img src="" alt="" id="js_preview_reward_author_head">
                    </div>
                    
                                        <div class="reward-author" id="js_preview_reward_author_name">洪峰</div>
                                        <p class="reward_tips" id="js_preview_reward_author_wording" style="display:none;"></p>
                    <p class="reward_button_wrp">
                    
                      <span class="reward_pop_panel">
                        <img src="https://res.wx.qq.com/mpres/zh_CN/htmledition/pages/home/index/pic_mp_app4290ba.png" alt="">
                        <strong>扫一扫下载订阅号助手，用手机发文章</strong>
                      </span>
                        <a class="reward_button" id='js_preview_reward_author_link' href="##"><span id="js_preview_reward_link_text">赞赏</span></a>
                    </p>
                </div>

                <div class="reward_qrcode_area reward_area tc" id="js_preview_reward_qrcode" style="display:none;">
                    <p class="tips_global">长按二维码向我转账</p>
                    <p id="js_preview_reward_ios_wording" class="reward_tips" style="display:none;"></p>
                    <span class="reward_qrcode_img_wrp"><img class="reward_qrcode_img" src="res.wx.qq.com/mmbizwap/zh_CN/htmledition/images/pic/appmsg/pic_reward_qrcode.2x42f400.png"></span>
                    <p class="tips_global">受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。</p>
                </div>
                            </div>
		<div class="comment">
			<h3 style="margin:26px 0;font-weight:100;padding-bottom:4px;border-bottom:1px solid #ccc;">精选留言</h3>
		    暂无...
		</div>
	</div>
	<div class='dy_all'>
		<a href='https://www.52pojie.cn/' target='_blank'>
			吾爱破解论坛
		</a>
	</div>
</body>