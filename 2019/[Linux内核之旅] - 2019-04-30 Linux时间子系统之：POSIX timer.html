<!DOCTYPE html>
<head>
	<meta http-equiv='Content-Type' content='text/html;charset=utf-8'>
	<meta name='viewport' content='width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no'>
	<title>
		Linux时间子系统之：POSIX timer
	</title>
	<script src='https://cdn.bootcss.com/jquery/1.10.2/jquery.min.js'>
	</script>
	<style>
		a {color: #607fa6;text-decoration:none;word-wrap:break-word;word-break:break-all;}.rich_media_title{padding-bottom:10px;margin-bottom:14px;border-bottom:1px solid #e7e7eb;font-weight:400;} .rich_media_meta_list{font-size:14px;margin-bottom: 22px;}
		.rich_media_meta{display:inline-block;vertical-align:middle;margin-right:8px;margin-bottom:10px;font-size:14px;}.rich_media_meta_text{color:#8c8c8c;color:rgba(0, 0, 0, 0.3)}.rich_media_meta_list
		em {font-style: normal;}@media screen and (max-width:768px){.rich_media{position:
		relative;padding: 20px 15px 15px;background-color: #fff;}}.rich_media_content{text-align:justify;} .rich_media_content * {max-width:100%!important;box-sizing: border-box!important;-webkit-box-sizing:
		border-box!important;word-wrap: break-word!important;}.rich_media_content
		blockquote {margin: 0;padding-left: 10px;border-left: 3px solid #dbdbdb;}.rich_media_content
		.list-paddingleft-2 {padding-left: 2.2em;}a.rich_media_meta_nickname{display: none;}@media screen and (min-width:1025px){.rich_media{position:relative;}a.rich_media_meta_nickname{display:inline-block!important;}span.rich_media_meta_nickname
		{display: inline-block!important;}.rich_media {width:677px;margin-left:auto;margin-right:auto;}}a.fwjm{font-size: 12px;color: #ececec;}.tenvideo_player {position: relative;width:
		100 %;height: 100 %;margin: auto;background: #000;}* {margin:0px;padding:0px;} body{line-height: 1.6;letter-spacing: .034em;}
		.dy_all {text-align: center;margin: 30px 0;} .dy_all a {display: inline-block;height:
		38px;line-height: 38px;padding: 0 18px;background-color: #009688;color:
		#fff;white-space: nowrap;font-size: 14px;border: none;border-radius: 2px;cursor:
		pointer;text-align: center;outline: 0;-webkit-appearance: none;transition:
		all .3s;-webkit-transition: all .3s;box-sizing: border-box;} img{max-width: 677px!important;}

		.crawler-info{padding: 8px 0;} .article-link>img{margin-left: 20px;width: 16px;}
		.comment-item::before,.comment-item::after{content:'';display:block;height:0;visibility:hidden;clear:both;*zoom:1;} .comment-item{margin-bottom:30px;}
		.avatar{width:12%; padding-right:10px;float:left;box-sizing:border-box;} .avatar img{width:100%;}
		.comment-body{float:left;width:88%;} .comment-body .comment-info{color:#b3b3b3;margin-bottom:4px;margin-top: -5px;} .comment-body .comment-info>span:last-child{float:right;} 
		.comment-author{border-left:4px solid green;padding-left:6px;margin:8px 0;}

		@media screen and (max-width: 420px) {.article-link>img {margin-left: 0px;}}
		@media screen and (min-width: 480px) {.avatar {width: 9%;}.comment-body {width: 91%;}}
	</style>
</head>
<body>
	<div id='js_article' class='rich_media'>
		<div class="crawler-info">
			<a href='https://www.52pojie.cn' class='fwjm' target='_blank'>
				提供的爬取软件来源于：52pojie.cn@夜泉 免费下载使用
			</a>
			<a href='https://mp.weixin.qq.com/s?__biz=MzI3NzA5MzUxNA==&amp;mid=2664606415&amp;idx=1&amp;sn=ca2fa6d35d432fd25927b1dbf701d890&amp;chksm=f04d872ac73a0e3c086ed3383ad04c65f2a1ed185793c984424717da79a58c94813b9fcad704&amp;scene=27#wechat_redirect&cpage=5' target='_blank' class="article-link">
				<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAMAAABA3o1rAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjk4QUEzQzVDNkNGQjExRTk5NzNBQ0VBMjgzMjY1NjkwIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjk4QUEzQzVENkNGQjExRTk5NzNBQ0VBMjgzMjY1NjkwIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OThBQTNDNUE2Q0ZCMTFFOTk3M0FDRUEyODMyNjU2OTAiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OThBQTNDNUI2Q0ZCMTFFOTk3M0FDRUEyODMyNjU2OTAiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5TKSKsAAAAclBMVEUuLi77+/stLS1VVVXx8fFOTk7s7Ozt7e1qamp5eXlNTU2WlpZFRUU6Ojrq6urn5+d/f3/8/Pw9PT0/Pz+YmJg8PDyZmZlAQECfn5+QkJBBQUFra2vo6OhDQ0OSkpKenp5WVlY+Pj7r6+tpaWksLCz///9o6ILHAAAAJnRSTlP/////////////////////////////////////////////////AKd6gbwAAACNSURBVHjajJHpEoIwDISDVMotcnuCmLz/K9KCdlqO6v7p7Mw3yW4KxG85fnUkIVfZ5J0SsCtqcgRw0HzjQYY2AAOIdRuaK4ReAPJ5nmglL5qICahpU60C0uXguQ9TgIwGJoDnT9z/ABmxt60ot0N2CsDLfb9mvBxs9ql+n5o9bEDBgbif7/1F4g80CjAAqrVAnnsm5f8AAAAASUVORK5CYII=" />
			</a>
		</div>
		<div id="img-content">

                
                <h2 class="rich_media_title" id="activity-name">Linux时间子系统之：POSIX timer</h2>
                <div id="meta_content" class="rich_media_meta_list">
                                                                                                            <span class="rich_media_meta rich_media_meta_text">
                                                        linuxer
                                                    </span>
                                                                
                                        <span class="rich_media_meta rich_media_meta_nickname" id="profileBt"><a href="javascript:void(0);">Linux内核之旅</a>
                      <div id="js_profile_qrcode" class="profile_container" style="display:none;">
                          <div class="profile_inner">
                              <strong class="profile_nickname">Linux内核之旅</strong>
                              <img class="profile_avatar" id="js_profile_qrcode_img" src="" alt="">

                              <p class="profile_meta">
                              <label class="profile_meta_label">微信号</label>
                              <span class="profile_meta_value">LinuxKernelTravel</span>
                              </p>

                              <p class="profile_meta">
                              <label class="profile_meta_label">功能介绍</label>
                              <span class="profile_meta_value">Linux内核之旅</span>
                              </p>
                              
                          </div>
                          <span class="profile_arrow_wrp" id="js_profile_arrow_wrp">
                              <i class="profile_arrow arrow_out"></i>
                              <i class="profile_arrow arrow_in"></i>
                          </span>
                      </div>
                    </span>


                    <em id="publish_time" class="rich_media_meta rich_media_meta_text">2019-04-30</em>





                </div>

                
                
                                
                
                
                
                                                
                                                                
                                
                
                <div class="rich_media_content " id="js_content">
                    

                    

                    
                    
                    <p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">一、前言</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">在用户空间接口函数文档中，我们描述了和POSIX timer相关的操作，主要包括创建一个timer、设定timer、获取timer的状态、获取timer overrun的信息、删除timer。本文将沿着这些用户空间的接口定义来看看内核态的实现。虽然POSIX timer可以基于各种不同的clock创建，本文主要描述real time clock相关的timer。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">本文第二章描述了POSIX timer的基本原理，第三章描述系统调用的具体实现，第四章主要讲real time clock的timer callback函数的实现，第五章介绍了timer超期后，内核如何处理信号。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">&nbsp;</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">二、基本概念和工作原理</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">1、如何标识POSIX timer</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">POSIX.1b interval timer（后面的文章中简称POSIX timer）是用来替代传统的interval timer的，posix timer一个重要的改进是进程可以创建更多（而不是3个）timer，既然可以创建多个timer，那么就存在标识问题，我们用timer ID来标识一个具体的posix timer。这个timer ID也作为一个handler参数在用户空间和内核空间之间传递。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">posix timer是一种资源，它隶属于某一个进程，。对于kernel，我们会用timer ID来标识一个POSIX timer，而这个ID是由进程自己管理和分配的。在进程控制块（struct task_struct ）中有一个struct signal_struct *signal的成员，用来管理和signal相关的控制数据。timer的处理和信号的发送是有关系的，因此也放到该数据结构中：</p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">……&nbsp;<br  />&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; posix_timer_id;&nbsp;<br  />……</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">一个进程在fork的时候，posix_timer_id会被设定为0，因此，对于一个进程而言，其timer ID从0开始分配，随后会依次加一，达到最大值后会从0开始。由此可见，timer ID不是一个全局唯一标识符，只是能保证在一个进程内，其ID是唯一的。实际timer ID的分配算法可以参考posix_timer_add函数，如下：</p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">static int posix_timer_add(struct k_itimer *timer)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct signal_struct *sig = current-&gt;signal;&nbsp;<br  />&nbsp;&nbsp;&nbsp; int first_free_id = sig-&gt;posix_timer_id;－－－－－－－－－－－－－－－－（1）&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct hlist_head *head;&nbsp;<br  />&nbsp;&nbsp;&nbsp; int ret = -ENOENT;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; do {－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－（2）&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spin_lock(&amp;hash_lock);&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; head = &amp;posix_timers_hashtable[hash(sig, sig-&gt;posix_timer_id)];－－－－（3）&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!__posix_timers_find(head, sig, sig-&gt;posix_timer_id)) {－－－－－－－－（4）&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hlist_add_head_rcu(&amp;timer-&gt;t_hash, head);&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = sig-&gt;posix_timer_id;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (++sig-&gt;posix_timer_id &lt; 0)－－－－－－－－－－－－－－－－－－－－（5）&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sig-&gt;posix_timer_id = 0;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((sig-&gt;posix_timer_id == first_free_id) &amp;&amp; (ret == -ENOENT))－－－－－－（6）&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = -EAGAIN;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spin_unlock(&amp;hash_lock);&nbsp;<br  />&nbsp;&nbsp;&nbsp; } while (ret == -ENOENT);&nbsp;<br  />&nbsp;&nbsp;&nbsp; return ret;&nbsp;<br  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（1）sig-&gt;posix_timer_id中记录了上一次分配的ID+1，该值被认为是下一个可以使用的free ID（当然，这个假设不一定成立，但是有很大的机会），也就是本次scan free timer ID的起点位置。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（2）do while是一个循环过程，如果选定的timer ID不是free的，我们还需要++sig-&gt;posix_timer_id，以便看看下一个timer ID是否是free的，这个过程不断的循环执行，直到找到一个free的timer ID，或者出错退出循环。一旦找到free的timer ID，则将该posix timer插入哈希表。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（3）根据分配的timer ID和该进程的signal descriptor的地址，找到该posix timer的hash链表头</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（4）看看该进程中是否已经有了该timer ID的posix timer存在，如果没有，那么timer ID分配完成</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（5）否则，看看下一个timer ID的情况。如果溢出（超过了INT_MAX），那么从0开始搜索</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（6）如果scan了一圈还是没有找到free timer ID，那么就出错返回。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">2、如何组织POSIX timer</p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">static DEFINE_HASHTABLE(posix_timers_hashtable, 9);&nbsp;<br  />static DEFINE_SPINLOCK(hash_lock);</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">随着系统启动和运行，各个进程会不断的创建属于自己的POSIX timer，这些timer被放到了一个全局的hash表中，也就是posix_timers_hashtable。该table共计有512个入口，每个入口都是一个POSIX timer链表头的指针。每一个系统中的POSIX timer都会根据其hash key放入到其中一个入口中（挂入链表）。具体hash key的计算方法是：</p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">static int hash(struct signal_struct *sig, unsigned int nr)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; return hash_32(hash32_ptr(sig) ^ nr, HASH_BITS(posix_timers_hashtable));&nbsp;<br  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">计算key考虑的factor包括timer ID值和进程signal descriptor的地址。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">hash_lock是包含全局POSIX timer的锁，每次访问该资源的时候需要使用该锁进行保护。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">除了作为一个全局资源来管理的hash table，每个进程也会管理自己分配和释放的timer资源，当然，这也是通过链表进行管理的，链表头在该进程signal descriptor的posix_timers成员中：</p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">……&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct list_head&nbsp;&nbsp;&nbsp; posix_timers;&nbsp;<br  />……</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">一旦进程创建了一个timer，那么就会挂入posix_timers的链表中。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">3、如何抽象POSIX timer</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">在内核中用struct k_itimer 来描述一个POSIX timer：</p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">struct k_itimer {&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct list_head list;&nbsp;&nbsp; －－－－－－－－－－－－－－－－－－－－－－－－－－（1）&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct hlist_node t_hash;&nbsp;&nbsp;<br  />&nbsp;&nbsp;&nbsp; spinlock_t it_lock; －－－－－保护本数据结构的spin lock&nbsp;<br  />&nbsp;&nbsp;&nbsp; clockid_t it_clock;－－－－－－－－－－－－－－－－－－－－－－－－－－－－（2）&nbsp;<br  />&nbsp;&nbsp;&nbsp; timer_t it_id;&nbsp;<br  />&nbsp;&nbsp;&nbsp; int it_overrun;&nbsp; －－－－－－－－－－－－－－－－－－－－－－－－－－－－－（3）&nbsp;<br  />&nbsp;&nbsp;&nbsp; int it_overrun_last;&nbsp;&nbsp;<br  />&nbsp;&nbsp;&nbsp; int it_requeue_pending;&nbsp; －－－－－－－－－－－－－－－－－－－－－－－－－（4）&nbsp;<br  />#define REQUEUE_PENDING 1&nbsp;<br  />&nbsp;&nbsp;&nbsp; int it_sigev_notify; －－－－－－－－－－－－－－－－－－－－－－－－－－－－（5）&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct signal_struct *it_signal; －－－－该timer对应的signal descriptor&nbsp;<br  />&nbsp;&nbsp;&nbsp; union { －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－（6）&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct pid *it_pid;&nbsp;&nbsp;&nbsp; /* pid of process to send signal to */&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct task_struct *it_process;&nbsp;&nbsp;&nbsp; /* for clock_nanosleep */&nbsp;<br  />&nbsp;&nbsp;&nbsp; };&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct sigqueue *sigq;&nbsp; －－－超期后，该sigquue成员会挂入signal pending队列&nbsp;<br  />&nbsp;&nbsp;&nbsp; union { －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－（7）&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct hrtimer timer;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ktime_t interval;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } real;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct cpu_timer_list cpu;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int clock;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int node;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long incr;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long expires;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } mmtimer;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct {&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct alarm alarmtimer;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ktime_t interval;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } alarm;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct rcu_head rcu;&nbsp;<br  />&nbsp;&nbsp;&nbsp; } it;&nbsp;<br  />};</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（1）这两个成员都是和POSIX timer的组织有关。t_hash是链接入全局hash table的节点，而list成员是和进程管理自己创建和释放timer的链表相关。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（2）这两个成员描述了POSIX timer的基本信息的。任何一个timer都是基于clock而构建的，it_clock说明该timer是以系统中哪一个clock为标准来计算超时时间。it_id描述了该timer的ID，在一个进程中唯一标识该timer。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（3）理解这两个成员首先对timer overrun的概念要理解。对overrun的解释我们可以用信号异步通知的例子来描述（创建进程执行callback函数也是一样的）。假设我们当一个POSIX timer超期后，会发送信号给进程，但是也有可能该信号当前被mask而导致signal handler不会调度执行（当然也有其他的场景导致overrun，这里就不描述了）。这样，我们当然想知道这种timer的overrun的次数。假设一个timer设定超期时间是1秒，那当timer超期后，会产生一个pending的signal，但是由于种种原因，在3秒后，信号被进程捕获到，调用signal handler，这时候overrun的次数就是2次。用户空间可以通过timer_getoverrun来获取这个overrun的次数。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">根据POSIX标准，当信号被递交给进程后，timer_getoverrun才会返回该timer ID的overrun count，因此在kernel中需要两个成员，只有信号还没有递交给进程，it_overrun就会不断的累积，一旦完成递交，it_overrun会保存在it_overrun_last成员中，而自己会被清除，准备进行下一次overrun count的计数。因此，实际上timer_getoverrun函数实际上是获取it_overrun_last的数据，代码如下：</p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">SYSCALL_DEFINE1(timer_getoverrun, timer_t, timer_id)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; ……</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; overrun = timr-&gt;it_overrun_last;&nbsp;<br  />&nbsp;&nbsp;&nbsp; ……</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; return overrun;&nbsp;<br  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（4）it_requeue_pending标识了该timer对应信号挂入signal pending的状态。该flag的LSB bit标识该signal已经挂入signal pending队列，其他的bit作为信号的私有数据。下面的代码会更详细的描述。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（5）it_sigev_notify成员说明了timer超期后如何异步通知该进程（线程）。定义如下：</p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">#define SIGEV_SIGNAL&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; －－－－－使用向进程发送信号的方式来通知&nbsp;<br  />#define SIGEV_NONE&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp; －－－－－－没有异步通知事件，用户空间的程序用轮询的方法&nbsp;<br  />#define SIGEV_THREAD&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; －－－－异步通知的方式是创建一个新线程来执行callback函数&nbsp;<br  />#define SIGEV_THREAD_ID 4&nbsp;&nbsp; －－－－－使用向指定线程发送信号的方式来通知</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（6）这个成员用来标识进程。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（7）it这个成员是一个union类型的，用于描述和timer interval相关的信息，不同类型的timer选择使用不同的成员数据。alarm是和alarm timer相关的成员，具体可以参考alarm timer的文档。（mmtimer不知道用在什么场合，可能和Multimedia Timer相关）。real用于real time clock的场景。real time clock的timer是构建在高精度timer上的（timer成员），而interval则描述该timer的mode，如果是one shot类型的，interval等于0，否则interval描述周期性触发timer的时间间隔。更详细的内容会在本文后面的小节中描述。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">&nbsp;</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">三、和POSIX timer相关的系统调用</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">1、创建timer的系统调用。具体代码如下：</p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">SYSCALL_DEFINE3(timer_create, const clockid_t, which_clock,&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct sigevent __user *, timer_event_spec,&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timer_t __user *, created_timer_id)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct k_clock *kc = clockid_to_kclock(which_clock);－－根据clock ID获取内核中的struct k_clock&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct k_itimer *new_timer;&nbsp;<br  />&nbsp;&nbsp;&nbsp; int error, new_timer_id;&nbsp;<br  />&nbsp;&nbsp;&nbsp; sigevent_t event;&nbsp;<br  />&nbsp;&nbsp;&nbsp; int it_id_set = IT_ID_NOT_SET;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; new_timer = alloc_posix_timer();－－－－－分配一个POSIX timer，所有成员被初始化为0</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; spin_lock_init(&amp;new_timer-&gt;it_lock);&nbsp;<br  />&nbsp;&nbsp;&nbsp; new_timer_id = posix_timer_add(new_timer);－－－－－－－－－－－（1）</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; it_id_set = IT_ID_SET;&nbsp;<br  />&nbsp;&nbsp;&nbsp; new_timer-&gt;it_id = (timer_t) new_timer_id;&nbsp;<br  />&nbsp;&nbsp;&nbsp; new_timer-&gt;it_clock = which_clock;&nbsp;<br  />&nbsp;&nbsp;&nbsp; new_timer-&gt;it_overrun = -1; －－－－－－－－－－－－－－－－－－－（2）</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; if (timer_event_spec) {&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (copy_from_user(&amp;event, timer_event_spec, sizeof (event))) {－－－－－拷贝用户空间的参数&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error = -EFAULT;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto out;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcu_read_lock();&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_timer-&gt;it_pid = get_pid(good_sigevent(&amp;event));－－－－－－－－（3）&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rcu_read_unlock();&nbsp;<br  />&nbsp;&nbsp;&nbsp; } else {&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event.sigev_notify = SIGEV_SIGNAL;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event.sigev_signo = SIGALRM;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; event.sigev_value.sival_int = new_timer-&gt;it_id;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new_timer-&gt;it_pid = get_pid(task_tgid(current));－－－－－－－－－－（4）&nbsp;<br  />&nbsp;&nbsp;&nbsp; }</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; new_timer-&gt;it_sigev_notify&nbsp;&nbsp;&nbsp;&nbsp; = event.sigev_notify;&nbsp;<br  />&nbsp;&nbsp;&nbsp; new_timer-&gt;sigq-&gt;info.si_signo = event.sigev_signo; －－信号ID&nbsp;<br  />&nbsp;&nbsp;&nbsp; new_timer-&gt;sigq-&gt;info.si_value = event.sigev_value;&nbsp;<br  />&nbsp;&nbsp;&nbsp; new_timer-&gt;sigq-&gt;info.si_tid&nbsp;&nbsp; = new_timer-&gt;it_id; －－－信号发送的目的地线程ID&nbsp;<br  />&nbsp;&nbsp;&nbsp; new_timer-&gt;sigq-&gt;info.si_code&nbsp; = SI_TIMER; －－－－－－－－－－－－－（5）</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; if (copy_to_user(created_timer_id,&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;new_timer_id, sizeof (new_timer_id))) {－－－－－－－－－－－－－（6）&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; error = -EFAULT;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; goto out;&nbsp;<br  />&nbsp;&nbsp;&nbsp; }</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; error = kc-&gt;timer_create(new_timer);－－－－－－调用具体clock的create timer函数</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; spin_lock_irq(¤t-&gt;sighand-&gt;siglock);&nbsp;<br  />&nbsp;&nbsp;&nbsp; new_timer-&gt;it_signal = current-&gt;signal;&nbsp;<br  />&nbsp;&nbsp;&nbsp; list_add(&amp;new_timer-&gt;list, ¤t-&gt;signal-&gt;posix_timers);－－－－－－－（7）&nbsp;<br  />&nbsp;&nbsp;&nbsp; spin_unlock_irq(¤t-&gt;sighand-&gt;siglock);</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; return 0;&nbsp;<br  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（1）将该timer加入到全局的哈希表中。当然，在加入之前，要分配一个timer ID，内核要确保该timer ID是在本进程内能唯一标识该timer。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（2）初始化该posix timer，设定timer ID，clock ID以及overrun的值。it_id_set这个变量主要用于出错处理，如果其值等于IT_ID_SET，说明已经完成插入全局的哈希表的操作，那么其后的出错处理要有从全局的哈希表中摘除该timer的操作（注意：上面的代码省略了出错处理，有兴趣的读者可以自行阅读）。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（3）good_sigevent这个函数主要是用来进行参数检查。用户空间的程序可以通过sigevent_t的数据结构来控制timer超期之后的行为。例如可以向某一个指定的线程（不是进程）发送信号（sigev_notify设定SIGEV_THREAD_ID并且设定SIGEV_SIGNAL），当然这时候要传递thread ID的信息。内核会根据这个thread ID来寻找对应的struct task_struct，如果找不到，那么说明用户空间传递的参数有问题。如果该thread ID对应的struct task_struct的确存在，那么还需要该thread ID对应的thread和当前thread属于同一个进程。此外，一旦程序打算用signal通知的方式来进行timer超期通知，那么传入的sigev_signo参数必须是一个有效的signal ID。如果这些检查通过，那么good_sigevent返回适当的pid信息。这里有两种场景，一种是指定thread ID，另外一种是发送给当前进程（实际上是返回当前的线程组leader）</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（4）如果用户空间的程序没有指定sigevent_t的参数，那么内核的缺省行为是发送SIGALRM给调用线程所属的线程组leader。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（5）初始化信号发送相关的数据结构。SI_TIMER用来标识该信号是由于posix timer而产生的。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（6）将分配的timer ID 拷贝回用户空间</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（7）建立posix timer和当前进程signal descriptor的关系（所有线程共享一个signal descriptor）</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">2、获取一个posix timer剩余时间的系统调用，代码如下：</p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">SYSCALL_DEFINE2(timer_gettime, timer_t, timer_id,&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct itimerspec __user *, setting)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct itimerspec cur_setting;&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct k_itimer *timr;&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct k_clock *kc;&nbsp;<br  />&nbsp;&nbsp;&nbsp; unsigned long flags;&nbsp;<br  />&nbsp;&nbsp;&nbsp; int ret = 0;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; timr = lock_timer(timer_id, &amp;flags);－－－－－－－－根据timer ID找到对应的posix timer</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; kc = clockid_to_kclock(timr-&gt;it_clock);－－－－－－根据clock ID获取内核中的struct k_clock</p><p style="padding-bottom: 15px;line-height: 20px;"><br  />&nbsp;&nbsp;&nbsp; if (WARN_ON_ONCE(!kc || !kc-&gt;timer_get))&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = -EINVAL;&nbsp;<br  />&nbsp;&nbsp;&nbsp; else&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kc-&gt;timer_get(timr, &amp;cur_setting); －－－－－－调用具体clock的get timer函数</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; unlock_timer(timr, flags);</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; if (!ret &amp;&amp; copy_to_user(setting, &amp;cur_setting, sizeof (cur_setting))) －－将结果copy到用户空间&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -EFAULT;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; return ret;&nbsp;<br  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">3、timer_getoverrun、timer_settime和timer_delete</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">这三个系统调用都非常简单，这里就不细述了，有兴趣的读者可以自行阅读。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">&nbsp;</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">四、real time clock的timer callback函数</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">对于real time base的那些clock（CLOCK_REALTIME、CLOCK_MONOTONIC等），其timer相关的函数都是构建在一个高精度timer的基础上，这个高精度timer就是posix timer中的it.real.timer成员。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">1、common_timer_create，代码如下：</p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">static int common_timer_create(struct k_itimer *new_timer)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; hrtimer_init(&amp;new_timer-&gt;it.real.timer, new_timer-&gt;it_clock, 0);&nbsp;<br  />&nbsp;&nbsp;&nbsp; return 0;&nbsp;<br  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">代码很简单，就是初始化了一个高精度timer而已。具体高精度timer的内容可以参考本站其他文档。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">2、common_timer_set，代码如下：</p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">common_timer_set(struct k_itimer *timr, int flags,&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct itimerspec *new_setting, struct itimerspec *old_setting)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct hrtimer *timer = &amp;timr-&gt;it.real.timer;－－－获取该posix timer对应的高精度timer&nbsp;<br  />&nbsp;&nbsp;&nbsp; enum hrtimer_mode mode;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; if (old_setting)&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; common_timer_get(timr, old_setting); －－－－获取旧的timer设定，参考下节描述</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; timr-&gt;it.real.interval.tv64 = 0; －－－－－－－初始化interval设定&nbsp;<br  />&nbsp;&nbsp;&nbsp; if (hrtimer_try_to_cancel(timer) &lt; 0)－－－－马上就要进行新的设定了，当然要停掉该高精度timer&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return TIMER_RETRY;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; timr-&gt;it_requeue_pending = (timr-&gt;it_requeue_pending + 2) &amp;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~REQUEUE_PENDING;&nbsp;<br  />&nbsp;&nbsp;&nbsp; timr-&gt;it_overrun_last = 0; －－－－－－－－－－－－－－－－－－－－－－－－－－－－（1）</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp; if (!new_setting-&gt;it_value.tv_sec &amp;&amp; !new_setting-&gt;it_value.tv_nsec)&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0; －－－－如果新设定的时间值等于0的话，那么该函数仅仅是停掉timer并获取old value。</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; mode = flags &amp; TIMER_ABSTIME ? HRTIMER_MODE_ABS : HRTIMER_MODE_REL; －－（2）&nbsp;<br  />&nbsp;&nbsp;&nbsp; hrtimer_init(&amp;timr-&gt;it.real.timer, timr-&gt;it_clock, mode);&nbsp;<br  />&nbsp;&nbsp;&nbsp; timr-&gt;it.real.timer.function = posix_timer_fn; －－－－－高精度timer的mode，callback函数设定</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; hrtimer_set_expires(timer, timespec_to_ktime(new_setting-&gt;it_value)); －－超期时间设定</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; timr-&gt;it.real.interval = timespec_to_ktime(new_setting-&gt;it_interval); －－－－－－－－－－（3）</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; if (((timr-&gt;it_sigev_notify &amp; ~SIGEV_THREAD_ID) == SIGEV_NONE)) { －－－－－－－－（4）&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mode == HRTIMER_MODE_REL) {&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hrtimer_add_expires(timer, timer-&gt;base-&gt;get_time());&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;&nbsp;<br  />&nbsp;&nbsp;&nbsp; }</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; hrtimer_start_expires(timer, mode); －－－－启动高精度timer&nbsp;<br  />&nbsp;&nbsp;&nbsp; return 0;&nbsp;<br  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（1）it_overrun_last实际上是和timer_getoverrun的调用有关。在一个timer触发后到异步通知完成之间可能会产生overrun，但是，一旦重新调用timer_settime之后，上次的overrun count要被清除。it_requeue_pending状态flag中的信号私有数据加一（这个私有数据是[31:1]，因此代码中加2），并且清除pending flag。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（2）这里的代码都是对该posix timer对应的高精度timer进行各种设定。该timer的callback函数会在下一章分析</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（3）设置interval的值，通过该值可以设定周期性timer，用户空间传入的参数是timespec，需转换成ktime的时间格式</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（4）对于轮询类型的posix timer，我们并不会真正启动该timer（插入到高精度timer的红黑树中），而是仅仅为那些设定相对事件的timer配置正确的超期时间值。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">3、common_timer_get，代码如下：</p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">static void common_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; ktime_t now, remaining, iv;&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct hrtimer *timer = &amp;timr-&gt;it.real.timer;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; memset(cur_setting, 0, sizeof(struct itimerspec));</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; iv = timr-&gt;it.real.interval; －－－获取该posix timer对应的timer period值</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; if (iv.tv64)－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－（1）&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur_setting-&gt;it_interval = ktime_to_timespec(iv);－－－interval timer需返回timer period&nbsp;<br  />&nbsp;&nbsp;&nbsp; else if (!hrtimer_active(timer) &amp;&amp;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (timr-&gt;it_sigev_notify &amp; ~SIGEV_THREAD_ID) != SIGEV_NONE)－－－－－－－（2）&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; now = timer-&gt;base-&gt;get_time(); －－－－－－－－－－－－－－－－－－－－－－－（3）</p><p style="padding-bottom: 15px;line-height: 20px;"><br  />&nbsp;&nbsp;&nbsp; if (iv.tv64 &amp;&amp; (timr-&gt;it_requeue_pending &amp; REQUEUE_PENDING ||&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (timr-&gt;it_sigev_notify &amp; ~SIGEV_THREAD_ID) == SIGEV_NONE))&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timr-&gt;it_overrun += (unsigned int) hrtimer_forward(timer, now, iv); －－－－－－－－（4）</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; remaining = ktime_sub(hrtimer_get_expires(timer), now); －－－计算剩余时间&nbsp;<br  />&nbsp;&nbsp;&nbsp; if (remaining.tv64 &lt;= 0) { －－已经超期&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((timr-&gt;it_sigev_notify &amp; ~SIGEV_THREAD_ID) != SIGEV_NONE)&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur_setting-&gt;it_value.tv_nsec = 1; －－－－－－－－－－－－－－－－－－－－（5）&nbsp;<br  />&nbsp;&nbsp;&nbsp; } else&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cur_setting-&gt;it_value = ktime_to_timespec(remaining); －－－返回剩余时间信息&nbsp;<br  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（1）posix timer的时间设定用struct itimerspec表示：</p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">struct itimerspec {&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct timespec it_interval;&nbsp;&nbsp;&nbsp; /* timer period */&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct timespec it_value;&nbsp;&nbsp;&nbsp; /* timer expiration */&nbsp;<br  />};</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">如果it_interval等于0的话，那么说明该posix timer是一个one shot类型的timer。如果非零的话，则说明该timer是一个periodic timer（或者称之为interval timer），it_interval定义了周期性触发的时间值。这个timer period值对应内核struct k_itimer中的it.real.interval成员。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（2）如果是one shot类型的timer，it_interval返回0值就OK了，我们只需要设定it_value值。对于通过信号进行异步通知的posix timer，如果对应的高精度timer已经不是active状态了，那么it_value值也是0，表示该timer已经触发了。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（3）获取当前时间点的值。不论timer当初是如何设定的：相对或者绝对，it_value总是返回相对于当前时间点的值，因此这里需要获取当前时间点的值。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（4）对于一个周期性触发的timer，并且设定SIGEV_NONE，实际上，该timer是不会触发的，都是用户程序自己调用timer_gettime来轮询情况，因此在get time函数中处理超期后，再次设定高精度timer的任务，同时计算overrun次数。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">如果periodic timer设定信号异步通知的方式，那么在信号pending到信号投递到进程这段时间内，虽然由于各种情况可能导致这段时间很长，按理periodic timer应该多次触发，但是实际上，信号只有在投递到进程后才会再次restart高精度timer，因此在信号pending期间，如果用户调用了timer_gettime，也需要自己处理timer的超期以及overrun。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（5）TODO。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">4、common_timer_del。比较简单，不再赘述。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">&nbsp;</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">五、和posix timer相关的信号处理</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">1、发送什么信号？发向哪一个进程或者线程？</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">用户空间的程序可以通过timer_create函数来创建timer，在创建timer的时候就设定了异步通知的方式（SIGEV_SIGNAL、SIGEV_NONE和SIGEV_THREAD），SIGEV_NONE方式比较简单，没有异步通知，用户空间的程序自己需要调用timer_gettime来轮询是否超期。SIGEV_THREAD则是创建一个线程来执行callback函数。我们这一章的场景主要描述的就是设定为SIGEV_SIGNAL方式，也就是timer超期后，发送信号来异步通知。缺省是发送给创建timer的进程，当然，也可以设定SIGEV_THREAD_ID的标识，发给一个该进程内的特定的线程。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">一个指定进程的timer超期后，产生的信号会挂入该进程（线程）pending队列，需要注意的是：在任意的时刻，特定timer的信号只会挂入一次，也就是说，该信号产生到该信号被投递到进程之间，如果timer又一次超期触发了，这时候，signal pending队列不会再次挂入信号（即便该signal是一个real-time signal），只会增加overrun的次数。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">2、信号的产生</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">在set timer函数中，内核会设定高精度timer的超期回调函数为posix_timer_fn，代码如下：</p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">static enum hrtimer_restart posix_timer_fn(struct hrtimer *timer)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct k_itimer *timr;&nbsp;<br  />&nbsp;&nbsp;&nbsp; unsigned long flags;&nbsp;<br  />&nbsp;&nbsp;&nbsp; int si_private = 0;&nbsp;<br  />&nbsp;&nbsp;&nbsp; enum hrtimer_restart ret = HRTIMER_NORESTART; －－－－－－－－－－－（1）</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; timr = container_of(timer, struct k_itimer, it.real.timer);－－－－－－－－－－－（2）&nbsp;<br  />&nbsp;&nbsp;&nbsp; spin_lock_irqsave(&amp;timr-&gt;it_lock, flags);</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; if (timr-&gt;it.real.interval.tv64 != 0)&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; si_private = ++timr-&gt;it_requeue_pending; －－－－－－－－－－－－－－－（3）</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; if (posix_timer_event(timr, si_private)) { －－－－－－－－－－－－－－－－－（4）&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果该signal的handler设定是ignor，那么需要对interval类型的timer做特别处理&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br  />&nbsp;&nbsp;&nbsp; }</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; unlock_timer(timr, flags);&nbsp;<br  />&nbsp;&nbsp;&nbsp; return ret;&nbsp;<br  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（1）高精度timer的超期callback函数的返回值标识了是否需要再次将该timer挂入队列，以便可以再次触发timer。对于one shot类型的，需要返回HRTIMER_NORESTART，对于periodic timer，需要返回HRTIMER_RESTART。缺省设定不再次start该timer。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（2）POSIX timer对应的高精度timer是嵌入到k_itimer数据结构中的，通过container_of可以获取该高精度timer对应的那个k_itimer数据。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（3）对于one shot类型的timer，不存在signal requeue的问题。对于周期性timer，有可能会有overrun的问题，这时候，需要传递一个signal的私有数据，以便在queue signal的时候进行标识。++timr-&gt;it_requeue_pending用来标记该timer处于pending状态（加一就是将LSB设定为1）</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">（4）具体将信号挂入进程（线程）signal pending队列的操作在posix_timer_event函数中，该函数会调用send_sigqueue函数进行具体操作。如下：</p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">int send_sigqueue(struct sigqueue *q, struct task_struct *t, int group)&nbsp;<br  />{……</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; ret = 0;&nbsp;<br  />&nbsp;&nbsp;&nbsp; if (unlikely(!list_empty(&amp;q-&gt;list))) {－－－－－－－－是否已经挂入signal pending队列？&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; q-&gt;info.si_overrun++;－－－－－－－－－－－－如果是，那么增加overrun counter就OK了&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ret;&nbsp;<br  />&nbsp;&nbsp;&nbsp; }&nbsp;<br  />&nbsp;&nbsp;&nbsp; q-&gt;info.si_overrun = 0; －－－－－－首次挂入signal pending队列，初始化overrun counter等于0&nbsp;<br  />&nbsp;&nbsp;&nbsp; pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;－挂入进程的还是线程的pending队列&nbsp;<br  />&nbsp;&nbsp;&nbsp; list_add_tail(&amp;q-&gt;list, &amp;pending-&gt;list);－－－－挂入pending队列&nbsp;<br  />&nbsp;&nbsp;&nbsp; sigaddset(&amp;pending-&gt;signal, sig);－－－－－－设定具体哪一个signal pending&nbsp;<br  />&nbsp;&nbsp;&nbsp; complete_signal(sig, t, group);－－－－－－－设定TIF_SIGPENDING标记&nbsp;<br  />&nbsp;&nbsp;&nbsp; ……&nbsp;<br  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">如果信号已经正确的产生了，挂入进程或者线程的signal pending队列（也有可能是仅仅增加overrun的计数），或者处理过程中发生了错误，posix_timer_event返回False，这时候整个处理就结束了。如果返回TRUE，说明该signal被进程ignor了。这时候需要一些特殊的处理。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">相信大家已经注意到了，default的情况下，该高精度timer的callback返回HRTIMER_NORESTART，即便是periodic timer也是如此，难道periodic timer不需要restart高精度timer吗？当然需要，只不过不是在这里，在投递信号的时候会处理的，具体可以参考dequeue_signal的处理。然而，如果一个periodic timer的信号处理是ignor类型的，那么信号是不会挂入pending队列的，这时候不会有信号的投递，不会调用dequeue_signal，这时候则需要在这个callback函数中处理的。这时候会设定下一个超期时间，并返回HRTIMER_RESTART，让高精度timer有机会重新挂入高精度timer的红黑树中。</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">3、信号投递到进程</p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">timer超期后会产生一个信号（配置了SIGEV_SIGNAL），这个信号虽然产生了，但是具体在什么时间点被投递到进程并执行signal处理函数呢？在ARM中断处理过程文档中，我们给出了一个场景（另外一个场景是系统调用返回用户空间，这里略过不表，思路是类似的），在返回用户空间之前，中断处理代码会检查struct thread_info中的flag标记，看看是否有_TIF_WORK_MASK的设定：</p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">#define _TIF_WORK_MASK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (_TIF_NEED_RESCHED | _TIF_SIGPENDING | _TIF_NOTIFY_RESUME)</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">如果任何一个bit有设定，那么就会调用do_work_pending来处理，如果设定了_TIF_SIGPENDING，那么就调用do_signal来处理信号，属于当前进程的pending signal会被一一处理，首先调用dequeue_signal，从队列中取出信号，然后调用signal handler执行。相关的dequeue_signal代码如下：</p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">int dequeue_signal(struct task_struct *tsk, sigset_t *mask, siginfo_t *info)&nbsp;<br  />{……&nbsp;<br  />&nbsp;&nbsp;&nbsp; if ((info-&gt;si_code &amp; __SI_MASK) == __SI_TIMER &amp;&amp; info-&gt;si_sys_private) {&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spin_unlock(&amp;tsk-&gt;sighand-&gt;siglock);&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do_schedule_next_timer(info);&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spin_lock(&amp;tsk-&gt;sighand-&gt;siglock);&nbsp;<br  />&nbsp;&nbsp;&nbsp; }&nbsp;<br  />&nbsp;&nbsp;&nbsp; return signr;&nbsp;<br  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">如果你想通过发生信号的方式进行异步通知，那么必须要设定si_code为SI_TIMER。对于real time的clock，do_schedule_next_timer函数会调用schedule_next_timer来处理periodic timer的restart：</p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;">static void schedule_next_timer(struct k_itimer *timr)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct hrtimer *timer = &amp;timr-&gt;it.real.timer;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; if (timr-&gt;it.real.interval.tv64 == 0)－－－one shot类型的，直接退出&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; timr-&gt;it_overrun += (unsigned int) hrtimer_forward(timer,－－－设定下次超期时间并计算overrun次数&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timer-&gt;base-&gt;get_time(),&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timr-&gt;it.real.interval);</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; timr-&gt;it_overrun_last = timr-&gt;it_overrun;－－－保存该timer的overrun次数&nbsp;<br  />&nbsp;&nbsp;&nbsp; timr-&gt;it_overrun = -1;－－－－为下次初始化overrun&nbsp;<br  />&nbsp;&nbsp;&nbsp; ++timr-&gt;it_requeue_pending;－－－－－－清除pending标记并增加信号私有数据域&nbsp;<br  />&nbsp;&nbsp;&nbsp; hrtimer_restart(timer);－－－－restart该timer&nbsp;<br  />}</p></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><br  /></p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 15px;color: rgb(255, 0, 0);"><em>本文转自“蜗窝科技”</em></span></p>
                </div>
                

                
  <div class="ct_mpda_wrp" id="js_sponsor_ad_area" style="display: none;"></div>


                
                <div class="read-more__area" id="js_more_read_area" style="display:none;">
                    
                </div>

                
                                <div class="reward_area tc reward_area_primary" id="js_preview_reward_author" style="display:none;">
                    <div class="reward-avatar" style="display: none;" id="js_preview_reward_author_avatar">
                        <img src="" alt="" id="js_preview_reward_author_head">
                    </div>
                    
                                        <div class="reward-author" id="js_preview_reward_author_name">linuxer</div>
                                        <p class="reward_tips" id="js_preview_reward_author_wording" style="display:none;"></p>
                    <p class="reward_button_wrp">
                    
                      <span class="reward_pop_panel">
                        <img src="https://res.wx.qq.com/mpres/zh_CN/htmledition/pages/home/index/pic_mp_app4290ba.png" alt="">
                        <strong>扫一扫下载订阅号助手，用手机发文章</strong>
                      </span>
                        <a class="reward_button" id='js_preview_reward_author_link' href="##"><span id="js_preview_reward_link_text">赞赏</span></a>
                    </p>
                </div>

                <div class="reward_qrcode_area reward_area tc" id="js_preview_reward_qrcode" style="display:none;">
                    <p class="tips_global">长按二维码向我转账</p>
                    <p id="js_preview_reward_ios_wording" class="reward_tips" style="display:none;"></p>
                    <span class="reward_qrcode_img_wrp"><img class="reward_qrcode_img" src="res.wx.qq.com/mmbizwap/zh_CN/htmledition/images/pic/appmsg/pic_reward_qrcode.2x42f400.png"></span>
                    <p class="tips_global">受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。</p>
                </div>
                            </div>
		<div class="comment">
			<h3 style="margin:26px 0;font-weight:100;padding-bottom:4px;border-bottom:1px solid #ccc;">精选留言</h3>
		    暂无...
		</div>
	</div>
	<div class='dy_all'>
		<a href='http://www.wowotech.net/timer_subsystem/posix-timer.html' target='_blank'>
			阅读全文
		</a>
	</div>
</body>