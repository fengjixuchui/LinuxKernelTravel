<!DOCTYPE html>
<head>
	<meta http-equiv='Content-Type' content='text/html;charset=utf-8'>
	<meta name='viewport' content='width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no'>
	<title>
		copy_{to,from}_user()的思考
	</title>
	<script src='https://cdn.bootcss.com/jquery/1.10.2/jquery.min.js'>
	</script>
	<style>
		a {color: #607fa6;text-decoration:none;word-wrap:break-word;word-break:break-all;}.rich_media_title{padding-bottom:10px;margin-bottom:14px;border-bottom:1px solid #e7e7eb;font-weight:400;} .rich_media_meta_list{font-size:14px;margin-bottom: 22px;}
		.rich_media_meta{display:inline-block;vertical-align:middle;margin-right:8px;margin-bottom:10px;font-size:14px;}.rich_media_meta_text{color:#8c8c8c;color:rgba(0, 0, 0, 0.3)}.rich_media_meta_list
		em {font-style: normal;}@media screen and (max-width:768px){.rich_media{position:
		relative;padding: 20px 15px 15px;background-color: #fff;}}.rich_media_content{text-align:justify;} .rich_media_content * {max-width:100%!important;box-sizing: border-box!important;-webkit-box-sizing:
		border-box!important;word-wrap: break-word!important;}.rich_media_content
		blockquote {margin: 0;padding-left: 10px;border-left: 3px solid #dbdbdb;}.rich_media_content
		.list-paddingleft-2 {padding-left: 2.2em;}a.rich_media_meta_nickname{display: none;}@media screen and (min-width:1025px){.rich_media{position:relative;}a.rich_media_meta_nickname{display:inline-block!important;}span.rich_media_meta_nickname
		{display: inline-block!important;}.rich_media {width:677px;margin-left:auto;margin-right:auto;}}a.fwjm{font-size: 12px;color: #ececec;}.tenvideo_player {position: relative;width:
		100 %;height: 100 %;margin: auto;background: #000;}* {margin:0px;padding:0px;} body{line-height: 1.6;letter-spacing: .034em;}
		.dy_all {text-align: center;margin: 30px 0;} .dy_all a {display: inline-block;height:
		38px;line-height: 38px;padding: 0 18px;background-color: #009688;color:
		#fff;white-space: nowrap;font-size: 14px;border: none;border-radius: 2px;cursor:
		pointer;text-align: center;outline: 0;-webkit-appearance: none;transition:
		all .3s;-webkit-transition: all .3s;box-sizing: border-box;} img{max-width: 677px!important;}

		.crawler-info{padding: 8px 0;} .article-link>img{margin-left: 20px;width: 16px;}
		.comment-item::before,.comment-item::after{content:'';display:block;height:0;visibility:hidden;clear:both;*zoom:1;} .comment-item{margin-bottom:30px;}
		.avatar{width:12%; padding-right:10px;float:left;box-sizing:border-box;} .avatar img{width:100%;}
		.comment-body{float:left;width:88%;} .comment-body .comment-info{color:#b3b3b3;margin-bottom:4px;margin-top: -5px;} .comment-body .comment-info>span:last-child{float:right;} 
		.comment-author{border-left:4px solid green;padding-left:6px;margin:8px 0;}

		@media screen and (max-width: 420px) {.article-link>img {margin-left: 0px;}}
		@media screen and (min-width: 480px) {.avatar {width: 9%;}.comment-body {width: 91%;}}
	</style>
</head>
<body>
	<div id='js_article' class='rich_media'>
		<div class="crawler-info">
			<a href='https://www.52pojie.cn' class='fwjm' target='_blank'>
				提供的爬取软件来源于：52pojie.cn@夜泉 免费下载使用
			</a>
			<a href='https://mp.weixin.qq.com/s?__biz=MzI3NzA5MzUxNA==&amp;mid=2664606438&amp;idx=1&amp;sn=c16631a8e70c8c58fa3ec0c336c58302&amp;chksm=f04d8703c73a0e1567a48a7948aa53092ded1fcfa432f713bc82b4864c26ee9701e364c68edb&amp;scene=27#wechat_redirect&cpage=5' target='_blank' class="article-link">
				<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAMAAABA3o1rAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjk4QUEzQzVDNkNGQjExRTk5NzNBQ0VBMjgzMjY1NjkwIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjk4QUEzQzVENkNGQjExRTk5NzNBQ0VBMjgzMjY1NjkwIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OThBQTNDNUE2Q0ZCMTFFOTk3M0FDRUEyODMyNjU2OTAiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OThBQTNDNUI2Q0ZCMTFFOTk3M0FDRUEyODMyNjU2OTAiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5TKSKsAAAAclBMVEUuLi77+/stLS1VVVXx8fFOTk7s7Ozt7e1qamp5eXlNTU2WlpZFRUU6Ojrq6urn5+d/f3/8/Pw9PT0/Pz+YmJg8PDyZmZlAQECfn5+QkJBBQUFra2vo6OhDQ0OSkpKenp5WVlY+Pj7r6+tpaWksLCz///9o6ILHAAAAJnRSTlP/////////////////////////////////////////////////AKd6gbwAAACNSURBVHjajJHpEoIwDISDVMotcnuCmLz/K9KCdlqO6v7p7Mw3yW4KxG85fnUkIVfZ5J0SsCtqcgRw0HzjQYY2AAOIdRuaK4ReAPJ5nmglL5qICahpU60C0uXguQ9TgIwGJoDnT9z/ABmxt60ot0N2CsDLfb9mvBxs9ql+n5o9bEDBgbif7/1F4g80CjAAqrVAnnsm5f8AAAAASUVORK5CYII=" />
			</a>
		</div>
		<div id="img-content">

                
                <h2 class="rich_media_title" id="activity-name">copy_{to,from}_user()的思考</h2>
                <div id="meta_content" class="rich_media_meta_list">
                                                                                                            <span class="rich_media_meta rich_media_meta_text">
                                                        smcdef
                                                    </span>
                                                                
                                        <span class="rich_media_meta rich_media_meta_nickname" id="profileBt"><a href="javascript:void(0);">Linux内核之旅</a>
                      <div id="js_profile_qrcode" class="profile_container" style="display:none;">
                          <div class="profile_inner">
                              <strong class="profile_nickname">Linux内核之旅</strong>
                              <img class="profile_avatar" id="js_profile_qrcode_img" src="" alt="">

                              <p class="profile_meta">
                              <label class="profile_meta_label">微信号</label>
                              <span class="profile_meta_value">LinuxKernelTravel</span>
                              </p>

                              <p class="profile_meta">
                              <label class="profile_meta_label">功能介绍</label>
                              <span class="profile_meta_value">Linux内核之旅</span>
                              </p>
                              
                          </div>
                          <span class="profile_arrow_wrp" id="js_profile_arrow_wrp">
                              <i class="profile_arrow arrow_out"></i>
                              <i class="profile_arrow arrow_in"></i>
                          </span>
                      </div>
                    </span>


                    <em id="publish_time" class="rich_media_meta rich_media_meta_text">2019-05-07</em>





                </div>

                
                
                                
                
                
                
                                                
                                                                
                                
                
                <div class="rich_media_content " id="js_content">
                    

                    

                    
                    
                    <h2 style="color: rgb(31, 31, 31);font-size: 18px;font-weight: bold;margin-top: 25px;margin-bottom: 10px;font-family: Arial, Helvetica, sans-serif;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 24px;">引言</span></h2><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">我们对copy_{to,from}_user()接口的使用应该是再熟悉不过吧。基本Linux书籍都会介绍它的作用。毕竟它是kernel space和user space沟通的桥梁。所有的数据交互都应该使用类似这种接口。所以，我们没有理由不知道接口的作用。但是，我也曾经有过以下疑问。</span></p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><ol start="1" class=" list-paddingleft-2" style=""><li><p><span style="font-size: 17px;">为什么需要copy_{to,from}_user()，它究竟在背后为我们做了什么？</span></p></li><li><p><span style="font-size: 17px;">copy_{to,from}_user()和memcpy()的区别是什么，直接使用memcpy()可以吗？</span></p></li><li><p><span style="font-size: 17px;">memcpy()替代copy_{to,from}_user()是不是一定会有问题？</span></p></li></ol></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">一下子找回了当年困惑的自己。我所提出的每个问题，曾经我也思考过。还不止一次的思考，每一次都有不同的想法。当然是因为从一开始就我就没有完全理解。现在又重新回到这个沉重的话题，继续思考这曾经的问题。</span></p><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><p style="padding-bottom: 15px;line-height: 20px;"><span style="font-size: 17px;">温馨提示：文章代码分析基于Linux-4.18.0，部分架构相关代码以ARM64为代表。</span></p></blockquote><h2 style="color: rgb(31, 31, 31);font-size: 18px;font-weight: bold;margin-top: 25px;margin-bottom: 10px;font-family: Arial, Helvetica, sans-serif;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 20px;">百家争鸣</span></h2><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">针对以上问题当然是先百度。百度对于该问题的博客也是很多，足以看出这个问题肯定困惑着一大批Linux的爱好者。对于我的查阅结果来说，观点主要分成以下两种：</span></p><ul style="" class=" list-paddingleft-2"><li><p>copy_{to,from}_user()比memcpy()多了传入地址合法性校验。例如是否属于用户空间地址范围。理论上说，内核空间可以直接使用用户空间传过来的指针，即使要做数据拷贝的动作，也可以直接使用memcpy()，事实上在没有MMU的体系架构上，copy_{to,from}_user()最终的实现就是利用了memcpy()。但是对于大多数有MMU的平台，情况就有了些变化：用户空间传过来的指针是在虚拟地址空间上的，它所指向的虚拟地址空间很可能还没有真正映射到实际的物理页面上。但是这又能怎样呢？缺页导致的异常会很透明地被内核予以修复（为缺页的地址空间提交新的物理页面），访问到缺页的指令会继续运行仿佛什么都没有发生一样。但这只是用户空间缺页异常的行为，在内核空间这种缺页异常必须被显式地修复，这是由内核提供的缺页异常处理函数的设计模式决定的。其背后的思想是：在内核态，如果程序试图访问一个尚未被提交物理页面的用户空间地址，内核必须对此保持警惕而不能像用户空间那样毫无察觉。</p></li><li><p>如果我们确保用户态传递的指针的正确性，我们完全可以用memcpy()函数替代copy_{to,from}_user()。经过一些试验测试，发现使用memcpy()，程序的运行上并没有问题。因此在确保用户态指针安全的情况下，二者可以替换。</p><p><br  /></p></li></ul><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;text-align: left;background-color: rgb(255, 255, 255);font-size: 17px;">从各家博客上，观点主要集中在第一点。看起来第一点受到大家的广泛认可。但是，注重实践的人又得出了第二种观点，毕竟是实践出真知。真理究竟是是掌握在少数人手里呢？还是群众的眼睛是雪亮的呢？当然，我不否定以上任何一种观点。也不能向你保证哪种观点正确。因为，我相信即使是曾经无懈可击的理论，随着时间的推移或者特定情况的改变理论也可能不再正确。比如，牛顿的经典力学理论（好像扯得有点远）。如果要我说人话，就是：随着时间的推移，Linux的代码在不断的变化。或许以上的观点在曾经正确。当然，也可能现在还正确。下面的分析就是我的观点了。同样，大家也是需要保持怀疑的态度。下面我就抛砖引玉。</span></p><h2 style="color: rgb(31, 31, 31);font-size: 18px;font-weight: bold;margin-top: 25px;margin-bottom: 10px;font-family: Arial, Helvetica, sans-serif;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 20px;">抛砖引玉</span></h2><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">首先我们看下memcpy()和copy_{to,from}_user()的函数定义。参数几乎没有差别，都包含目的地址，源地址和需要复制的字节size。</span></p><pre style="color: rgb(50, 50, 50);font-size: 13px;text-align: left;background-color: rgb(255, 255, 255);"><br  /><pre class="prettyprint lang-cpp linenums" style="border-width: 0px;border-style: solid;border-color: rgb(136, 136, 136);font-family: &quot;Courier New&quot;, Courier, monospace;font-size: 12px;overflow: auto;margin-top: 5px;margin-bottom: 5px;line-height: 12pt;"><ol class="linenums list-paddingleft-2" style=""><li><p><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">static</span><span class="pln" style="color: rgb(0, 0, 0);"> __always_inline </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">unsigned</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">long</span><span class="pln" style="color: rgb(0, 0, 0);"> __must_check</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">copy_to_user</span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">void</span><span class="pln" style="color: rgb(0, 0, 0);"> __user </span><span class="pun" style="color: rgb(102, 102, 0);">*</span><span class="pln" style="color: rgb(0, 0, 0);">to</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">const</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">void</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">*</span><span class="pln" style="color: rgb(0, 0, 0);">from</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">unsigned</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">long</span><span class="pln" style="color: rgb(0, 0, 0);"> n</span><span class="pun" style="color: rgb(102, 102, 0);">);</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">&nbsp;</span></p></li><li><p><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">static</span><span class="pln" style="color: rgb(0, 0, 0);"> __always_inline </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">unsigned</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">long</span><span class="pln" style="color: rgb(0, 0, 0);"> __must_check</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">copy_from_user</span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">void</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">*</span><span class="pln" style="color: rgb(0, 0, 0);">to</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">const</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">void</span><span class="pln" style="color: rgb(0, 0, 0);"> __user </span><span class="pun" style="color: rgb(102, 102, 0);">*</span><span class="pln" style="color: rgb(0, 0, 0);">from</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">unsigned</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">long</span><span class="pln" style="color: rgb(0, 0, 0);"> n</span><span class="pun" style="color: rgb(102, 102, 0);">);</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">&nbsp;</span></p></li><li><p><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">void</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">*</span><span class="pln" style="color: rgb(0, 0, 0);">memcpy</span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">void</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">*</span><span class="pln" style="color: rgb(0, 0, 0);">dest</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">const</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">void</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">*</span><span class="pln" style="color: rgb(0, 0, 0);">src</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="typ" style="color: rgb(102, 0, 102);">size_t</span><span class="pln" style="color: rgb(0, 0, 0);"> len</span><span class="pun" style="color: rgb(102, 102, 0);">);</span><span class="pln" style="color: rgb(0, 0, 0);"> </span></p></li></ol></pre><br  /></pre><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">但是，有一点我们肯定是知道的。那就是memcpy()没有传入地址合法性校验。而copy_{to,from}_user()针对传入地址进行类似下面的合法性校验（简单说点，更多校验详情可以参考代码）。</span></p><ul style="" class=" list-paddingleft-2"><li><p>如果从用户空间copy数据到内核空间，用户空间地址to及to加上copy的字节长度n必须位于用户空间地址空间。</p></li><li><p>如果从内核空间copy数据到用户空间，当然也需要检查地址的合法性。例如，是否越界访问或者是不是代码段的数据等等。总之一切不合法地操作都需要立刻杜绝。</p><p><br  /></p></li></ul><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">经过简单的对比之后，我们再看看其他的差异以及一起探讨下上面提出的2个观点。我们先从第2个观点说起。涉及实践，我还是有点相信实践出真知。从我测试的结果来说，实现结果分成两种情况。</span></p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">第一种情况的结果是：使用memcpy()测试，没有出现问题，代码正常运行。测试代码如下（仅仅展示proc文件系统下file_operations对应的read接口函数）：</span></p><pre style="color: rgb(50, 50, 50);font-size: 13px;text-align: left;background-color: rgb(255, 255, 255);"><br  /><pre class="prettyprint lang-cpp linenums" style="border-width: 0px;border-style: solid;border-color: rgb(136, 136, 136);font-family: &quot;Courier New&quot;, Courier, monospace;font-size: 12px;overflow: auto;margin-top: 5px;margin-bottom: 5px;line-height: 12pt;"><ol class="linenums list-paddingleft-2" style=""><li><p><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">static</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="typ" style="color: rgb(102, 0, 102);">ssize_t</span><span class="pln" style="color: rgb(0, 0, 0);"> test_read</span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">struct</span><span class="pln" style="color: rgb(0, 0, 0);"> file </span><span class="pun" style="color: rgb(102, 102, 0);">*</span><span class="pln" style="color: rgb(0, 0, 0);">file</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">char</span><span class="pln" style="color: rgb(0, 0, 0);"> __user </span><span class="pun" style="color: rgb(102, 102, 0);">*</span><span class="pln" style="color: rgb(0, 0, 0);">buf</span><span class="pun" style="color: rgb(102, 102, 0);">,</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">                         </span><span class="typ" style="color: rgb(102, 0, 102);">size_t</span><span class="pln" style="color: rgb(0, 0, 0);"> len</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="typ" style="color: rgb(102, 0, 102);">loff_t</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">*</span><span class="pln" style="color: rgb(0, 0, 0);">offset</span><span class="pun" style="color: rgb(102, 102, 0);">)</span></p></li><li><p><span class="pun" style="color: rgb(102, 102, 0);">{</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">    	memcpy</span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="pln" style="color: rgb(0, 0, 0);">buf</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="str" style="color: rgb(0, 136, 0);">"test\n"</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="lit" style="color: rgb(0, 102, 102);">5</span><span class="pun" style="color: rgb(102, 102, 0);">);</span><span class="pln" style="color: rgb(0, 0, 0);">	</span><span class="com" style="color: rgb(136, 0, 0);">/* copy_to_user(buf, "test\n", 5) */</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">&nbsp;</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">    	</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">return</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="lit" style="color: rgb(0, 102, 102);">5</span><span class="pun" style="color: rgb(102, 102, 0);">;</span></p></li><li><p><span class="pun" style="color: rgb(102, 102, 0);">}</span><span class="pln" style="color: rgb(0, 0, 0);"> </span></p></li></ol></pre><br  /></pre><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">我们使用cat命令读取文件内容，cat会通过系统调用read调用test_read，并且传递的buf大小是4k。测试很顺利，结果很喜人。成功地读到了“test”字符串。看起来，第2点观点是没毛病的。但是，我们还需要继续验证和探究下去。因为第1个观点提到，“在内核空间这种缺页异常必须被显式地修复”。因此我们还需要验证的情况是：如果buf在用户空间已经分配虚拟地址空间，但是并没有建立和物理内存的具体映射关系，这种情况下会出现内核态page fault。我们首先需要创建这种条件，找到符合的buf，然后测试。这里我当然没测啦。因为有测试结论（主要是因为我懒，构造这个条件我觉得比较麻烦）。这个测试是我的一个朋友，人称宋老师的“阿助教”阿克曼大牛。他曾经做个这个实验，并且得到的结论是：即使是没有建立和物理内存的具体映射关系的buf，代码也可以正常运行。在内核态发生page fault，并被其修复（分配具体物理内存，填充页表，建立映射关系）。同时，我从代码的角度分析，结论也是如此。</span></p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">经过上面的分析，看起来好像是memcpy()也可以正常使用，鉴于安全地考虑建议使用copy_{to,from}_user()等接口。</span></p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">第二种情况的结果是：以上的测试代码并没有正常运行，并且会触发kernel oops。当然本次测试和上次测试的kernel配置选项是不一样的。这个配置项是</span><code><span style="font-size: 17px;">CONFIG_ARM64_SW_TTBR0_PAN</span></code><span style="font-size: 17px;">或者</span><code><span style="font-size: 17px;">CONFIG_ARM64_PAN</span></code><span style="font-size: 17px;">（针对ARM64平台）。两个配置选项的功能都是阻止内核态直接访问用户地址空间。只不过，CONFIG_ARM64_SW_TTBR0_PAN是软件仿真实现这种功能，而CONFIG_ARM64_PAN是硬件实现功能（ARMv8.1扩展功能）。我们以CONFIG_ARM64_SW_TTBR0_PAN作为分析对象（软件仿真才有代码提供分析）。BTW，如果硬件不支持，即使配置CONFIG_ARM64_PAN也没用，只能使用软件仿真的方法。内核Kconfig部分解释如下。如果需要访问用户空间地址需要通过类似copy_{to,from}_user()的接口，否则会导致kernel oops。</span></p><pre style="color: rgb(50, 50, 50);font-size: 13px;text-align: left;background-color: rgb(255, 255, 255);"><pre class="prettyprint linenums" style="border-width: 0px;border-style: solid;border-color: rgb(136, 136, 136);font-family: &quot;Courier New&quot;, Courier, monospace;font-size: 12px;overflow: auto;margin-top: 5px;margin-bottom: 5px;line-height: 12pt;"><ol class="linenums list-paddingleft-2" style=""><li><p><span class="pln" style="color: rgb(0, 0, 0);">config ARM64_SW_TTBR0_PAN</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">        </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">bool</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="str" style="color: rgb(0, 136, 0);">"Emulate Privileged Access Never using TTBR0_EL1 switching"</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">        help</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">          </span><span class="typ" style="color: rgb(102, 0, 102);">Enabling</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">this</span><span class="pln" style="color: rgb(0, 0, 0);"> option prevents the kernel </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">from</span><span class="pln" style="color: rgb(0, 0, 0);"> accessing</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">          user</span><span class="pun" style="color: rgb(102, 102, 0);">-</span><span class="pln" style="color: rgb(0, 0, 0);">space memory directly </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">by</span><span class="pln" style="color: rgb(0, 0, 0);"> pointing TTBR0_EL1 to a reserved</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">          zeroed area </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">and</span><span class="pln" style="color: rgb(0, 0, 0);"> reserved ASID</span><span class="pun" style="color: rgb(102, 102, 0);">.</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="typ" style="color: rgb(102, 0, 102);">The</span><span class="pln" style="color: rgb(0, 0, 0);"> user access routines</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">          restore the valid TTBR0_EL1 temporarily</span><span class="pun" style="color: rgb(102, 102, 0);">.</span><span class="pln" style="color: rgb(0, 0, 0);"> </span></p></li></ol></pre><br  /></pre><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">在打开CONFIG_ARM64_SW_TTBR0_PAN的选项后，测试以上代码就会导致kernel oops。原因就是内核态直接访问了用户空间地址。因此，在这种情况我们就不可以使用memcpy()。我们别无选择，只能使用copy_{to,from}_user()。当然了，我们也不是没有办法使用memcpy()，但是需要额外的操作。如何操作呢？下一节为你揭晓。</span></p><h2 style="margin-top: 25px;margin-bottom: 10px;font-weight: bold;font-size: 18px;color: rgb(31, 31, 31);font-family: Arial, Helvetica, sans-serif;text-align: left;background-color: rgb(255, 255, 255);"><span style="font-size: 20px;">刨根问底</span></h2><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">既然提到了CONFIG_ARM64_SW_TTBR0_PAN的配置选项。当然我也希望了解其背后设计的原理。由于ARM64的硬件特殊设计，我们使用两个页表基地址寄存器ttbr0_el1和ttbr1_el1。处理器根据64 bit地址的高16 bit判断访问的地址属于用户空间还是内核空间。如果是用户空间地址则使用ttbr0_el1，反之使用ttbr1_el1。因此，ARM64进程切换的时候，只需要改变ttbr0_el1的值即可。ttbr1_el1可以选择不需要改变，因为所有的进程共享相同的内核空间地址。</span></p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">当进程切换到内核态（中断，异常，系统调用等）后，如何才能避免内核态访问用户态地址空间呢？其实不难想出，改变ttbr0_el1的值即可，指向一段非法的映射即可。因此，我们为此准备了一份特殊的页表，该页表大小4k内存，其值全是0。当进程切换到内核态后，修改ttbr0_el1的值为该页表的地址即可保证访问用户空间地址是非法访问。因为页表的值是非法的。这个特殊的页表内存通过</span><span style="font-size: 17px;">链接脚本</span><span style="font-size: 17px;">分配。</span></p><pre style="color: rgb(50, 50, 50);font-size: 13px;text-align: left;background-color: rgb(255, 255, 255);"><code class="language-c#" lang="c#"> <br  /><pre class="prettyprint linenums" style="border-width: 0px;border-style: solid;border-color: rgb(136, 136, 136);font-family: &quot;Courier New&quot;, Courier, monospace;font-size: 12px;overflow: auto;margin-top: 5px;margin-bottom: 5px;line-height: 12pt;"><ol class="linenums list-paddingleft-2" style=""><li><p><span class="com" style="color: rgb(136, 0, 0);">#define</span><span class="pln" style="color: rgb(0, 0, 0);"> RESERVED_TTBR0_SIZE	</span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="pln" style="color: rgb(0, 0, 0);">PAGE_SIZE</span><span class="pun" style="color: rgb(102, 102, 0);">)</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">&nbsp;</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">SECTIONS</span></p></li><li><p><span class="pun" style="color: rgb(102, 102, 0);">{</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	reserved_ttbr0 </span><span class="pun" style="color: rgb(102, 102, 0);">=</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">.;</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	</span><span class="pun" style="color: rgb(102, 102, 0);">.</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">+=</span><span class="pln" style="color: rgb(0, 0, 0);"> RESERVED_TTBR0_SIZE</span><span class="pun" style="color: rgb(102, 102, 0);">;</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	swapper_pg_dir </span><span class="pun" style="color: rgb(102, 102, 0);">=</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">.;</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	</span><span class="pun" style="color: rgb(102, 102, 0);">.</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">+=</span><span class="pln" style="color: rgb(0, 0, 0);"> SWAPPER_DIR_SIZE</span><span class="pun" style="color: rgb(102, 102, 0);">;</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	swapper_pg_end </span><span class="pun" style="color: rgb(102, 102, 0);">=</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">.;</span></p></li><li><p><span class="pun" style="color: rgb(102, 102, 0);">}</span></p></li></ol></pre><br  /></code></pre><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">这个特殊的页表和内核页表在一起。和</span><code><span style="font-size: 17px;">swapper_pg_dir</span></code><span style="font-size: 17px;">仅仅差4k大小。</span><code><span style="font-size: 17px;">reserved_ttbr0</span></code><span style="font-size: 17px;">地址开始的4k内存空间的内容会被清零。</span></p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">当我们进入内核态后会通过</span><code><span style="font-size: 17px;">__uaccess_ttbr0_disable</span></code><span style="font-size: 17px;">切换ttbr0_el1以关闭用户空间地址访问，在需要访问的时候通过</span><code><span style="font-size: 17px;">__uaccess_ttbr0_enable</span></code><span style="font-size: 17px;">打开用户空间地址访问。这两个宏定义也不复杂，就以__uaccess_ttbr0_disable为例说明原理。其</span><span style="font-size: 17px;">定义</span><span style="font-size: 17px;">如下：</span></p><pre style="color: rgb(50, 50, 50);font-size: 13px;text-align: left;background-color: rgb(255, 255, 255);"><code class="language-assembly" lang="assembly"> <br  /><pre class="prettyprint linenums" style="border-width: 0px;border-style: solid;border-color: rgb(136, 136, 136);font-family: &quot;Courier New&quot;, Courier, monospace;font-size: 12px;overflow: auto;margin-top: 5px;margin-bottom: 5px;line-height: 12pt;"><ol class="linenums list-paddingleft-2" style=""><li><p><span class="pun" style="color: rgb(102, 102, 0);">.</span><span class="pln" style="color: rgb(0, 0, 0);">macro	__uaccess_ttbr0_disable</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> tmp1</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">    mrs	\tmp1</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> ttbr1_el1                        </span><span class="com" style="color: rgb(136, 0, 0);">// swapper_pg_dir (1)</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">    bic	\tmp1</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> \tmp1</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="com" style="color: rgb(136, 0, 0);">#TTBR_ASID_MASK</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">    </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">sub</span><span class="pln" style="color: rgb(0, 0, 0);">	\tmp1</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> \tmp1</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="com" style="color: rgb(136, 0, 0);">#RESERVED_TTBR0_SIZE      // reserved_ttbr0 just before</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">                                                </span><span class="com" style="color: rgb(136, 0, 0);">// swapper_pg_dir (2)</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">    msr	ttbr0_el1</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> \tmp1                        </span><span class="com" style="color: rgb(136, 0, 0);">// set reserved TTBR0_EL1 (3)</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">    isb</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">    add	\tmp1</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> \tmp1</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="com" style="color: rgb(136, 0, 0);">#RESERVED_TTBR0_SIZE</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">    msr	ttbr1_el1</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> \tmp1                       </span><span class="com" style="color: rgb(136, 0, 0);">// set reserved ASID</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">    isb</span></p></li><li><p><span class="pun" style="color: rgb(102, 102, 0);">.</span><span class="pln" style="color: rgb(0, 0, 0);">endm</span></p></li></ol></pre><br  /></code></pre><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><ol start="1" class=" list-paddingleft-2" style=""><li><p>ttbr1_el1存储的是内核页表基地址，因此其值就是swapper_pg_dir。</p></li><li><p>swapper_pg_dir减去RESERVED_TTBR0_SIZE就是上面描述的特殊页表。</p></li><li><p>将ttbr0_el1修改指向这个特殊的页表基地址，当然可以保证后续访问用户地址都是非法的。</p></li></ol></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">__uaccess_ttbr0_disable对应的C语言实现可以参考</span><span style="font-size: 17px;">这里</span><span style="font-size: 17px;">。如何允许内核态访问用户空间地址呢？也很简单，就是__uaccess_ttbr0_disable的反操作，给ttbr0_el1赋予合法的页表基地址。这里就不必重复了。我们现在需要知道的事实就是，在配置CONFIG_ARM64_SW_TTBR0_PAN的情况下，copy_{to,from}_user()接口会在copy之前允许内核态访问用户空间，并在copy结束之后关闭内核态访问用户空间的能力。因此，使用copy_{to,from}_user()才是正统做法。主要体现在安全性检查及安全访问处理。这里是其比memcpy()多的第一个特性，后面还会介绍另一个重要特性。</span></p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">现在我们可以解答上一节中遗留的问题。怎样才能继续使用memcpy()？现在就很简单了，在memcpy()调用之前通过</span><span style="font-size: 17px;">uaccess_enable_not_uao()</span><span style="font-size: 17px;">允许内核态访问用户空间地址，调用memcpy()，最后通过</span><span style="font-size: 17px;">uaccess_disable_not_uao()</span><span style="font-size: 17px;">关闭内核态访问用户空间的能力。</span></p><h2 style="color: rgb(31, 31, 31);font-size: 18px;font-weight: bold;margin-top: 25px;margin-bottom: 10px;font-family: Arial, Helvetica, sans-serif;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);">未雨绸缪</h2><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">以上的测试用例都是建立在用户空间传递合法地址的基础上测试的，何为合法的用户空间地址？用户空间通过系统调用申请的虚拟地址空间包含的地址范围，即是合法的地址（不论是否分配物理页面建立映射关系）。既然要写一个接口程序，当然也要考虑程序的健壮性，我们不能假设所有的用户传递的参数都是合法的。我们应该预判非法传参情况的发生，并提前做好准备，这就是未雨绸缪。</span></p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">我们首先使用memcpy()的测试用例，随机传递一个非法的地址。经过测试发现：会触发kernel oops。继续使用copy_{to,from}_user()替代memcpy()测试。测试发现：read()仅仅是返回错误，但不会触发kernel oops。这才是我们想要的结果。毕竟，一个应用程序不应该触发kernel oops。这种机制的实现原理是什么呢？</span></p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">我们以</span><span style="font-size: 17px;">copy_to_user()</span><span style="font-size: 17px;">为例分析。函数调用流程如下：</span></p><pre style="color: rgb(50, 50, 50);font-size: 13px;text-align: left;background-color: rgb(255, 255, 255);"><code class="language-txt" lang="txt"> <br  /><pre class="prettyprint linenums" style="border-width: 0px;border-style: solid;border-color: rgb(136, 136, 136);font-family: &quot;Courier New&quot;, Courier, monospace;font-size: 12px;overflow: auto;margin-top: 5px;margin-bottom: 5px;line-height: 12pt;"><ol class="linenums list-paddingleft-2" style=""><li><p><span class="pln" style="color: rgb(0, 0, 0);">copy_to_user</span><span class="pun" style="color: rgb(102, 102, 0);">()-&gt;</span><span class="pln" style="color: rgb(0, 0, 0);">_copy_to_user</span><span class="pun" style="color: rgb(102, 102, 0);">()-&gt;</span><span class="pln" style="color: rgb(0, 0, 0);">raw_copy_to_user</span><span class="pun" style="color: rgb(102, 102, 0);">()-&gt;</span><span class="pln" style="color: rgb(0, 0, 0);">__arch_copy_to_user</span><span class="pun" style="color: rgb(102, 102, 0);">()</span></p></li></ol></pre><br  /></code></pre><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">__arch_copy_to_user()</span><span style="font-size: 17px;">在ARM64平台是汇编代码实现，这部分代码很关键。</span></p><pre style="color: rgb(50, 50, 50);font-size: 13px;text-align: left;background-color: rgb(255, 255, 255);"><code class="language-assembly" lang="assembly"> <br  /><pre class="prettyprint lang-cpp linenums" style="border-width: 0px;border-style: solid;border-color: rgb(136, 136, 136);font-family: &quot;Courier New&quot;, Courier, monospace;font-size: 12px;overflow: auto;margin-top: 5px;margin-bottom: 5px;line-height: 12pt;"><ol class="linenums list-paddingleft-2" style=""><li><p><span class="pln" style="color: rgb(0, 0, 0);">end	</span><span class="pun" style="color: rgb(102, 102, 0);">.</span><span class="pln" style="color: rgb(0, 0, 0);">req	x5</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">ENTRY</span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="pln" style="color: rgb(0, 0, 0);">__arch_copy_to_user</span><span class="pun" style="color: rgb(102, 102, 0);">)</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	uaccess_enable_not_uao x3</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> x4</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> x5</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	add	end</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> x0</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> x2</span></p></li><li><p><span class="com" style="color: rgb(136, 0, 0);">#include</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="str" style="color: rgb(0, 136, 0);">"copy_template.S"</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	uaccess_disable_not_uao x3</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> x4</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	mov	x0</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="com" style="color: rgb(136, 0, 0);">#0</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	ret</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">ENDPROC</span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="pln" style="color: rgb(0, 0, 0);">__arch_copy_to_user</span><span class="pun" style="color: rgb(102, 102, 0);">)</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">&nbsp;</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	</span><span class="pun" style="color: rgb(102, 102, 0);">.</span><span class="pln" style="color: rgb(0, 0, 0);">section </span><span class="pun" style="color: rgb(102, 102, 0);">.</span><span class="pln" style="color: rgb(0, 0, 0);">fixup</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="str" style="color: rgb(0, 136, 0);">"ax"</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	</span><span class="pun" style="color: rgb(102, 102, 0);">.</span><span class="pln" style="color: rgb(0, 0, 0);">align	</span><span class="lit" style="color: rgb(0, 102, 102);">2</span></p></li><li><p><span class="lit" style="color: rgb(0, 102, 102);">9998</span><span class="pun" style="color: rgb(102, 102, 0);">:</span><span class="pln" style="color: rgb(0, 0, 0);">	sub	x0</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> end</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> dst			</span><span class="com" style="color: rgb(136, 0, 0);">// bytes not copied</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	ret</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	</span><span class="pun" style="color: rgb(102, 102, 0);">.</span><span class="pln" style="color: rgb(0, 0, 0);">previous</span></p></li></ol></pre><br  /></code></pre><blockquote style="margin: 0px 20px 20px;padding: 25px 20px;background: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right: 5px solid rgb(105, 105, 105);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;"><ol start="1" class=" list-paddingleft-2" style=""><li><p>uaccess_enable_not_uao和uaccess_disable_not_uao是上面说到的内核态访问用户空间的开关。</p></li><li><p>copy_template.S文件是汇编实现的memcpy()的功能，稍后看看memcpy()的实现代码就清楚了。</p></li><li><p><code>.section .fixup,“ax”</code>定义一个section，名为“.fixup”，权限是ax（‘a’可重定位的段，‘x’可执行段）。<code>9998</code>标号处的指令就是“未雨绸缪”的善后处理工作。还记得copy_{to,from}_user()返回值的意义吗？返回0代表copy成功，否则返回剩余没有copy的字节数。这行代码就是计算剩余没有copy的字节数。当我们访问非法的用户空间地址的时候，就一定会触发page fault。这种情况下，内核态发生的page fault并返回的时候并没有修复异常，所以肯定不能返回发生异常的地址继续运行。所以，系统可以有2个选择：第1个选择是kernel oops，并给当前进程发送SIGSEGV信号；第2个选择是不返回出现异常的地址运行，而是选择一个已经修复的地址返回。如果使用的是memcpy()就只有第1个选择。但是copy_{to,from}_user()可以有第2个选择。<code>.fixup</code>段就是为了实现这个修复功能。当copy过程中出现访问非法用户空间地址的时候，do_page_fault()返回的地址变成<code>9998</code>标号处，此时可以计算剩余未copy的字节长度，程序还可以继续执行。</p></li></ol></blockquote><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">对比前面分析的结果，其实__arch_copy_to_user()可以近似等效如下关系。</span></p><pre style="color: rgb(50, 50, 50);font-size: 13px;text-align: left;background-color: rgb(255, 255, 255);"><code class="language-txt" lang="txt"><pre class="prettyprint linenums" style="border-width: 0px;border-style: solid;border-color: rgb(136, 136, 136);font-family: &quot;Courier New&quot;, Courier, monospace;font-size: 12px;overflow: auto;margin-top: 5px;margin-bottom: 5px;line-height: 12pt;"><ol class="linenums list-paddingleft-2" style=""><li><p><span class="pln" style="color: rgb(0, 0, 0);">uaccess_enable_not_uao</span><span class="pun" style="color: rgb(102, 102, 0);">();</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">memcpy</span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="pln" style="color: rgb(0, 0, 0);">ubuf</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> kbuf</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> size</span><span class="pun" style="color: rgb(102, 102, 0);">);</span><span class="pln" style="color: rgb(0, 0, 0);">      </span><span class="pun" style="color: rgb(102, 102, 0);">==</span><span class="pln" style="color: rgb(0, 0, 0);">     __arch_copy_to_user</span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="pln" style="color: rgb(0, 0, 0);">ubuf</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> kbuf</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> size</span><span class="pun" style="color: rgb(102, 102, 0);">);</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">uaccess_disable_not_uao</span><span class="pun" style="color: rgb(102, 102, 0);">();</span></p></li></ol></pre><br  /></code></pre><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">先插播一条消息，解释</span><span style="font-size: 17px;">copy_template.S</span><span style="font-size: 17px;">为何是memcpy()。memcpy()在ARM64平台是由汇编代码实现。其定义在</span><span style="font-size: 17px;">arch/arm64/lib/memcpy.S</span><span style="font-size: 17px;">文件。</span></p><pre style="color: rgb(50, 50, 50);font-size: 13px;text-align: left;background-color: rgb(255, 255, 255);"><code class="language-assembly" lang="assembly"> <br  /><pre class="prettyprint lang-cpp linenums" style="border-width: 0px;border-style: solid;border-color: rgb(136, 136, 136);font-family: &quot;Courier New&quot;, Courier, monospace;font-size: 12px;overflow: auto;margin-top: 5px;margin-bottom: 5px;line-height: 12pt;"><ol class="linenums list-paddingleft-2" style=""><li><p><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">.</span><span class="pln" style="color: rgb(0, 0, 0);">weak memcpy</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">ENTRY</span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="pln" style="color: rgb(0, 0, 0);">__memcpy</span><span class="pun" style="color: rgb(102, 102, 0);">)</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">ENTRY</span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="pln" style="color: rgb(0, 0, 0);">memcpy</span><span class="pun" style="color: rgb(102, 102, 0);">)</span></p></li><li><p><span class="com" style="color: rgb(136, 0, 0);">#include</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="str" style="color: rgb(0, 136, 0);">"copy_template.S"</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	ret</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">ENDPIPROC</span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="pln" style="color: rgb(0, 0, 0);">memcpy</span><span class="pun" style="color: rgb(102, 102, 0);">)</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">ENDPROC</span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="pln" style="color: rgb(0, 0, 0);">__memcpy</span><span class="pun" style="color: rgb(102, 102, 0);">)</span></p></li></ol></pre><br  /></code></pre><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">所以很明显，memcpy()和__memcpy()函数定义是一样的。并且memcpy()函数声明是weak，因此可以重写memcpy()函数（扯得有点远）。再扯一点，为何使用汇编呢？为何不使用lib/string.c文件的</span><span style="font-size: 17px;">memcpy()</span><span style="font-size: 17px;">函数呢？当然是为了优化memcpy() 的执行速度。lib/string.c文件的memcpy()函数是按照字节为单位进行copy（再好的硬件也会被粗糙的代码毁掉）。但是现在的处理器基本都是32或者64位，完全可以4 bytes或者8 bytes甚至16 bytes copy（考虑地址对齐的情况下）。可以明显提升执行速度。所以，ARM64平台使用汇编实现。这部分知识可以参考这篇博客</span><span style="font-size: 17px;">《ARM64 的 memcpy 优化与实现》</span><span style="font-size: 17px;">。</span></p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">下面继续进入正题，再重复一遍：内核态访问用户空间地址，如果触发page fault，只要用户空间地址合法，内核态也会像什么也没有发生一样修复异常（分配物理内存，建立页表映射关系）。但是如果访问非法用户空间地址，就选择第2条路，尝试救赎自己。这条路就是利用</span><code><span style="font-size: 17px;">.fixup</span></code><span style="font-size: 17px;">和</span><code><span style="font-size: 17px;">__ex_table</span></code><span style="font-size: 17px;">段。如果无力回天只能给当前进程发送SIGSEGV信号。并且，轻则kernel oops，重则panic（取决于kernel配置选项CONFIG_PANIC_ON_OOPS）。在内核态访问非法用户空间地址的情况下，do_page_fault()最终会跳转</span><code><span style="font-size: 17px;">no_context</span></code><span style="font-size: 17px;">标号处的</span><span style="font-size: 17px;">__do_kernel_fault()</span><span style="font-size: 17px;">。</span></p><pre style="color: rgb(50, 50, 50);font-size: 13px;text-align: left;background-color: rgb(255, 255, 255);"><code class="language-c" lang="c"> <br  /><pre class="prettyprint lang-cpp linenums" style="border-width: 0px;border-style: solid;border-color: rgb(136, 136, 136);font-family: &quot;Courier New&quot;, Courier, monospace;font-size: 12px;overflow: auto;margin-top: 5px;margin-bottom: 5px;line-height: 12pt;"><ol class="linenums list-paddingleft-2" style=""><li><p><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">static</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">void</span><span class="pln" style="color: rgb(0, 0, 0);"> __do_kernel_fault</span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">unsigned</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">long</span><span class="pln" style="color: rgb(0, 0, 0);"> addr</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">unsigned</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="typ" style="color: rgb(102, 0, 102);">int</span><span class="pln" style="color: rgb(0, 0, 0);"> esr</span><span class="pun" style="color: rgb(102, 102, 0);">,</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">                              </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">struct</span><span class="pln" style="color: rgb(0, 0, 0);"> pt_regs </span><span class="pun" style="color: rgb(102, 102, 0);">*</span><span class="pln" style="color: rgb(0, 0, 0);">regs</span><span class="pun" style="color: rgb(102, 102, 0);">)</span></p></li><li><p><span class="pun" style="color: rgb(102, 102, 0);">{</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	</span><span class="com" style="color: rgb(136, 0, 0);">/*</span></p></li><li><p><span class="com" style="color: rgb(136, 0, 0);">	 * Are we prepared to handle this kernel fault?</span></p></li><li><p><span class="com" style="color: rgb(136, 0, 0);">	 * We are almost certainly not prepared to handle instruction faults.</span></p></li><li><p><span class="com" style="color: rgb(136, 0, 0);">	 */</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">if</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">(!</span><span class="pln" style="color: rgb(0, 0, 0);">is_el1_instruction_abort</span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="pln" style="color: rgb(0, 0, 0);">esr</span><span class="pun" style="color: rgb(102, 102, 0);">)</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">&amp;&amp;</span><span class="pln" style="color: rgb(0, 0, 0);"> fixup_exception</span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="pln" style="color: rgb(0, 0, 0);">regs</span><span class="pun" style="color: rgb(102, 102, 0);">))</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">		</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">return</span><span class="pun" style="color: rgb(102, 102, 0);">;</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	</span><span class="com" style="color: rgb(136, 0, 0);">/* ... */</span></p></li><li><p><span class="pun" style="color: rgb(102, 102, 0);">}</span></p></li></ol></pre><br  /></code></pre><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">fixup_exception()</span><span style="font-size: 17px;">继续调用</span><span style="font-size: 17px;">search_exception_tables()</span><span style="font-size: 17px;">，其通过查找__ex_table段。__ex_table段存储exception table，每个entry存储着异常地址及其对应修复的地址。例如上述的</span><code><span style="font-size: 17px;">9998: sub x0, end, dst</span></code><span style="font-size: 17px;">指令的地址就会被找到并修改do_page_fault()函数的返回地址，以达到跳转修复的功能。其实查找过程是根据出问题的地址addr，查找__ex_table段（exception table）是否有对应的exception table entry，如果有就代表可以被修复。由于32位处理器和64位处理器实现方式有差别，因此我们先从32位处理器异常表的实现原理说起。</span></p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">__ex_table段的首尾地址分别是</span><code><span style="font-size: 17px;">__start___ex_table</span></code><span style="font-size: 17px;">和</span><code><span style="font-size: 17px;">__stop___ex_table</span></code><span style="font-size: 17px;">（定义在</span><span style="font-size: 17px;">include/asm-generic/vmlinux.lds.h</span><span style="font-size: 17px;">。这段内存可以看作是一个数组，数组的每个元素都是</span><code><span style="font-size: 17px;">struct exception_table_entry</span></code><span style="font-size: 17px;">类型，其记录着异常发生地址及其对应的修复地址。</span></p><pre style="color: rgb(50, 50, 50);font-size: 13px;text-align: left;background-color: rgb(255, 255, 255);"><code class="language-txt" lang="txt"> <br  /><pre class="prettyprint linenums" style="border-width: 0px;border-style: solid;border-color: rgb(136, 136, 136);font-family: &quot;Courier New&quot;, Courier, monospace;font-size: 12px;overflow: auto;margin-top: 5px;margin-bottom: 5px;line-height: 12pt;"><ol class="linenums list-paddingleft-2" style=""><li><p><span class="pln" style="color: rgb(0, 0, 0);"> exception tables</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">__start___ex_table </span><span class="pun" style="color: rgb(102, 102, 0);">--&gt;</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">+---------------+</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">                       </span><span class="pun" style="color: rgb(102, 102, 0);">|</span><span class="pln" style="color: rgb(0, 0, 0);">     entry     </span><span class="pun" style="color: rgb(102, 102, 0);">|</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">                       </span><span class="pun" style="color: rgb(102, 102, 0);">+---------------+</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">                       </span><span class="pun" style="color: rgb(102, 102, 0);">|</span><span class="pln" style="color: rgb(0, 0, 0);">     entry     </span><span class="pun" style="color: rgb(102, 102, 0);">|</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">                       </span><span class="pun" style="color: rgb(102, 102, 0);">+---------------+</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">                       </span><span class="pun" style="color: rgb(102, 102, 0);">|</span><span class="pln" style="color: rgb(0, 0, 0);">      </span><span class="pun" style="color: rgb(102, 102, 0);">...</span><span class="pln" style="color: rgb(0, 0, 0);">      </span><span class="pun" style="color: rgb(102, 102, 0);">|</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">                       </span><span class="pun" style="color: rgb(102, 102, 0);">+---------------+</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">                       </span><span class="pun" style="color: rgb(102, 102, 0);">|</span><span class="pln" style="color: rgb(0, 0, 0);">     entry     </span><span class="pun" style="color: rgb(102, 102, 0);">|</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">                       </span><span class="pun" style="color: rgb(102, 102, 0);">+---------------+</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">                       </span><span class="pun" style="color: rgb(102, 102, 0);">|</span><span class="pln" style="color: rgb(0, 0, 0);">     entry     </span><span class="pun" style="color: rgb(102, 102, 0);">|</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">__stop___ex_table  </span><span class="pun" style="color: rgb(102, 102, 0);">--&gt;</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">+---------------+</span></p></li></ol></pre></code><code class="language-txt" lang="txt"><br  /></code></pre><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">在32位处理器上，struct exception_table_entry</span><span style="font-size: 17px;">定义</span><span style="font-size: 17px;">如下：</span></p><pre style="color: rgb(50, 50, 50);font-size: 13px;text-align: left;background-color: rgb(255, 255, 255);"><code class="language-c" lang="c"> <br  /><pre class="prettyprint lang-cpp linenums" style="border-width: 0px;border-style: solid;border-color: rgb(136, 136, 136);font-family: &quot;Courier New&quot;, Courier, monospace;font-size: 12px;overflow: auto;margin-top: 5px;margin-bottom: 5px;line-height: 12pt;"><ol class="linenums list-paddingleft-2" style=""><li><p><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">struct</span><span class="pln" style="color: rgb(0, 0, 0);"> exception_table_entry </span><span class="pun" style="color: rgb(102, 102, 0);">{</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">unsigned</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">long</span><span class="pln" style="color: rgb(0, 0, 0);"> insn</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> fixup</span><span class="pun" style="color: rgb(102, 102, 0);">;</span></p></li><li><p><span class="pun" style="color: rgb(102, 102, 0);">};</span></p></li></ol></pre><br  /></code></pre><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">有一点需要明确，在32位处理器上，unsigned long是4 bytes。insn和fixup分别存储异常发生地址及其对应的修复地址。根据异常地址ex_addr查找对应的修复地址（未找到返回0），其示意代码如下：</span></p><pre style="color: rgb(50, 50, 50);font-size: 13px;text-align: left;background-color: rgb(255, 255, 255);"><code class="language-c" lang="c"> <br  /><pre class="prettyprint lang-cpp linenums" style="border-width: 0px;border-style: solid;border-color: rgb(136, 136, 136);font-family: &quot;Courier New&quot;, Courier, monospace;font-size: 12px;overflow: auto;margin-top: 5px;margin-bottom: 5px;line-height: 12pt;"><ol class="linenums list-paddingleft-2" style=""><li><p><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">unsigned</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">long</span><span class="pln" style="color: rgb(0, 0, 0);"> search_fixup_addr32</span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">unsigned</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">long</span><span class="pln" style="color: rgb(0, 0, 0);"> ex_addr</span><span class="pun" style="color: rgb(102, 102, 0);">)</span></p></li><li><p><span class="pun" style="color: rgb(102, 102, 0);">{</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">const</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">struct</span><span class="pln" style="color: rgb(0, 0, 0);"> exception_table_entry </span><span class="pun" style="color: rgb(102, 102, 0);">*</span><span class="pln" style="color: rgb(0, 0, 0);">e</span><span class="pun" style="color: rgb(102, 102, 0);">;</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">&nbsp;</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">for</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="pln" style="color: rgb(0, 0, 0);">e </span><span class="pun" style="color: rgb(102, 102, 0);">=</span><span class="pln" style="color: rgb(0, 0, 0);"> __start___ex_table</span><span class="pun" style="color: rgb(102, 102, 0);">;</span><span class="pln" style="color: rgb(0, 0, 0);"> e </span><span class="pun" style="color: rgb(102, 102, 0);">&lt;</span><span class="pln" style="color: rgb(0, 0, 0);"> __stop___ex_table</span><span class="pun" style="color: rgb(102, 102, 0);">;</span><span class="pln" style="color: rgb(0, 0, 0);"> e</span><span class="pun" style="color: rgb(102, 102, 0);">++)</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">		</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">if</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="pln" style="color: rgb(0, 0, 0);">ex_addr </span><span class="pun" style="color: rgb(102, 102, 0);">==</span><span class="pln" style="color: rgb(0, 0, 0);"> e</span><span class="pun" style="color: rgb(102, 102, 0);">-&gt;</span><span class="pln" style="color: rgb(0, 0, 0);">insn</span><span class="pun" style="color: rgb(102, 102, 0);">)</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">			</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">return</span><span class="pln" style="color: rgb(0, 0, 0);"> e</span><span class="pun" style="color: rgb(102, 102, 0);">-&gt;</span><span class="pln" style="color: rgb(0, 0, 0);">fixup</span><span class="pun" style="color: rgb(102, 102, 0);">;</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">&nbsp;</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">return</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="lit" style="color: rgb(0, 102, 102);">0</span><span class="pun" style="color: rgb(102, 102, 0);">;</span></p></li><li><p><span class="pun" style="color: rgb(102, 102, 0);">}</span></p></li></ol></pre><br  /></code></pre><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">在32位处理器上，创建exception table entry相对简单。针对copy_{to,from}_user()汇编代码中每一处用户空间地址访问的指令都会创建一个entry，并且insn存储当前指令对应的地址，fixup存储修复指令对应的地址。</span></p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">当64位处理器开始发展起来，如果我们继续使用这种方式，势必需要2倍于32位处理器的内存存储exception table（因为存储一个地址需要8 bytes）。所以，kernel换用另一种方式实现。在64处理器上，struct exception_table_entry</span><span style="font-size: 17px;">定义</span><span style="font-size: 17px;">如下：</span></p><pre style="color: rgb(50, 50, 50);font-size: 13px;text-align: left;background-color: rgb(255, 255, 255);"><code class="language-c" lang="c"><pre class="prettyprint lang-cpp linenums" style="border-width: 0px;border-style: solid;border-color: rgb(136, 136, 136);font-family: &quot;Courier New&quot;, Courier, monospace;font-size: 12px;overflow: auto;margin-top: 5px;margin-bottom: 5px;line-height: 12pt;"><ol class="linenums list-paddingleft-2" style=""><li><p><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">struct</span><span class="pln" style="color: rgb(0, 0, 0);"> exception_table_entry </span><span class="pun" style="color: rgb(102, 102, 0);">{</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	</span><span class="typ" style="color: rgb(102, 0, 102);">int</span><span class="pln" style="color: rgb(0, 0, 0);"> insn</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> fixup</span><span class="pun" style="color: rgb(102, 102, 0);">;</span></p></li><li><p><span class="pun" style="color: rgb(102, 102, 0);">};</span></p></li></ol></pre><br  /></code></pre><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">每个exception table entry占用的内存和32位处理器情况一样，因此内存占用不变。但是insn和fixup的意义发生变化。insn和fixup分别存储着异常发生地址及修复地址相对于当前结构体成员地址的偏移（有点拗口）。例如，根据异常地址ex_addr查找对应的修复地址（未找到返回0），其示意代码如下：</span></p><pre style="color: rgb(50, 50, 50);font-size: 13px;text-align: left;background-color: rgb(255, 255, 255);"><pre class="prettyprint lang-cpp linenums" style="border-width: 0px;border-style: solid;border-color: rgb(136, 136, 136);font-family: &quot;Courier New&quot;, Courier, monospace;font-size: 12px;overflow: auto;margin-top: 5px;margin-bottom: 5px;line-height: 12pt;"><ol class="linenums list-paddingleft-2" style=""><li><p><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">unsigned</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">long</span><span class="pln" style="color: rgb(0, 0, 0);"> search_fixup_addr64</span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">unsigned</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">long</span><span class="pln" style="color: rgb(0, 0, 0);"> ex_addr</span><span class="pun" style="color: rgb(102, 102, 0);">)</span></p></li><li><p><span class="pun" style="color: rgb(102, 102, 0);">{</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">const</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">struct</span><span class="pln" style="color: rgb(0, 0, 0);"> exception_table_entry </span><span class="pun" style="color: rgb(102, 102, 0);">*</span><span class="pln" style="color: rgb(0, 0, 0);">e</span><span class="pun" style="color: rgb(102, 102, 0);">;</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">&nbsp;</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">for</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="pln" style="color: rgb(0, 0, 0);">e </span><span class="pun" style="color: rgb(102, 102, 0);">=</span><span class="pln" style="color: rgb(0, 0, 0);"> __start___ex_table</span><span class="pun" style="color: rgb(102, 102, 0);">;</span><span class="pln" style="color: rgb(0, 0, 0);"> e </span><span class="pun" style="color: rgb(102, 102, 0);">&lt;</span><span class="pln" style="color: rgb(0, 0, 0);"> __stop___ex_table</span><span class="pun" style="color: rgb(102, 102, 0);">;</span><span class="pln" style="color: rgb(0, 0, 0);"> e</span><span class="pun" style="color: rgb(102, 102, 0);">++)</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">		</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">if</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="pln" style="color: rgb(0, 0, 0);">ex_addr </span><span class="pun" style="color: rgb(102, 102, 0);">==</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">unsigned</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">long</span><span class="pun" style="color: rgb(102, 102, 0);">)&amp;</span><span class="pln" style="color: rgb(0, 0, 0);">e</span><span class="pun" style="color: rgb(102, 102, 0);">-&gt;</span><span class="pln" style="color: rgb(0, 0, 0);">insn </span><span class="pun" style="color: rgb(102, 102, 0);">+</span><span class="pln" style="color: rgb(0, 0, 0);"> e</span><span class="pun" style="color: rgb(102, 102, 0);">-&gt;</span><span class="pln" style="color: rgb(0, 0, 0);">insn</span><span class="pun" style="color: rgb(102, 102, 0);">)</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">			</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">return</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">(</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">unsigned</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">long</span><span class="pun" style="color: rgb(102, 102, 0);">)&amp;</span><span class="pln" style="color: rgb(0, 0, 0);">e</span><span class="pun" style="color: rgb(102, 102, 0);">-&gt;</span><span class="pln" style="color: rgb(0, 0, 0);">fixup </span><span class="pun" style="color: rgb(102, 102, 0);">+</span><span class="pln" style="color: rgb(0, 0, 0);"> e</span><span class="pun" style="color: rgb(102, 102, 0);">-&gt;</span><span class="pln" style="color: rgb(0, 0, 0);">fixup</span><span class="pun" style="color: rgb(102, 102, 0);">;</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">&nbsp;</span></p></li><li><p><span class="pln" style="color: rgb(0, 0, 0);">	</span><span class="kwd" style="color: rgb(0, 0, 136);font-weight: bold;">return</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="lit" style="color: rgb(0, 102, 102);">0</span><span class="pun" style="color: rgb(102, 102, 0);">;</span></p></li><li><p><span class="pun" style="color: rgb(102, 102, 0);">}</span><span class="pln" style="color: rgb(0, 0, 0);"> </span></p></li></ol></pre><br  /></pre><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">因此，我们的关注点就是如何去构建exception_table_entry。我们针对每个用户空间地址的内存访问都需要创建一个exception table entry，并插入__ex_table段。例如下面的汇编指令（汇编指令对应的地址是随意写的，不用纠结对错。理解原理才是王道）。</span></p><pre style="color: rgb(50, 50, 50);font-size: 13px;text-align: left;background-color: rgb(255, 255, 255);"><code class="language-assembly" lang="assembly"><pre class="prettyprint linenums" style="border-width: 0px;border-style: solid;border-color: rgb(136, 136, 136);font-family: &quot;Courier New&quot;, Courier, monospace;font-size: 12px;overflow: auto;margin-top: 5px;margin-bottom: 5px;line-height: 12pt;"><ol class="linenums list-paddingleft-2" style=""><li><p><span class="lit" style="color: rgb(0, 102, 102);">0xffff000000000000</span><span class="pun" style="color: rgb(102, 102, 0);">:</span><span class="pln" style="color: rgb(0, 0, 0);"> ldr x1</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">[</span><span class="pln" style="color: rgb(0, 0, 0);">x0</span><span class="pun" style="color: rgb(102, 102, 0);">]</span></p></li><li><p><span class="lit" style="color: rgb(0, 102, 102);">0xffff000000000004</span><span class="pun" style="color: rgb(102, 102, 0);">:</span><span class="pln" style="color: rgb(0, 0, 0);"> add x1</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> x1</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="com" style="color: rgb(136, 0, 0);">#0x10</span></p></li><li><p><span class="lit" style="color: rgb(0, 102, 102);">0xffff000000000008</span><span class="pun" style="color: rgb(102, 102, 0);">:</span><span class="pln" style="color: rgb(0, 0, 0);"> ldr x2</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="pun" style="color: rgb(102, 102, 0);">[</span><span class="pln" style="color: rgb(0, 0, 0);">x0</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="com" style="color: rgb(136, 0, 0);">#0x10]</span></p></li><li><p><span class="com" style="color: rgb(136, 0, 0);">/* ... */</span></p></li><li><p><span class="lit" style="color: rgb(0, 102, 102);">0xffff000040000000</span><span class="pun" style="color: rgb(102, 102, 0);">:</span><span class="pln" style="color: rgb(0, 0, 0);"> mov x0</span><span class="pun" style="color: rgb(102, 102, 0);">,</span><span class="pln" style="color: rgb(0, 0, 0);"> </span><span class="com" style="color: rgb(136, 0, 0);">#0xfffffffffffffff2    // -14</span></p></li><li><p><span class="lit" style="color: rgb(0, 102, 102);">0xffff000040000004</span><span class="pun" style="color: rgb(102, 102, 0);">:</span><span class="pln" style="color: rgb(0, 0, 0);"> ret</span></p></li></ol></pre><br  /></code></pre><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">假设x0寄存器保存着用户空间地址，因此我们需要对0xffff000000000000地址的汇编指令创建一个exception table entry，并且我们期望当x0是非法用户空间地址时，跳转返回的修复地址是0xffff000040000000。为了计算简单，假设这是创建第一个entry，</span><code><span style="font-size: 17px;">__start___ex_table</span></code><span style="font-size: 17px;">值是0xffff000080000000。那么第一个exception table entry的insn和fixup成员的值分别是：0x80000000和0xbffffffc（这两个值都是负数）。因此，针对copy_{to,from}_user()汇编代码中每一处用户空间地址访问的指令都会创建一个entry。所以0xffff000000000008地址处的汇编指令也需要创建一个exception table entry。</span></p><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">所以，如果内核态访问非法用户空间地址究竟发生了什么？上面的分析流程可以总结如下：</span></p><section class="output_wrapper" style="font-size: 16px;color: rgb(62, 62, 62);line-height: 1.6;letter-spacing: 0px;font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;"><blockquote style="line-height: inherit;padding: 15px 15px 15px 1rem;font-size: 0.9em;color: rgb(129, 145, 152);border-left-width: 6px;border-left-color: rgb(220, 230, 240);background: rgb(242, 247, 251);overflow: auto;overflow-wrap: normal;word-break: normal;"><p style="font-size: inherit;color: inherit;line-height: inherit;">1.访问非法用户空间地址:0xffff000000000000: ldr x1, [x0]<br  />2.MMU触发异常<br  />3.CPU调用do_page_fault()<br  />4.do_page_fault()调用search_exception_table()（regs-&gt;pc == 0xffff000000000000）<br  />5.查看__ex_table段，寻找0xffff000000000000 并且返回修复地址0xffff000040000000<br  />6.do_page_fault()修改函数返回地址（regs-&gt;pc = 0xffff000040000000）并返回<br  />7.程序继续执行，处理出错情况<br  />8.修改函数返回值x0 = -EFAULT (-14) 并返回（ARM64通过x0传递函数返回值）</p></blockquote></section><h2 style="color: rgb(31, 31, 31);font-size: 18px;font-weight: bold;margin-top: 25px;margin-bottom: 10px;font-family: Arial, Helvetica, sans-serif;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 20px;">总结</span></h2><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">到了回顾总结的时候，copy_{to,from}_user()的思考也到此结束。我们来个总结结束此文。</span></p><ul style="" class=" list-paddingleft-2"><li><p>无论是内核态还是用户态访问合法的用户空间地址，当虚拟地址并未建立物理地址的映射关系的时候，page fault的流程几乎一样，都会帮助我们申请物理内存并创建映射关系。所以这种情况下memcpy()和copy_{to,from}_user()是类似的。</p></li><li><p>当内核态访问非法用户空间地址的时候，通过<code>.fixup</code>和<code>__ex_table</code>两个段的帮助尝试修复异常。这种修复异常并不是建立地址映射关系，而是修改do_page_fault()返回地址。memcpy()由于没有创建这样的段，所以memcpy()无法做到这点。</p></li><li><p>在使能<code>CONFIG_ARM64_SW_TTBR0_PAN</code>或者<code>CONFIG_ARM64_PAN</code>（硬件支持的情况下才有效）的时候，我们只能使用copy_{to,from}_user()这种接口，直接使用memcpy()是不行的。</p><p><br  /></p></li></ul><p style="padding-bottom: 15px;line-height: 20px;color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;white-space: normal;background-color: rgb(255, 255, 255);"><span style="font-size: 17px;">最后，我想说，即使在某些情况下memcpy()可以正常工作。但是，这也是不推荐的，不是良好的编程习惯。在用户空间和内核空间数据交互上，我们必须使用类似copy_{to,from}_user()的接口。为什么类似呢？因为还有其他的接口用于内核空间和用户空间数据交互，只是没有copy_{to,from}_user()出名。例如：{get,put}_user()。</span></p><p><em style="max-width: 100%;letter-spacing: 0.544px;white-space: normal;background-color: rgb(255, 255, 255);caret-color: rgb(0, 82, 255);color: rgb(0, 82, 255);box-sizing: border-box !important;overflow-wrap: break-word !important;">本文转自蜗窝科技</em></p>
                </div>
                

                
  <div class="ct_mpda_wrp" id="js_sponsor_ad_area" style="display: none;"></div>


                
                <div class="read-more__area" id="js_more_read_area" style="display:none;">
                    
                </div>

                
                                <div class="reward_area tc reward_area_primary" id="js_preview_reward_author" style="display:none;">
                    <div class="reward-avatar" style="display: none;" id="js_preview_reward_author_avatar">
                        <img src="" alt="" id="js_preview_reward_author_head">
                    </div>
                    
                                        <div class="reward-author" id="js_preview_reward_author_name">smcdef</div>
                                        <p class="reward_tips" id="js_preview_reward_author_wording" style="display:none;"></p>
                    <p class="reward_button_wrp">
                    
                      <span class="reward_pop_panel">
                        <img src="https://res.wx.qq.com/mpres/zh_CN/htmledition/pages/home/index/pic_mp_app4290ba.png" alt="">
                        <strong>扫一扫下载订阅号助手，用手机发文章</strong>
                      </span>
                        <a class="reward_button" id='js_preview_reward_author_link' href="##"><span id="js_preview_reward_link_text">赞赏</span></a>
                    </p>
                </div>

                <div class="reward_qrcode_area reward_area tc" id="js_preview_reward_qrcode" style="display:none;">
                    <p class="tips_global">长按二维码向我转账</p>
                    <p id="js_preview_reward_ios_wording" class="reward_tips" style="display:none;"></p>
                    <span class="reward_qrcode_img_wrp"><img class="reward_qrcode_img" src="res.wx.qq.com/mmbizwap/zh_CN/htmledition/images/pic/appmsg/pic_reward_qrcode.2x42f400.png"></span>
                    <p class="tips_global">受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。</p>
                </div>
                            </div>
		<div class="comment">
			<h3 style="margin:26px 0;font-weight:100;padding-bottom:4px;border-bottom:1px solid #ccc;">精选留言</h3>
		    暂无...
		</div>
	</div>
	<div class='dy_all'>
		<a href='http://www.wowotech.net/memory_management/454.html' target='_blank'>
			阅读全文
		</a>
	</div>
</body>