<!DOCTYPE html>
<head>
	<meta http-equiv='Content-Type' content='text/html;charset=utf-8'>
	<meta name='viewport' content='width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no'>
	<title>
		Shrinking The Kernel With A Hammer
	</title>
	<script src='https://cdn.bootcss.com/jquery/1.10.2/jquery.min.js'>
	</script>
	<style>
		a {color: #607fa6;text-decoration:none;word-wrap:break-word;word-break:break-all;}.rich_media_title{padding-bottom:10px;margin-bottom:14px;border-bottom:1px solid #e7e7eb;font-weight:400;} .rich_media_meta_list{font-size:14px;margin-bottom: 22px;}
		.rich_media_meta{display:inline-block;vertical-align:middle;margin-right:8px;margin-bottom:10px;font-size:14px;}.rich_media_meta_text{color:#8c8c8c;color:rgba(0, 0, 0, 0.3)}.rich_media_meta_list
		em {font-style: normal;}@media screen and (max-width:768px){.rich_media{position:
		relative;padding: 20px 15px 15px;background-color: #fff;}}.rich_media_content{text-align:justify;} .rich_media_content * {max-width:100%!important;box-sizing: border-box!important;-webkit-box-sizing:
		border-box!important;word-wrap: break-word!important;}.rich_media_content
		blockquote {margin: 0;padding-left: 10px;border-left: 3px solid #dbdbdb;}.rich_media_content
		.list-paddingleft-2 {padding-left: 2.2em;}a.rich_media_meta_nickname{display: none;}@media screen and (min-width:1025px){.rich_media{position:relative;}a.rich_media_meta_nickname{display:inline-block!important;}span.rich_media_meta_nickname
		{display: inline-block!important;}.rich_media {width:677px;margin-left:auto;margin-right:auto;}}a.fwjm{font-size: 12px;color: #ececec;}.tenvideo_player {position: relative;width:
		100 %;height: 100 %;margin: auto;background: #000;}* {margin:0px;padding:0px;} body{line-height: 1.6;letter-spacing: .034em;}
		.dy_all {text-align: center;margin: 30px 0;} .dy_all a {display: inline-block;height:
		38px;line-height: 38px;padding: 0 18px;background-color: #009688;color:
		#fff;white-space: nowrap;font-size: 14px;border: none;border-radius: 2px;cursor:
		pointer;text-align: center;outline: 0;-webkit-appearance: none;transition:
		all .3s;-webkit-transition: all .3s;box-sizing: border-box;} img{max-width: 677px!important;}

		.crawler-info{padding: 8px 0;} .article-link>img{margin-left: 20px;width: 16px;}
		.comment-item::before,.comment-item::after{content:'';display:block;height:0;visibility:hidden;clear:both;*zoom:1;} .comment-item{margin-bottom:30px;}
		.avatar{width:12%; padding-right:10px;float:left;box-sizing:border-box;} .avatar img{width:100%;}
		.comment-body{float:left;width:88%;} .comment-body .comment-info{color:#b3b3b3;margin-bottom:4px;margin-top: -5px;} .comment-body .comment-info>span:last-child{float:right;} 
		.comment-author{border-left:4px solid green;padding-left:6px;margin:8px 0;}

		@media screen and (max-width: 420px) {.article-link>img {margin-left: 0px;}}
		@media screen and (min-width: 480px) {.avatar {width: 9%;}.comment-body {width: 91%;}}
	</style>
</head>
<body>
	<div id='js_article' class='rich_media'>
		<div class="crawler-info">
			<a href='https://www.52pojie.cn' class='fwjm' target='_blank'>
				提供的爬取软件来源于：52pojie.cn@夜泉 免费下载使用
			</a>
			<a href='https://mp.weixin.qq.com/s?__biz=MzI3NzA5MzUxNA==&amp;mid=2664606293&amp;idx=1&amp;sn=a973c94c7fd78e85c69b3199bb69f882&amp;chksm=f04d87b0c73a0ea6a80a8ce0ac2ce13dbc62dc40f263627515da1f1118bc2020bf84356d8f8b&amp;scene=27#wechat_redirect&cpage=8' target='_blank' class="article-link">
				<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAMAAABA3o1rAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjk4QUEzQzVDNkNGQjExRTk5NzNBQ0VBMjgzMjY1NjkwIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjk4QUEzQzVENkNGQjExRTk5NzNBQ0VBMjgzMjY1NjkwIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OThBQTNDNUE2Q0ZCMTFFOTk3M0FDRUEyODMyNjU2OTAiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OThBQTNDNUI2Q0ZCMTFFOTk3M0FDRUEyODMyNjU2OTAiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5TKSKsAAAAclBMVEUuLi77+/stLS1VVVXx8fFOTk7s7Ozt7e1qamp5eXlNTU2WlpZFRUU6Ojrq6urn5+d/f3/8/Pw9PT0/Pz+YmJg8PDyZmZlAQECfn5+QkJBBQUFra2vo6OhDQ0OSkpKenp5WVlY+Pj7r6+tpaWksLCz///9o6ILHAAAAJnRSTlP/////////////////////////////////////////////////AKd6gbwAAACNSURBVHjajJHpEoIwDISDVMotcnuCmLz/K9KCdlqO6v7p7Mw3yW4KxG85fnUkIVfZ5J0SsCtqcgRw0HzjQYY2AAOIdRuaK4ReAPJ5nmglL5qICahpU60C0uXguQ9TgIwGJoDnT9z/ABmxt60ot0N2CsDLfb9mvBxs9ql+n5o9bEDBgbif7/1F4g80CjAAqrVAnnsm5f8AAAAASUVORK5CYII=" />
			</a>
		</div>
		<div id="img-content">

                
                <h2 class="rich_media_title" id="activity-name">Shrinking The Kernel With A Hammer</h2>
                <div id="meta_content" class="rich_media_meta_list">
                                                                                                            <span class="rich_media_meta rich_media_meta_text">
                                                        ​石祤
                                                    </span>
                                                                
                                        <span class="rich_media_meta rich_media_meta_nickname" id="profileBt"><a href="javascript:void(0);">Linux内核之旅</a>
                      <div id="js_profile_qrcode" class="profile_container" style="display:none;">
                          <div class="profile_inner">
                              <strong class="profile_nickname">Linux内核之旅</strong>
                              <img class="profile_avatar" id="js_profile_qrcode_img" src="" alt="">

                              <p class="profile_meta">
                              <label class="profile_meta_label">微信号</label>
                              <span class="profile_meta_value">LinuxKernelTravel</span>
                              </p>

                              <p class="profile_meta">
                              <label class="profile_meta_label">功能介绍</label>
                              <span class="profile_meta_value">Linux内核之旅</span>
                              </p>
                              
                          </div>
                          <span class="profile_arrow_wrp" id="js_profile_arrow_wrp">
                              <i class="profile_arrow arrow_out"></i>
                              <i class="profile_arrow arrow_in"></i>
                          </span>
                      </div>
                    </span>


                    <em id="publish_time" class="rich_media_meta rich_media_meta_text">2019-03-14</em>





                </div>

                
                
                                
                
                
                
                                                
                                                                
                                
                
                <div class="rich_media_content " id="js_content">
                    

                    

                    
                    
                    <section data-role="outer" label="Powered by 135editor.com" style="font-size:16px;"><section data-role="outer" label="Powered by 135editor.com"><section data-id="undefined" class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"><section style="margin: 5px;padding-top: 10px;text-align: center;box-sizing: border-box;"><h1 class="" itemprop="name headline" style="margin-bottom: 2em;font-weight: bold;font-size: 1.875rem;max-width: 100%;font-family: consolas, monaco, courier, fixed-width;font-style: inherit;font-variant: inherit;letter-spacing: 0.544px;white-space: normal;widows: 1;border-width: 0px;border-style: initial;border-color: initial;font-stretch: inherit;line-height: 1.2;vertical-align: baseline;">大刀阔斧精简内核</h1></section></section><section data-id="2484" class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"><section style="margin:10px 10%;"><section class="135brush" data-style="font-size:14px;text-align: justify; line-height: 25px;" style="line-height: 25px;color: inherit;"><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;"><span style="letter-spacing: 0.544px;color: inherit;">&nbsp; &nbsp; 这是“讨论各种精简内核大小方法系列文章”的第四篇,旨在让 Linux 内核能适用于小型的运行环境。精简内核二进制文件是有其极限的，而我们已经尽可能地做到极致。但是，我们的目标是将 Linux 完全运行在一个片上微控制器，这个目标还没有达到。这篇文章会通过使内核和用户态适用于资源受限系统的角度来总结这个系列文章</span>。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 微控制器是一个自包含的系统，它拥有外设，内存和CPU。它通常较小，廉价，而且低功耗。微控制器被设计成用于实现单一任务和运行某个特定的程序。因此，微控制器中的动态内存通常比静态内存空间小的多。这也就是为何微控制器上的 ROM 普遍比 RAM 大很多倍的原因。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 比如说， ATmega328 （常见的 Arduino 型号）装载 32KB 的闪存（flash），但只有 2KB 的静态内存（SRAM）。至于可以运行 Linux 的 STM32F767BI 装载了 2MB 的闪存和 512KB 的静态内存。所以，我们将锁定使用这些资源来确定如何将最多的内容从 RAM 搬移到 ROM。</p><p style="color: inherit;line-height: 2em;"><br  /></p></section></section></section><section data-role="paragraph" class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"><p><br  /></p></section><section data-id="2280" class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"><section style="border-width: 0px;border-style: initial;border-color: initial;box-sizing: border-box;width: 100%;clear: both;overflow: hidden;"><section style="box-sizing: border-box;width: 30%;float: left;padding-right: 0.1em;text-align: right;color: inherit;"><section style="width: 100px;height: 100px;border-width: 10px;border-style: solid;border-color: rgb(33, 33, 34);color: rgb(254, 254, 254);margin-top: 10px;margin-bottom: 10px;display: inline-block;border-radius: 100%;box-sizing: border-box;"></section></section><section style="margin-top: 15px;margin-bottom: 10px;box-sizing: border-box;width: 70%;float: left;padding-top: 10px;padding-bottom: 10px;margin-left: -50px;color: inherit;"><section style="color: inherit;background-color: #fefefe;"><h2 style="margin-top: 0.75em;margin-bottom: 0.75em;font-weight: bold;font-size: 1.625rem;max-width: 100%;font-family: -apple-system-font, BlinkMacSystemFont, Arial, sans-serif;font-style: inherit;font-variant: inherit;letter-spacing: 0.544px;white-space: normal;widows: 1;border-width: 0px;border-style: initial;border-color: initial;font-stretch: inherit;line-height: 1.2;vertical-align: baseline;">Kernel XIP</h2></section></section></section></section><section data-id="2484" class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"><section style="margin:10px 10%;"><section class="135brush" data-style="color: inherit; text-align: justify; line-height: 2em;font-size:14px" style="line-height: 25px;color: inherit;"><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; “就地运行“（eXecute-In-Place XIP）机制允许 CPU 从 ROM 或者闪存中获取指令，这样一来可以避免将运行指令存储和加载到 RAM 中。XIP 引入到微控制器领域是因为它们的 RAM 通常都很小。所以，XIP 在大型系统上很少被使用（因他们拥有充足的内存，所以直接在 RAM 上运行所有东西）；在 RAM 上运行指令因为高性能缓存也会变得更高效。这个也就是为何大部分 Linux 架构不支持 XIP。实际上，内核的 XIP 只在 ARM 平台上支持，而且早在 Git 出现之前。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 至于内核 XIP， 它需要 ROM 或者闪存能跟内存一样直接通过处理器的内存地址来被访问，且不需要单独的软件驱动。NOR 闪存支持随机访问而经常被用于这个目的，它不像使用块地址索引的 NAND 闪存。然后，内核在构建链接时特殊处理，这样一来代码段和只读数据段将被分配到闪存的地址空间中。我们只需要开启 CONFIG_XIP_KERNEL，构建系统会提示输入预期内核要在闪存上的物理地址。只有可写的内核数据将被拷贝到 RAM 上。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 因此，我们期望 XIP 内核更可能多地将代码和数据放置到闪存中。越多空间被放置在闪存中，越少的空间会被拷贝到珍贵的 RAM 上。默认方法和其被 const 标注的数据将会被放置到 flash 上。最近内核开发上为了强化变量用途展开了很多常量化工作，这使得 XIP 内核受益很多。</p></section></section></section><section data-id="132" class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"><section style="border-width: 0px;border-style: initial;border-color: initial;text-align: center;box-sizing: border-box;"><section style="display: inline-block;box-sizing: border-box;color: inherit;"><section style="margin-top: 0em;max-width: 100%;color: rgb(33, 33, 34);font-size: 1.8em;line-height: 1;border-bottom: 1px solid rgb(33, 33, 34);border-top-color: rgb(33, 33, 34);border-right-color: rgb(33, 33, 34);border-left-color: rgb(33, 33, 34);box-sizing: border-box;"><h2 style="margin-top: 0.75em;margin-bottom: 0.75em;font-weight: bold;font-size: 1.625rem;max-width: 100%;color: rgb(51, 51, 51);font-family: -apple-system-font, BlinkMacSystemFont, Arial, sans-serif;font-style: inherit;font-variant: inherit;letter-spacing: 0.544px;text-align: justify;white-space: normal;widows: 1;border-width: 0px;border-style: initial;border-color: initial;font-stretch: inherit;line-height: 1.2;vertical-align: baseline;">&nbsp; &nbsp;用户态 XIP 和文件系统　</h2></section><section class="135brush" data-brushtype="text" style="margin: 0em;font-size: 1em;line-height: 1;color: #212122;box-sizing: border-box;border-color: #212122;text-align: left;">　　　　　　</section></section></section></section><section data-role="paragraph" class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"><p><br  /></p></section><section data-id="2484" class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"><section style="margin:10px 10%;"><section class="135brush" data-style="color: inherit; text-align: justify; line-height: 2em;font-size:14px" style="line-height: 25px;color: inherit;"><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 用户空间是个内存消耗大户。但是，正如内核一样，用户空间二进制有可读可写和只读段。如果能将只读段也存放在之前相同的闪存空间，并从闪存中直接运行，这样就避免被加载到内存中。然而，并非完全与内核一样，内核是一个静态的二进制，它只被加载或者映射到 ROM 和 RAM 地址一次。用户空间的程序存在与文件系统，这样使得事情变得复杂起来。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 我们能否摈弃文件系统？当然可以。事实上，这也是大多数小型实时操作系统的做法。他们把程序代码直接跟内核链接到一起，完全绕开文件系统层。而且这也不会颠覆 Linux 的运行机制，因为内核线程本身就可以当作是一个用户态的程序： 他们拥有自己的执行上下文，与用户程序一起被调度，可以被发送信号，显示在进程列表中，等等。而且内核线程也不需要文件系统。虽然，将程序运行在内核线程中，可能导致整个内核崩溃，但是微控制器中本来也缺少 MMU 设备，它已经是一个纯粹的用户态程序了。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 然而，为用户态程序搭配一个文件系统，会有很多我们不想损失的优势：</p><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p style="max-width: 100%;min-height: 1em;">兼容全功能的 Linux 系统，这样我们的程序可以在本地工作站中开发测试</p></li><li><p style="max-width: 100%;min-height: 1em;">方便整合多个不相关的程序</p></li><li><p style="max-width: 100%;min-height: 1em;">可以单独开发和更新内核与用户态程序</p></li><li><p style="max-width: 100%;min-height: 1em;">与内核 GPL 协议划清界限</p></li></ul><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 也就是说，我们尽可能想要一个最小，最简单的文件系统。别忘记我们的闪存容量只有 2MB，而我们的内核已经占用 1MB。因为很多可写文件系统有它固有的损耗，我们只能排除这些文件系统，并且我们不希望写闪存区域，因为内核代码存在其中，写操作可能导致系统崩溃。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 注意：即使闪存通过开启 CONFIG_MTD_XIP 被用于 XIP，它也是受限可写的。当前只能在 Intel 和 AMD 的闪存设备实现，而且需要特定的架构支持</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">所以小型且只读文件系统的选择只有这些：</p><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p style="max-width: 100%;min-height: 1em;">Squiashfs：可高度扩展，默认压缩，代码有些复杂，没有 XIP 支持</p></li><li><p style="max-width: 100%;min-height: 1em;">Romfs： 简单，精小的代码，没有压缩，部分支持（没有 MMU 的系统） XIP</p></li><li><p style="max-width: 100%;min-height: 1em;">Cramfs： 简单，精小的代码，有压缩功能，非主干代码可以部分支持 (MMU上) XIP</p></li></ul><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 我选择 Cramfs，因为只它拥有的压缩机制能满足只使用少量的闪存，这些 romfs 所没有的。而且 Cramfs 的代码相对 squashfs 比较简单，可以较容易在没有 MMU 设备的系统上添加 XIP 特性。并且，Cramfs 只需配置一下可以完全被用在块设备上。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 然后，添加 XIP 到 cramfs 上的初步尝试是相当粗鲁而缺乏基本原则的。这些尝试功能要么能用，要么完全不能用：比如，每一个文件在 XIP 下，要么完全没压缩，要么完全压缩。实际上，可执行文件由代码和数据组成，既然可写数据得拷贝到 RAM 中，就没有必要让它们以非压缩的方式存在闪存中。所以，我只能靠自己重新设计 cramfs 在 MMU 和非 MMU 的 XIP 支持。我添加了所需的功能以实现混合压缩和不压缩任意区间的块，最终这确实满足上游合并的标准（主干 Linux 版本4.15 以后可用）。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 之后，我（再次）发现有10年历史的 AXFS 文件系统（仍不在主干维护）更适用。但，我只能放弃这个想法，毕竟我更愿意与主干代码打交道。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 有人会奇怪为何 DAX 没有在这里被适用。极端上，DAX 有点像 XIP；DAX 被制作于大型可写文件系统，并依赖 MMU 来实现页数据按需读入和置出。它的文档也提到另一个缺点：”DAX 的代码不能在虚拟映射缓存的架构中正确运行，如 ARM, MIPS 和 SPARC“。因为XIP 的 cramfs 是只读而且足够小，可以完全被映射到内存中，他的功能完全可以实现所需的结果，而且方式更简单，这样一来 DAX 在这个上下文下就有点太重了。</p></section></section></section><section data-id="132" class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"><section style="border-width: 0px;border-style: initial;border-color: initial;text-align: center;box-sizing: border-box;"><section style="display: inline-block;box-sizing: border-box;color: inherit;"><section style="margin-top: 0em;max-width: 100%;color: rgb(33, 33, 34);font-size: 1.8em;line-height: 1;border-bottom: 1px solid rgb(33, 33, 34);border-top-color: rgb(33, 33, 34);border-right-color: rgb(33, 33, 34);border-left-color: rgb(33, 33, 34);box-sizing: border-box;"><strong><span class="135brush" data-brushtype="text" style="font-size:24px;"><h2 style="margin-top: 0.75em;margin-bottom: 0.75em;font-weight: bold;font-size: 1.625rem;max-width: 100%;color: rgb(51, 51, 51);font-family: -apple-system-font, BlinkMacSystemFont, Arial, sans-serif;font-style: inherit;font-variant: inherit;letter-spacing: 0.544px;text-align: justify;white-space: normal;widows: 1;border-width: 0px;border-style: initial;border-color: initial;font-stretch: inherit;line-height: 1.2;vertical-align: baseline;"><span style="font-size: 20px;">&nbsp; &nbsp;用户空间 XIP 和可执行二进制格式&nbsp; &nbsp;</span></h2></span></strong></section><section class="135brush" data-brushtype="text" style="margin: 0em;font-size: 1em;line-height: 1;color: #212122;box-sizing: border-box;border-color: #212122;text-align: left;">　　　　　　</section></section></section></section><section data-id="2484" class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"><section style="margin:10px 10%;"><section class="135brush" data-style="color: inherit; text-align: justify; line-height: 2em;font-size:14px" style="line-height: 25px;color: inherit;"><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 现在，我们有了 XIP 支持的文件系统，是时候使用它了。我适用一个静态构建的 BusyBox 版本以保持简单。在适用具有 MMU 的架构，我们可以看到程序是如何被映射到内存中的。</p><blockquote style="margin-top: 1.5em;margin-bottom: 1.5em;padding-left: 1.5em;color: rgb(51, 51, 51);font-size: inherit;max-width: 100%;border-width: 0px 0px 0px 0.75em;border-left-color: rgb(204, 204, 204);font-family: inherit;font-style: inherit;font-variant: inherit;font-weight: inherit;letter-spacing: 0.544px;white-space: normal;widows: 1;border-top-style: initial;border-right-style: initial;border-bottom-style: initial;border-top-color: initial;border-right-color: initial;border-bottom-color: initial;font-stretch: inherit;line-height: 1.8;vertical-align: baseline;quotes: none;background-color: rgb(242, 242, 242);"><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;"># cat /proc/self/maps<br style="max-width: 100%;"  />00010000-000a5000 r-xp&nbsp;<strong style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font-style: inherit;font-variant: inherit;font-stretch: inherit;font-size: inherit;line-height: inherit;font-family: inherit;vertical-align: baseline;">08101000</strong>&nbsp;1f:00 1328 /bin/busybox<br style="max-width: 100%;"  />000b5000-000b7000 rw-p 00095000 1f:00 1328 /bin/busybox<br style="max-width: 100%;"  />000b7000-000da000 rw-p 00000000 00:00 0 [heap]<br style="max-width: 100%;"  />bea07000-bea28000 rw-p 00000000 00:00 0 [stack]<br style="max-width: 100%;"  />bebc1000-bebc2000 r-xp 00000000 00:00 0 [sigpage]<br style="max-width: 100%;"  />bebc2000-bebc3000 r–p 00000000 00:00 0 [vvar]<br style="max-width: 100%;"  />bebc3000-bebc4000 r-xp 00000000 00:00 0 [vdso]<br style="max-width: 100%;"  />ffff0000-ffff1000 r-xp 00000000 00:00 0 [vectors]</p></blockquote><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 第一行粗字体的线索就暴露了 XIP。这行代表文件的偏移与映射的关系。我们可以看到 0x08101000 明显大于文件偏移量；实际上，它代表闪存物理地址的偏移量。Cramfs 也可能用在某些场景调用 vm_insert_mixed() ，这样物理机地址汇报将不可用。在任意场景可靠的汇报映射关系将会很有用。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 第二行映射 /bin/busybox （.data 区）被标志成可读可写，并不像第一行的代码区，是只读可执行的。可写段不能映射到闪存中，因此需以正常的方式加载到内存中。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; MMU 让程序很容易使用绝对地址而不用在意它的实际内存使用量。在非 MMU 环境下，事情变得复杂起来，用户执行程序必须可以在任意内存地址上运行；因此地址无关代码（PIC）是一个必须选项。这个功能由 bFLT 平铺文件格式支持，该格式被 uClinux 架构支持了很久。然后，这个格式有许多限制，使得 XIP，共享库，或者两者合并，不容易操作。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 幸运地是，有一个 ELF 的变体格式，ELF FDPIC，可以解决这些限制。因为 FDPIC 段是地址无关的，不需要先决相对偏移量，因此它可以在多个可执行文件中共享代码段，正如 有 MMU 的 ELF 格式一样。代码段也可以做成 XIP。ELF FDPIC 支持已经被添加到了 ARM 架构上（同样主干 Linux 版本 4.15）</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 在我的 STM32 设备上，使用 XIP cramfs 和 ELF FDPIC 用户态二进制，BusyBox 的地址映射看起来是这样的：</p><pre class="" style="padding: 1.5em;max-width: 100%;font-size: 1em;font-style: inherit;font-variant: inherit;font-weight: inherit;letter-spacing: 0.544px;widows: 1;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);font-stretch: inherit;line-height: 23px;vertical-align: baseline;overflow: auto;max-height: 60em;box-shadow: rgba(0, 0, 0, 0.098) 0px 0px 2px;word-break: inherit;"><code style="max-width: 100%;border-width: initial;border-style: none;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: 1em;line-height: 1.75em;vertical-align: baseline;border-radius: 0px;background-image: none;background-attachment: initial;background-size: initial;background-origin: initial;background-clip: initial;background-position: initial;background-repeat: initial;"># cat /proc/self/maps<br style="max-width: 100%;"  />00028000-0002d000 rw-p 00037000 1f:03 1660 &nbsp; &nbsp; &nbsp; /bin/busybox &nbsp;<br style="max-width: 100%;"  />0002d000-0002e000 rw-p 00000000 00:00 0 &nbsp;<br style="max-width: 100%;"  />0002e000-00030000 rw-p 00000000 00:00 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[stack] &nbsp; &nbsp;<br style="max-width: 100%;"  />081a0760-081d8760 r-xs 00000000 1f:03 1660 &nbsp; &nbsp; &nbsp; /bin/busybox &nbsp;<br style="max-width: 100%;"  /></code></pre><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 因为缺少 MMU，使用 XIP 的段因为没有地址转换，直接可以看到闪存地址。</p></section></section></section><section data-id="132" class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"><section style="border-width: 0px;border-style: initial;border-color: initial;text-align: center;box-sizing: border-box;"><section style="display: inline-block;box-sizing: border-box;color: inherit;"><section style="margin-top: 0em;max-width: 100%;color: rgb(33, 33, 34);line-height: 1;border-bottom: 1px solid rgb(33, 33, 34);border-top-color: rgb(33, 33, 34);border-right-color: rgb(33, 33, 34);border-left-color: rgb(33, 33, 34);box-sizing: border-box;"><span style="font-size: 24px;"><strong>&nbsp; &nbsp; &nbsp;砍掉静态内存</strong></span><span style="font-size: 1.8em;">　</span></section><section class="135brush" data-brushtype="text" style="margin: 0em;font-size: 1em;line-height: 1;color: #212122;box-sizing: border-box;border-color: #212122;text-align: left;">　　　　　　</section></section></section></section><section data-role="paragraph" class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 好了，现在我们准备好做一些大动作。我们看到上面 XIP 的 BusyBox 已经省掉 229,376 字节内存，或者说 56 个内存页。如果我们有 512KB，这是 128 个页的 44%。从现在开始，精确地记录内存被分配到哪，决定这些珍贵的内存如何被高效使用，是很重要的。我们先从内核开始看，使用一个之前文章中精简过的配置，另外加上 XIP 配置，我们得到如下</p><pre class="" style="padding: 1.5em;max-width: 100%;font-size: 1em;font-style: inherit;font-variant: inherit;font-weight: inherit;letter-spacing: 0.544px;widows: 1;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);font-stretch: inherit;line-height: 23px;vertical-align: baseline;overflow: auto;max-height: 60em;box-shadow: rgba(0, 0, 0, 0.098) 0px 0px 2px;word-break: inherit;"><code style="max-width: 100%;border-width: initial;border-style: none;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: 1em;line-height: 1.75em;vertical-align: baseline;border-radius: 0px;background-image: none;background-attachment: initial;background-size: initial;background-origin: initial;background-clip: initial;background-position: initial;background-repeat: initial;"> &nbsp; text &nbsp; &nbsp;data &nbsp; &nbsp; bss &nbsp; &nbsp; dec &nbsp; &nbsp; hex filename<br style="max-width: 100%;"  />1016264 &nbsp; 97352 &nbsp;169568 1283184 &nbsp;139470 vmlinux<br style="max-width: 100%;"  /></code></pre><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 1,016,264 字节的代码段是被放置在闪存中的，我们先略过这一部分。但是，266,920 字节的数据段和 BSS 段使用了 51% 的内存总量。让我们通过一些脚本来找出哪些东西占用了这部分空间</p><pre class="" style="padding: 1.5em;max-width: 100%;font-size: 1em;font-style: inherit;font-variant: inherit;font-weight: inherit;letter-spacing: 0.544px;widows: 1;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);font-stretch: inherit;line-height: 23px;vertical-align: baseline;overflow: auto;max-height: 60em;box-shadow: rgba(0, 0, 0, 0.098) 0px 0px 2px;word-break: inherit;"><code style="max-width: 100%;border-width: initial;border-style: none;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: 1em;line-height: 1.75em;vertical-align: baseline;border-radius: 0px;background-image: none;background-attachment: initial;background-size: initial;background-origin: initial;background-clip: initial;background-position: initial;background-repeat: initial;"> &nbsp; &nbsp;<span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font-style: italic;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: inherit;line-height: inherit;font-family: inherit;vertical-align: baseline;color: rgb(153, 153, 136);">#!/bin/sh</span><br style="max-width: 100%;"  /> &nbsp; &nbsp;<span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: bold;font-stretch: inherit;font-size: inherit;line-height: inherit;font-family: inherit;vertical-align: baseline;">{</span><br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: rgb(0, 134, 179);">read&nbsp;</span>addr1 type1 sym1<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: bold;font-stretch: inherit;font-size: inherit;line-height: inherit;font-family: inherit;vertical-align: baseline;">while&nbsp;</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: rgb(0, 134, 179);">read&nbsp;</span>addr2 type2 sym2<span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;">;</span> <span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: bold;font-stretch: inherit;font-size: inherit;line-height: inherit;font-family: inherit;vertical-align: baseline;">do&nbsp;</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: teal;">size</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: bold;font-stretch: inherit;font-size: inherit;line-height: inherit;font-family: inherit;vertical-align: baseline;">=</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: bold;font-stretch: inherit;font-size: inherit;line-height: inherit;font-family: inherit;vertical-align: baseline;">$((</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: rgb(0, 153, 153);">0</span>x<span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: teal;">$addr2</span> <span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: bold;font-stretch: inherit;font-size: inherit;line-height: inherit;font-family: inherit;vertical-align: baseline;">-</span> <span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: rgb(0, 153, 153);">0</span>x<span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: teal;">$addr1</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: bold;font-stretch: inherit;font-size: inherit;line-height: inherit;font-family: inherit;vertical-align: baseline;">))</span><br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: bold;font-stretch: inherit;font-size: inherit;line-height: inherit;font-family: inherit;vertical-align: baseline;">case</span> <span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: teal;">$type1</span> <span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: bold;font-stretch: inherit;font-size: inherit;line-height: inherit;font-family: inherit;vertical-align: baseline;">in&nbsp;</span>b|B|d|D<span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;">)</span><br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: rgb(0, 134, 179);">echo</span> <span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: navy;">-e</span> <span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: rgb(221, 17, 68);">"</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: teal;">$type1</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: rgb(221, 17, 68);">&nbsp;</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: teal;">$size</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: rgb(221, 17, 68);">\t</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: teal;">$sym1</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: rgb(221, 17, 68);">"</span><br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;">;;</span><br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: bold;font-stretch: inherit;font-size: inherit;line-height: inherit;font-family: inherit;vertical-align: baseline;">esac</span><br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: teal;">type1</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: bold;font-stretch: inherit;font-size: inherit;line-height: inherit;font-family: inherit;vertical-align: baseline;">=</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: teal;">$type2</span><br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: teal;">addr1</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: bold;font-stretch: inherit;font-size: inherit;line-height: inherit;font-family: inherit;vertical-align: baseline;">=</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: teal;">$addr2</span><br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: teal;">sym1</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: bold;font-stretch: inherit;font-size: inherit;line-height: inherit;font-family: inherit;vertical-align: baseline;">=</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: teal;">$sym2</span><br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp;<span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: bold;font-stretch: inherit;font-size: inherit;line-height: inherit;font-family: inherit;vertical-align: baseline;">done</span><br style="max-width: 100%;"  /> &nbsp; &nbsp;<span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: bold;font-stretch: inherit;font-size: inherit;line-height: inherit;font-family: inherit;vertical-align: baseline;">}</span> &lt; System.map | <span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: rgb(0, 134, 179);">sort</span> <span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: navy;">-n</span> <span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: navy;">-r</span> <span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: navy;">-k</span> 2<br style="max-width: 100%;"  /></code></pre><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">前面几行的输出：</p><pre class="" style="padding: 1.5em;max-width: 100%;font-size: 1em;font-style: inherit;font-variant: inherit;font-weight: inherit;letter-spacing: 0.544px;widows: 1;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);font-stretch: inherit;line-height: 23px;vertical-align: baseline;overflow: auto;max-height: 60em;box-shadow: rgba(0, 0, 0, 0.098) 0px 0px 2px;word-break: inherit;"><code style="max-width: 100%;border-width: initial;border-style: none;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: 1em;line-height: 1.75em;vertical-align: baseline;border-radius: 0px;background-image: none;background-attachment: initial;background-size: initial;background-origin: initial;background-clip: initial;background-position: initial;background-repeat: initial;"> &nbsp; &nbsp;B 133953016 &nbsp; &nbsp; _end<br style="max-width: 100%;"  /> &nbsp; &nbsp;b 131072 &nbsp; &nbsp; &nbsp; &nbsp;__log_buf<br style="max-width: 100%;"  /> &nbsp; &nbsp;d 8192 &nbsp;safe_print_seq<br style="max-width: 100%;"  /> &nbsp; &nbsp;d 8192 &nbsp;nmi_print_seq<br style="max-width: 100%;"  /> &nbsp; &nbsp;D 8192 &nbsp;init_thread_union<br style="max-width: 100%;"  /> &nbsp; &nbsp;d 4288 &nbsp;timer_bases<br style="max-width: 100%;"  /> &nbsp; &nbsp;b 4100 &nbsp;in_lookup_hashtable<br style="max-width: 100%;"  /> &nbsp; &nbsp;b 4096 &nbsp;ucounts_hashtable<br style="max-width: 100%;"  /> &nbsp; &nbsp;d 3960 &nbsp;cpuhp_ap_states<br style="max-width: 100%;"  /> &nbsp; &nbsp;[...]<br style="max-width: 100%;"  /></code></pre><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 这里，我们忽略 _end，因为它使用了超大空间明显是因为一个情况，内存分配的末尾是在闪存前面的。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 然而，我们有一些明显分配情况用来考量问题。观察一下 __log_buf 的定义：</p><pre class="" style="padding: 1.5em;max-width: 100%;font-size: 1em;font-style: inherit;font-variant: inherit;font-weight: inherit;letter-spacing: 0.544px;widows: 1;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);font-stretch: inherit;line-height: 23px;vertical-align: baseline;overflow: auto;max-height: 60em;box-shadow: rgba(0, 0, 0, 0.098) 0px 0px 2px;word-break: inherit;"><code style="max-width: 100%;border-width: initial;border-style: none;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: 1em;line-height: 1.75em;vertical-align: baseline;border-radius: 0px;background-image: none;background-attachment: initial;background-size: initial;background-origin: initial;background-clip: initial;background-position: initial;background-repeat: initial;"> &nbsp; &nbsp;/* record buffer */<br style="max-width: 100%;"  /> &nbsp; &nbsp;#define LOG_ALIGN __alignof__(struct printk_log)<br style="max-width: 100%;"  /> &nbsp; &nbsp;#define __LOG_BUF_LEN (1 &lt;&lt; CONFIG_LOG_BUF_SHIFT)<br style="max-width: 100%;"  /> &nbsp; &nbsp;static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);<br style="max-width: 100%;"  /></code></pre><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 这个变量很简单，因为我们不想将整个 printk() 支持去掉，所以我们将 CONFIG_LOG_BUF_SHIFT 这设置成 12（最小可设置的值）。同时，我们将 CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT 设置成最小值 10. 结果：</p><pre class="" style="padding: 1.5em;max-width: 100%;font-size: 1em;font-style: inherit;font-variant: inherit;font-weight: inherit;letter-spacing: 0.544px;widows: 1;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);font-stretch: inherit;line-height: 23px;vertical-align: baseline;overflow: auto;max-height: 60em;box-shadow: rgba(0, 0, 0, 0.098) 0px 0px 2px;word-break: inherit;"><code style="max-width: 100%;border-width: initial;border-style: none;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: 1em;line-height: 1.75em;vertical-align: baseline;border-radius: 0px;background-image: none;background-attachment: initial;background-size: initial;background-origin: initial;background-clip: initial;background-position: initial;background-repeat: initial;"> &nbsp; text &nbsp; &nbsp;data &nbsp; &nbsp; bss &nbsp; &nbsp; dec &nbsp; &nbsp; hex filename<br style="max-width: 100%;"  />1016220 &nbsp; 83016 &nbsp; 42624 1141860 &nbsp;116c64 vmlinux<br style="max-width: 100%;"  /></code></pre><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 我们通过一些简单的配置调节，将内存使用量从 266,920 降低到 125,640 字节。我们再看看符号使用情况：</p><pre class="" style="padding: 1.5em;max-width: 100%;font-size: 1em;font-style: inherit;font-variant: inherit;font-weight: inherit;letter-spacing: 0.544px;widows: 1;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);font-stretch: inherit;line-height: 23px;vertical-align: baseline;overflow: auto;max-height: 60em;box-shadow: rgba(0, 0, 0, 0.098) 0px 0px 2px;word-break: inherit;"><code style="max-width: 100%;border-width: initial;border-style: none;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: 1em;line-height: 1.75em;vertical-align: baseline;border-radius: 0px;background-image: none;background-attachment: initial;background-size: initial;background-origin: initial;background-clip: initial;background-position: initial;background-repeat: initial;">B 134092280 &nbsp; &nbsp; _end<br style="max-width: 100%;"  />D 8192 &nbsp;init_thread_union<br style="max-width: 100%;"  />d 4288 &nbsp;timer_bases<br style="max-width: 100%;"  />b 4100 &nbsp;in_lookup_hashtable<br style="max-width: 100%;"  />b 4096 &nbsp;ucounts_hashtable<br style="max-width: 100%;"  />b 4096 &nbsp;__log_buf<br style="max-width: 100%;"  />d 3960 &nbsp;cpuhp_ap_states<br style="max-width: 100%;"  />[...]<br style="max-width: 100%;"  /></code></pre><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 下一个消耗大户是 init_thread_union 。这个比较有趣，因为它来源自 THREAD_SIZE_ORDER，它用来决定内核进程能拥有多少个栈页。第一个进程（init 进程）刚巧在数据字段静态分配了它的栈，这就是为何我们能在这里看到它。把这个值从 2 个修改到 1 个就能很好的适用在我们的小型环境里，而且这也能在动态分配栈时每进程能减少 1 个页。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 我们可以调整 LVL_BITS 从 6 到 4，来减少 timer_bases 的大小。调整 IN_LOOKUP_SHIFT 从 10 到 5. 连同一些其他内核常量。</p></section><p>&nbsp; &nbsp;&nbsp;</p><section data-id="132" class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"><section style="border-width: 0px;border-style: initial;border-color: initial;text-align: center;box-sizing: border-box;"><section style="display: inline-block;box-sizing: border-box;color: inherit;"><section style="margin-top: 0em;max-width: 100%;color: rgb(33, 33, 34);font-size: 1.8em;line-height: 1;border-bottom: 1px solid rgb(33, 33, 34);border-top-color: rgb(33, 33, 34);border-right-color: rgb(33, 33, 34);border-left-color: rgb(33, 33, 34);box-sizing: border-box;"><strong><span class="135brush" data-brushtype="text" style="font-size:24px;"><p>&nbsp; &nbsp; 搞定动态内存分配&nbsp; &nbsp;</p></span></strong></section><section class="135brush" data-brushtype="text" style="margin: 0em;font-size: 1em;line-height: 1;color: #212122;box-sizing: border-box;border-color: #212122;text-align: left;">　　　　　　</section></section></section></section><section data-id="2484" class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"><section style="margin:10px 10%;"><section class="135brush" data-style="color: inherit; text-align: justify; line-height: 2em;font-size:14px" style="line-height: 25px;color: inherit;"><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 正如我们所看见的，找出和减少静态内存分配是比较容易的。但是动态分配也需要好好处理，为了这个目的我们得将我们的设备引导起来。当内核的分配器还没有启动运行时，第一个动态分配器来自 memblock 分配器。观察其执行操作的方法是现成的，只要设置 memblock=debug 去启动它。它会显示如下：</p><pre class="" style="padding: 1.5em;max-width: 100%;font-size: 1em;font-style: inherit;font-variant: inherit;font-weight: inherit;letter-spacing: 0.544px;widows: 1;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);font-stretch: inherit;line-height: 23px;vertical-align: baseline;overflow: auto;max-height: 60em;box-shadow: rgba(0, 0, 0, 0.098) 0px 0px 2px;word-break: inherit;"><code style="max-width: 100%;border-width: initial;border-style: none;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: 1em;line-height: 1.75em;vertical-align: baseline;border-radius: 0px;background-image: none;background-attachment: initial;background-size: initial;background-origin: initial;background-clip: initial;background-position: initial;background-repeat: initial;">memblock_reserve: [0x00008000-0x000229f7] arm_memblock_init+0xf/0x48<br style="max-width: 100%;"  />memblock_reserve: [0x08004000-0x08007dbe] arm_memblock_init+0x1d/0x48<br style="max-width: 100%;"  /></code></pre><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 这里可以看出静态内存被保留了，它与内核代码，只读数据相连，一同存在闪存中（它们被映射在 0x08004000）。如果内核代码是在 RAM，是有必要保留这部分内存。在现在这个场景下，这个保留行为是无用但无害的行为，因为闪存永远不会被用于分配。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">现在看下实际的动态分配：</p><pre class="" style="padding: 1.5em;max-width: 100%;font-size: 1em;font-style: inherit;font-variant: inherit;font-weight: inherit;letter-spacing: 0.544px;widows: 1;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);font-stretch: inherit;line-height: 23px;vertical-align: baseline;overflow: auto;max-height: 60em;box-shadow: rgba(0, 0, 0, 0.098) 0px 0px 2px;word-break: inherit;"><code style="max-width: 100%;border-width: initial;border-style: none;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: 1em;line-height: 1.75em;vertical-align: baseline;border-radius: 0px;background-image: none;background-attachment: initial;background-size: initial;background-origin: initial;background-clip: initial;background-position: initial;background-repeat: initial;">memblock_virt_alloc_try_nid_nopanic: 131072 bytes align=0x0 nid=0<br style="max-width: 100%;"  />from=0x0 max_addr=0x0 alloc_node_mem_map.constprop.6+0x35/0x5c<br style="max-width: 100%;"  /> &nbsp;Normal zone: 32 pages used for memmap<br style="max-width: 100%;"  /> &nbsp;Normal zone: 4096 pages, LIFO batch:0<br style="max-width: 100%;"  /></code></pre><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; memmap 数组使用了 131,072 字节 （32 个页）去管理 4096 个页。默认这个设备需要使用 16MB 的主板外置内存地址。所以，如果我们把这个数字降低成实际的页数量，比如说 512KB，那么这个值会明显降低。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">下一个较大的分配是：</p><pre class="" style="padding: 1.5em;max-width: 100%;font-size: 1em;font-style: inherit;font-variant: inherit;font-weight: inherit;letter-spacing: 0.544px;widows: 1;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);font-stretch: inherit;line-height: 23px;vertical-align: baseline;overflow: auto;max-height: 60em;box-shadow: rgba(0, 0, 0, 0.098) 0px 0px 2px;word-break: inherit;"><code style="max-width: 100%;border-width: initial;border-style: none;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: 1em;line-height: 1.75em;vertical-align: baseline;border-radius: 0px;background-image: none;background-attachment: initial;background-size: initial;background-origin: initial;background-clip: initial;background-position: initial;background-repeat: initial;">memblock_virt_alloc_try_nid_nopanic: 32768 bytes align=0x1000 nid=-1<br style="max-width: 100%;"  />from=0xffffffff max_addr=0x0 setup_per_cpu_areas+0x21/0x64<br style="max-width: 100%;"  />pcpu-alloc: s0 r0 d32768 u32768 alloc=1*32768<br style="max-width: 100%;"  /></code></pre><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 在一个只有小于 1MB 内存的单处理器系统预留给每个 CPU 一个 32KB 的内存池？没必要。需要修改 include/linux/percpu.h 文件来修改成单个页</p><pre class="" style="padding: 1.5em;max-width: 100%;font-size: 1em;font-style: inherit;font-variant: inherit;font-weight: inherit;letter-spacing: 0.544px;widows: 1;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);font-stretch: inherit;line-height: 23px;vertical-align: baseline;overflow: auto;max-height: 60em;box-shadow: rgba(0, 0, 0, 0.098) 0px 0px 2px;word-break: inherit;"><code style="max-width: 100%;border-width: initial;border-style: none;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: 1em;line-height: 1.75em;vertical-align: baseline;border-radius: 0px;background-image: none;background-attachment: initial;background-size: initial;background-origin: initial;background-clip: initial;background-position: initial;background-repeat: initial;">-#define PCPU_MIN_UNIT_SIZE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PFN_ALIGN(32 &lt;&lt; 10)<br style="max-width: 100%;"  />+#define PCPU_MIN_UNIT_SIZE &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PFN_ALIGN(4 &lt;&lt; 10)<br style="max-width: 100%;"  /><br style="max-width: 100%;"  />-#define PERCPU_DYNAMIC_EARLY_SLOTS &nbsp; &nbsp; 128<br style="max-width: 100%;"  />-#define PERCPU_DYNAMIC_EARLY_SIZE &nbsp; &nbsp; &nbsp;(12 &lt;&lt; 10)<br style="max-width: 100%;"  />+#define PERCPU_DYNAMIC_EARLY_SLOTS &nbsp; &nbsp; 32<br style="max-width: 100%;"  />+#define PERCPU_DYNAMIC_EARLY_SIZE &nbsp; &nbsp; &nbsp;(4 &lt;&lt; 10)<br style="max-width: 100%;"  /><br style="max-width: 100%;"  />+#undef PERCPU_DYNAMIC_RESERVE<br style="max-width: 100%;"  />+#define PERCPU_DYNAMIC_RESERVE &nbsp; &nbsp; &nbsp; &nbsp; (4 &lt;&lt; 10)<br style="max-width: 100%;"  /></code></pre><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp;值得注意的是，只有 SLOB 内存分配器 （CONFIG_SLOB）在这些修改后能继续工作。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">继续看下一个较大的内存分配：</p><pre class="" style="padding: 1.5em;max-width: 100%;font-size: 1em;font-style: inherit;font-variant: inherit;font-weight: inherit;letter-spacing: 0.544px;widows: 1;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);font-stretch: inherit;line-height: 23px;vertical-align: baseline;overflow: auto;max-height: 60em;box-shadow: rgba(0, 0, 0, 0.098) 0px 0px 2px;word-break: inherit;"><code style="max-width: 100%;border-width: initial;border-style: none;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: 1em;line-height: 1.75em;vertical-align: baseline;border-radius: 0px;background-image: none;background-attachment: initial;background-size: initial;background-origin: initial;background-clip: initial;background-position: initial;background-repeat: initial;">memblock_virt_alloc_try_nid_nopanic: 8192 bytes align=0x0 nid=-1<br style="max-width: 100%;"  />from=0x0 max_addr=0x0 alloc_large_system_hash+0x119/0x1a4<br style="max-width: 100%;"  />Dentry cache hash table entries: 2048 (order: 1, 8192 bytes)<br style="max-width: 100%;"  />memblock_virt_alloc_try_nid_nopanic: 4096 bytes align=0x0 nid=-1<br style="max-width: 100%;"  />from=0x0 max_addr=0x0 alloc_large_system_hash+0x119/0x1a4<br style="max-width: 100%;"  />Inode-cache hash table entries: 1024 (order: 0, 4096 bytes)<br style="max-width: 100%;"  /></code></pre><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 谁说这是一个大型系统？是的，目前你应该领悟精简方法了 ———— 接下来值需要一些类似调整，不过为了让这篇文章保持合理的篇幅，这些调整被省略了。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 之后，通用的内核内存工作将被分配器如 kmalloc() 接管，所有的分配最终落在 __alloc_pages_nodemask(). 类似的跟踪和调整也适用在这个阶段，直到启动完成。有时就是配置调整的事情，如 sysfs 文件系统，它使用的内存有点超过我们的预算，等等。</p></section></section></section><section data-id="132" class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"><section style="border-width: 0px;border-style: initial;border-color: initial;text-align: center;box-sizing: border-box;"><section style="display: inline-block;box-sizing: border-box;color: inherit;"><section style="margin-top: 0em;max-width: 100%;color: rgb(33, 33, 34);font-size: 1.8em;line-height: 1;border-bottom: 1px solid rgb(33, 33, 34);border-top-color: rgb(33, 33, 34);border-right-color: rgb(33, 33, 34);border-left-color: rgb(33, 33, 34);box-sizing: border-box;"><strong><span class="135brush" data-brushtype="text" style="font-size:24px;"><h2 style="margin-top: 0.75em;margin-bottom: 0.75em;font-weight: bold;font-size: 1.625rem;max-width: 100%;color: rgb(51, 51, 51);font-family: -apple-system-font, BlinkMacSystemFont, Arial, sans-serif;font-style: inherit;font-variant: inherit;letter-spacing: 0.544px;text-align: justify;white-space: normal;widows: 1;border-width: 0px;border-style: initial;border-color: initial;font-stretch: inherit;line-height: 1.2;vertical-align: baseline;">&nbsp; &nbsp; &nbsp;回到用户空间　　</h2></span></strong></section><section class="135brush" data-brushtype="text" style="margin: 0em;font-size: 1em;line-height: 1;color: #212122;box-sizing: border-box;border-color: #212122;text-align: left;">　　　　　　</section></section></section></section><section data-id="2484" class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"><section style="margin:10px 10%;"><section class="135brush" data-style="color: inherit; text-align: justify; line-height: 2em;font-size:14px" style="line-height: 25px;color: inherit;"><p style="color: inherit;line-height: 2em;"><span style="font-family: inherit;font-size: inherit;font-style: inherit;font-variant-ligatures: inherit;font-variant-caps: inherit;font-weight: inherit;letter-spacing: 0.544px;widows: 1;caret-color: red;">&nbsp; &nbsp; 既然我们已经大幅降低内核的内存使用量，我们准备再次引导看看。这次引导成功最低的内存所需，我们设定成800KB （设置内核引导命令行”mem=800K“）。让我们看看这个小小的世界：</span></p><pre class="" style="padding: 1.5em;max-width: 100%;font-size: 1em;font-style: inherit;font-variant: inherit;font-weight: inherit;letter-spacing: 0.544px;widows: 1;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);font-stretch: inherit;line-height: 23px;vertical-align: baseline;overflow: auto;max-height: 60em;box-shadow: rgba(0, 0, 0, 0.098) 0px 0px 2px;word-break: inherit;"><code style="max-width: 100%;border-width: initial;border-style: none;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: 1em;line-height: 1.75em;vertical-align: baseline;border-radius: 0px;background-image: none;background-attachment: initial;background-size: initial;background-origin: initial;background-clip: initial;background-position: initial;background-repeat: initial;">BusyBox v1.7.1 (2017-09-16 02:45:01 EDT) hush - the humble shell<br style="max-width: 100%;"  /><br style="max-width: 100%;"  /># free<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total &nbsp; &nbsp; &nbsp; used &nbsp; &nbsp; &nbsp; free &nbsp; &nbsp; shared &nbsp; &nbsp;buffers &nbsp; &nbsp; cached<br style="max-width: 100%;"  />Mem: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 672 &nbsp; &nbsp; &nbsp; &nbsp;540 &nbsp; &nbsp; &nbsp; &nbsp;132 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0<br style="max-width: 100%;"  />-/+ buffers/cache: &nbsp; &nbsp; &nbsp; &nbsp;540 &nbsp; &nbsp; &nbsp; &nbsp;132<br style="max-width: 100%;"  /><br style="max-width: 100%;"  /># cat /proc/maps<br style="max-width: 100%;"  />00028000-0002d000 rw-p 00037000 1f:03 1660 &nbsp; &nbsp; &nbsp; /bin/busybox<br style="max-width: 100%;"  />0002d000-0002e000 rw-p 00000000 00:00 0<br style="max-width: 100%;"  />0002e000-00030000 rw-p 00000000 00:00 0<br style="max-width: 100%;"  />00030000-00038000 rw-p 00000000 00:00 0<br style="max-width: 100%;"  />0004d000-0004e000 rw-p 00000000 00:00 0<br style="max-width: 100%;"  />00061000-00062000 rw-p 00000000 00:00 0<br style="max-width: 100%;"  />0006c000-0006d000 rw-p 00000000 00:00 0<br style="max-width: 100%;"  />0006f000-00070000 rw-p 00000000 00:00 0<br style="max-width: 100%;"  />00070000-00078000 rw-p 00000000 00:00 0<br style="max-width: 100%;"  />00078000-0007d000 rw-p 00037000 1f:03 1660 &nbsp; &nbsp; &nbsp; /bin/busybox<br style="max-width: 100%;"  />081a0760-081d8760 r-xs 00000000 1f:03 1660 &nbsp; &nbsp; &nbsp; /bin/busybox<br style="max-width: 100%;"  /></code></pre><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 这里我们可以看到从 /bin/busybox 的文件偏移 0x37000 开始有 2 个 4 页的内存。这是两个数据实例，一个是 shell 进程，一个是 cat 进程。他们共同共享 busybox 从 0x081a0760 开始的 XIP 代码段。另外，还有两个匿名的 8 页内存，它们消耗了大量的页预算。他们相当于一个 32KB 的栈空间。这个页可以被调整下来：</p><pre class="" style="padding: 1.5em;max-width: 100%;font-size: 1em;font-style: inherit;font-variant: inherit;font-weight: inherit;letter-spacing: 0.544px;widows: 1;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);font-stretch: inherit;line-height: 23px;vertical-align: baseline;overflow: auto;max-height: 60em;box-shadow: rgba(0, 0, 0, 0.098) 0px 0px 2px;word-break: inherit;"><code style="max-width: 100%;border-width: initial;border-style: none;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: 1em;line-height: 1.75em;vertical-align: baseline;border-radius: 0px;background-image: none;background-attachment: initial;background-size: initial;background-origin: initial;background-clip: initial;background-position: initial;background-repeat: initial;"><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: rgb(0, 0, 0);background-color: rgb(255, 221, 221);">--- a/fs/binfmt_elf_fdpic.c&nbsp;</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: rgb(0, 0, 0);background-color: rgb(221, 255, 221);">+++ b/fs/binfmt_elf_fdpic.c&nbsp;</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: rgb(170, 170, 170);">@@ -337,6 +337,7 @@ static int load_elf_fdpic_binary(struct linux_binprm *bprm)&nbsp;</span> &nbsp; &nbsp; &nbsp; &nbsp;retval = -ENOEXEC;<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp;if (stack_size == 0)<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stack_size = 131072UL; /* same as exec.c's default commit */<br style="max-width: 100%;"  /><br style="max-width: 100%;"  /><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: rgb(0, 0, 0);background-color: rgb(221, 255, 221);">+ stack_size = 8192;&nbsp;</span><br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp;if (is_constdisp(&amp;interp_params.hdr))<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;interp_params.flags |= ELF_FDPIC_FLAG_CONSTDISP;<br style="max-width: 100%;"  /></code></pre><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 这个是相当又快又脏的做法；在 ELF 二进制头文件中合理地修改栈大小才是比较恰当的做法。这页需要比较细致的验证，比如说在有 MMU 的系统上设置一个固定大小的栈，任意的栈溢出都能被捕捉到。但是，这反正也不是我们第一次做这种事情了。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">在重启之前，我们看看更多的信息：</p><pre class="" style="padding: 1.5em;max-width: 100%;font-size: 1em;font-style: inherit;font-variant: inherit;font-weight: inherit;letter-spacing: 0.544px;widows: 1;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);font-stretch: inherit;line-height: 23px;vertical-align: baseline;overflow: auto;max-height: 60em;box-shadow: rgba(0, 0, 0, 0.098) 0px 0px 2px;word-break: inherit;"><code style="max-width: 100%;border-width: initial;border-style: none;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: 1em;line-height: 1.75em;vertical-align: baseline;border-radius: 0px;background-image: none;background-attachment: initial;background-size: initial;background-origin: initial;background-clip: initial;background-position: initial;background-repeat: initial;"># ps<br style="max-width: 100%;"  /> &nbsp;PID USER &nbsp; &nbsp; &nbsp; VSZ STAT COMMAND<br style="max-width: 100%;"  /> &nbsp; &nbsp;1 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;300 S &nbsp; &nbsp;{busybox} sh<br style="max-width: 100%;"  /> &nbsp; &nbsp;2 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 SW &nbsp; [kthreadd]<br style="max-width: 100%;"  /> &nbsp; &nbsp;3 0<br style="max-width: 100%;"  />ps invoked oom-killer: gfp_mask=0x14000c0(GFP_KERNEL),<br style="max-width: 100%;"  />nodemask=(null), order=0, oom_score_adj=0<br style="max-width: 100%;"  />[...]<br style="max-width: 100%;"  />Out of memory: Kill process 19 (ps) score 5 or sacrifice child<br style="max-width: 100%;"  /></code></pre><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 内存不足导致的杀进程行为似乎必会发生。好在内存不足时buddy分配器中会提供一些信息：</p><pre class="" style="padding: 1.5em;max-width: 100%;font-size: 1em;font-style: inherit;font-variant: inherit;font-weight: inherit;letter-spacing: 0.544px;widows: 1;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);font-stretch: inherit;line-height: 23px;vertical-align: baseline;overflow: auto;max-height: 60em;box-shadow: rgba(0, 0, 0, 0.098) 0px 0px 2px;word-break: inherit;"><code style="max-width: 100%;border-width: initial;border-style: none;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: 1em;line-height: 1.75em;vertical-align: baseline;border-radius: 0px;background-image: none;background-attachment: initial;background-size: initial;background-origin: initial;background-clip: initial;background-position: initial;background-repeat: initial;">Normal: 2*4kB (U) 3*8kB (U) 2*16kB (U) 2*32kB (UM)<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp;0*64kB 0*128kB 0*256kB = 128kB<br style="max-width: 100%;"  /></code></pre><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; ps 进程尝试使用0阶大小（单个 4KB 页）的内存分配，尽管有 128KB 空闲，这个操作仍然失败了。为什么？原来是因为页分配器在低于一定水位后会不执行正常的内存分配逻辑，这个水位由 zone_watermark_ok() 来判断返回。这样可以避免死锁，因为无法分配内存后，需要去杀进程，这个杀进程操作又需要内存。尽管这个水位很小，但是在我们的小型环境中，这仍然是一个我们无法接受的数值，所以我们稍微降低这个水位</p><pre class="" style="padding: 1.5em;max-width: 100%;font-size: 1em;font-style: inherit;font-variant: inherit;font-weight: inherit;letter-spacing: 0.544px;widows: 1;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);font-stretch: inherit;line-height: 23px;vertical-align: baseline;overflow: auto;max-height: 60em;box-shadow: rgba(0, 0, 0, 0.098) 0px 0px 2px;word-break: inherit;"><code style="max-width: 100%;border-width: initial;border-style: none;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: 1em;line-height: 1.75em;vertical-align: baseline;border-radius: 0px;background-image: none;background-attachment: initial;background-size: initial;background-origin: initial;background-clip: initial;background-position: initial;background-repeat: initial;"><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: rgb(0, 0, 0);background-color: rgb(255, 221, 221);">--- a/mm/page_alloc.c&nbsp;</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: rgb(0, 0, 0);background-color: rgb(221, 255, 221);">+++ b/mm/page_alloc.c&nbsp;</span><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: rgb(170, 170, 170);">@@ -7035,6 +7035,10 @@ static void __setup_per_zone_wmarks(void)&nbsp;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;zone-&gt;watermark[WMARK_LOW] &nbsp;= min_wmark_pages(zone) + tmp;<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;zone-&gt;watermark[WMARK_HIGH] = min_wmark_pages(zone) + tmp * 2;<br style="max-width: 100%;"  /><br style="max-width: 100%;"  /><span class="" style="max-width: 100%;border-width: 0px;border-style: initial;border-color: initial;font: inherit;vertical-align: baseline;color: rgb(0, 0, 0);background-color: rgb(221, 255, 221);">+ zone-&gt;watermark[WMARK_MIN] = 0; + zone-&gt;watermark[WMARK_LOW] = 0; + zone-&gt;watermark[WMARK_HIGH] = 0; +&nbsp;</span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp;}<br style="max-width: 100%;"  /></code></pre><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">最终，我们能够用 “mem=768k” 来重启内核</p><pre class="" style="padding: 1.5em;max-width: 100%;font-size: 1em;font-style: inherit;font-variant: inherit;font-weight: inherit;letter-spacing: 0.544px;widows: 1;border-width: 1px;border-style: solid;border-color: rgb(204, 204, 204);font-stretch: inherit;line-height: 23px;vertical-align: baseline;overflow: auto;max-height: 60em;box-shadow: rgba(0, 0, 0, 0.098) 0px 0px 2px;word-break: inherit;"><code style="max-width: 100%;border-width: initial;border-style: none;border-color: initial;font-style: inherit;font-variant: inherit;font-weight: inherit;font-stretch: inherit;font-size: 1em;line-height: 1.75em;vertical-align: baseline;border-radius: 0px;background-image: none;background-attachment: initial;background-size: initial;background-origin: initial;background-clip: initial;background-position: initial;background-repeat: initial;">Linux version 4.15.0-00008-gf90e37b6fb-dirty (nico@xanadu.home) (gcc version 6.3.1 20170404<br style="max-width: 100%;"  /> 		 &nbsp;(Linaro GCC 6.3-2017.05)) #634 Fri Feb 23 14:03:34 EST 2018<br style="max-width: 100%;"  /> &nbsp; &nbsp;CPU: ARMv7-M [410fc241] revision 1 (ARMv7M), cr=00000000<br style="max-width: 100%;"  /> &nbsp; &nbsp;CPU: unknown data cache, unknown instruction cache<br style="max-width: 100%;"  /> &nbsp; &nbsp;OF: fdt: Machine model: STMicroelectronics STM32F469i-DISCO board<br style="max-width: 100%;"  /> &nbsp; &nbsp;On node 0 totalpages: 192<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp;Normal zone: 2 pages used for memmap<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp;Normal zone: 0 pages reserved<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp;Normal zone: 192 pages, LIFO batch:0<br style="max-width: 100%;"  /> &nbsp; &nbsp;random: fast init done<br style="max-width: 100%;"  /> &nbsp; &nbsp;[...]<br style="max-width: 100%;"  /><br style="max-width: 100%;"  /> &nbsp; &nbsp;BusyBox v1.27.1 (2017-09-16 02:45:01 EDT) hush - the humble shell<br style="max-width: 100%;"  /><br style="max-width: 100%;"  /> &nbsp; &nbsp;# free<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total &nbsp; &nbsp; &nbsp; used &nbsp; &nbsp; &nbsp; free &nbsp; &nbsp; shared &nbsp; &nbsp;buffers &nbsp; &nbsp; cached<br style="max-width: 100%;"  /> &nbsp; &nbsp;Mem: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 644 &nbsp; &nbsp; &nbsp; &nbsp;532 &nbsp; &nbsp; &nbsp; &nbsp;112 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 &nbsp; &nbsp; &nbsp; &nbsp; 24<br style="max-width: 100%;"  /> &nbsp; &nbsp;-/+ buffers/cache: &nbsp; &nbsp; &nbsp; &nbsp;508 &nbsp; &nbsp; &nbsp; &nbsp;136<br style="max-width: 100%;"  /><br style="max-width: 100%;"  /> &nbsp; &nbsp;# ps<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp;PID USER &nbsp; &nbsp; &nbsp; VSZ STAT COMMAND<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp;1 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;276 S &nbsp; &nbsp;{busybox} sh<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp;2 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 SW &nbsp; [kthreadd]<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp;3 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 IW &nbsp; [kworker/0:0]<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp;4 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 IW&lt; &nbsp;[kworker/0:0H]<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp;5 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 IW &nbsp; [kworker/u2:0]<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp;6 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 IW&lt; &nbsp;[mm_percpu_wq]<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp;7 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 SW &nbsp; [ksoftirqd/0]<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp;8 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 IW&lt; &nbsp;[writeback]<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; &nbsp;9 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 IW&lt; &nbsp;[watchdogd]<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; 10 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 IW &nbsp; [kworker/0:1]<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; 11 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 SW &nbsp; [kswapd0]<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; 12 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 SW &nbsp; [irq/31-40002800]<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; 13 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 SW &nbsp; [irq/32-40004800]<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; 16 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 IW &nbsp; [kworker/u2:1]<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; 21 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 IW &nbsp; [kworker/u2:2]<br style="max-width: 100%;"  /> &nbsp; &nbsp; &nbsp; 23 0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;260 R &nbsp; &nbsp;ps<br style="max-width: 100%;"  /><br style="max-width: 100%;"  /> &nbsp; &nbsp;# grep -v " 0 kB" /proc/meminfo<br style="max-width: 100%;"  /> &nbsp; &nbsp;MemTotal: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;644 kB<br style="max-width: 100%;"  /> &nbsp; &nbsp;MemFree: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;92 kB<br style="max-width: 100%;"  /> &nbsp; &nbsp;MemAvailable: &nbsp; &nbsp; &nbsp; &nbsp; 92 kB<br style="max-width: 100%;"  /> &nbsp; &nbsp;Cached: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 24 kB<br style="max-width: 100%;"  /> &nbsp; &nbsp;MmapCopy: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 92 kB<br style="max-width: 100%;"  /> &nbsp; &nbsp;KernelStack: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;64 kB<br style="max-width: 100%;"  /> &nbsp; &nbsp;CommitLimit: &nbsp; &nbsp; &nbsp; &nbsp; 320 kB<br style="max-width: 100%;"  /></code></pre><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 看吧！ 尽管没有达到我们 512KB 内存的目标，但是 768KB 已经比较接近了。有些微控制器已经有超过这个数量的片上静态内存了。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 不复杂的提升工作仍然存在。我们可以看到在16个进程中，有14个是内核进程，各自使用了 4KB 的栈。其中一些进程肯定可以去除。然后在进行一轮内存页的分析，能透露出更多可以被优化的部分，等等。而且，专用的程序并不需要产生新的子进程，它也只需要更少的内存去运行。毕竟，一些流行的控制器用这里我们剩余的空闲内存就来实现互联网的连接功能。</p></section></section></section><section data-id="2280" class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"><section style="border-width: 0px;border-style: initial;border-color: initial;box-sizing: border-box;width: 100%;clear: both;overflow: hidden;"><section style="box-sizing: border-box;width: 30%;float: left;padding-right: 0.1em;text-align: right;color: inherit;"><section style="width: 100px;height: 100px;border-width: 10px;border-style: solid;border-color: rgb(33, 33, 34);color: rgb(254, 254, 254);margin-top: 10px;margin-bottom: 10px;display: inline-block;border-radius: 100%;box-sizing: border-box;"></section></section><section style="margin-top: 15px;margin-bottom: 10px;box-sizing: border-box;width: 70%;float: left;padding-top: 10px;padding-bottom: 10px;margin-left: -50px;color: inherit;"><section style="color: inherit;background-color: #fefefe;"><span style="font-size:24px;"><strong class="135brush" data-brushtype="text">&nbsp;总结</strong></span></section></section></section></section><section data-id="2484" class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"><section style="margin:10px 10%;"><section class="135brush" data-style="color: inherit; text-align: justify; line-height: 2em;font-size:14px" style="line-height: 25px;color: inherit;"><p style="color: inherit;line-height: 2em;"><span style="font-family: inherit;font-size: inherit;font-style: inherit;font-variant-ligatures: inherit;font-variant-caps: inherit;font-weight: inherit;letter-spacing: 0.544px;widows: 1;caret-color: red;">&nbsp; &nbsp; 这里至少有一个重要的点可以从这个项目中学习到。精简内核内存使用量比精简内核代码要容易的多。因为，代码已经被高度优化过，而且代码对系统性能有直接的影响，即使在大型系统上。但是内存使用量却是不一样的。RAM 在大型系统上变得相对偏移，在操作上，即使浪费一些也没有关系。因此，在优化内存使用量的工作中，有很多唾手可得成果。</span></p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">&nbsp; &nbsp; 除了这些小的调整和快速的修改，其他重要的部分如（XIP 内核，XIP 用户态，甚至一些设备内存使用量精简）都已经在主干版本中。但是为了让 Linux 跑在微小的设备上仍需要进一步工作。这个工作的进度，永远依赖于人们对使用上的期待和构建一个社区去推动开发的愿景。</p><p style="margin-bottom: 0.75em;max-width: 100%;min-height: 1em;font: inherit;letter-spacing: 0.544px;widows: 1;border-width: 0px;border-style: initial;border-color: initial;vertical-align: baseline;">[感谢 Linaro 组织允许我投入时间在这个项目和写作这个文章上]</p></section></section></section><section data-role="paragraph" class="_135editor" style="border-width: 0px;border-style: none;border-color: initial;box-sizing: border-box;"><p><br  /></p></section></section></section><p><span style="color: rgb(255, 104, 39);"><em>本文转自：公众号“内核月谈”</em></span></p>
                </div>
                

                
  <div class="ct_mpda_wrp" id="js_sponsor_ad_area" style="display: none;"></div>


                
                <div class="read-more__area" id="js_more_read_area" style="display:none;">
                    
                </div>

                
                                <div class="reward_area tc reward_area_primary" id="js_preview_reward_author" style="display:none;">
                    <div class="reward-avatar" style="display: none;" id="js_preview_reward_author_avatar">
                        <img src="" alt="" id="js_preview_reward_author_head">
                    </div>
                    
                                        <div class="reward-author" id="js_preview_reward_author_name">​石祤</div>
                                        <p class="reward_tips" id="js_preview_reward_author_wording" style="display:none;"></p>
                    <p class="reward_button_wrp">
                    
                      <span class="reward_pop_panel">
                        <img src="https://res.wx.qq.com/mpres/zh_CN/htmledition/pages/home/index/pic_mp_app4290ba.png" alt="">
                        <strong>扫一扫下载订阅号助手，用手机发文章</strong>
                      </span>
                        <a class="reward_button" id='js_preview_reward_author_link' href="##"><span id="js_preview_reward_link_text">赞赏</span></a>
                    </p>
                </div>

                <div class="reward_qrcode_area reward_area tc" id="js_preview_reward_qrcode" style="display:none;">
                    <p class="tips_global">长按二维码向我转账</p>
                    <p id="js_preview_reward_ios_wording" class="reward_tips" style="display:none;"></p>
                    <span class="reward_qrcode_img_wrp"><img class="reward_qrcode_img" src="res.wx.qq.com/mmbizwap/zh_CN/htmledition/images/pic/appmsg/pic_reward_qrcode.2x42f400.png"></span>
                    <p class="tips_global">受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。</p>
                </div>
                            </div>
		<div class="comment">
			<h3 style="margin:26px 0;font-weight:100;padding-bottom:4px;border-bottom:1px solid #ccc;">精选留言</h3>
		    暂无...
		</div>
	</div>
	<div class='dy_all'>
		<a href='https://mp.weixin.qq.com/s/PCSrZ0UAWG9rwYyquwJCOg#rd' target='_blank'>
			阅读全文
		</a>
	</div>
</body>