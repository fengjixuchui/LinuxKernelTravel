<!DOCTYPE html>
<head>
	<meta http-equiv='Content-Type' content='text/html;charset=utf-8'>
	<meta name='viewport' content='width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no'>
	<title>
		Linux时间子系统之：timekeeping
	</title>
	<script src='https://cdn.bootcss.com/jquery/1.10.2/jquery.min.js'>
	</script>
	<style>
		a {color: #607fa6;text-decoration:none;word-wrap:break-word;word-break:break-all;}.rich_media_title{padding-bottom:10px;margin-bottom:14px;border-bottom:1px solid #e7e7eb;font-weight:400;} .rich_media_meta_list{font-size:14px;margin-bottom: 22px;}
		.rich_media_meta{display:inline-block;vertical-align:middle;margin-right:8px;margin-bottom:10px;font-size:14px;}.rich_media_meta_text{color:#8c8c8c;color:rgba(0, 0, 0, 0.3)}.rich_media_meta_list
		em {font-style: normal;}@media screen and (max-width:768px){.rich_media{position:
		relative;padding: 20px 15px 15px;background-color: #fff;}}.rich_media_content{text-align:justify;} .rich_media_content * {max-width:100%!important;box-sizing: border-box!important;-webkit-box-sizing:
		border-box!important;word-wrap: break-word!important;}.rich_media_content
		blockquote {margin: 0;padding-left: 10px;border-left: 3px solid #dbdbdb;}.rich_media_content
		.list-paddingleft-2 {padding-left: 2.2em;}a.rich_media_meta_nickname{display: none;}@media screen and (min-width:1025px){.rich_media{position:relative;}a.rich_media_meta_nickname{display:inline-block!important;}span.rich_media_meta_nickname
		{display: inline-block!important;}.rich_media {width:677px;margin-left:auto;margin-right:auto;}}a.fwjm{font-size: 12px;color: #ececec;}.tenvideo_player {position: relative;width:
		100 %;height: 100 %;margin: auto;background: #000;}* {margin:0px;padding:0px;} body{line-height: 1.6;letter-spacing: .034em;}
		.dy_all {text-align: center;margin: 30px 0;} .dy_all a {display: inline-block;height:
		38px;line-height: 38px;padding: 0 18px;background-color: #009688;color:
		#fff;white-space: nowrap;font-size: 14px;border: none;border-radius: 2px;cursor:
		pointer;text-align: center;outline: 0;-webkit-appearance: none;transition:
		all .3s;-webkit-transition: all .3s;box-sizing: border-box;} img{max-width: 677px!important;}

		.crawler-info{padding: 8px 0;} .article-link>img{margin-left: 20px;width: 16px;}
		.comment-item::before,.comment-item::after{content:'';display:block;height:0;visibility:hidden;clear:both;*zoom:1;} .comment-item{margin-bottom:30px;}
		.avatar{width:12%; padding-right:10px;float:left;box-sizing:border-box;} .avatar img{width:100%;}
		.comment-body{float:left;width:88%;} .comment-body .comment-info{color:#b3b3b3;margin-bottom:4px;margin-top: -5px;} .comment-body .comment-info>span:last-child{float:right;} 
		.comment-author{border-left:4px solid green;padding-left:6px;margin:8px 0;}

		@media screen and (max-width: 420px) {.article-link>img {margin-left: 0px;}}
		@media screen and (min-width: 480px) {.avatar {width: 9%;}.comment-body {width: 91%;}}
	</style>
</head>
<body>
	<div id='js_article' class='rich_media'>
		<div class="crawler-info">
			<a href='https://www.52pojie.cn' class='fwjm' target='_blank'>
				提供的爬取软件来源于：52pojie.cn@夜泉 免费下载使用
			</a>
			<a href='https://mp.weixin.qq.com/s?__biz=MzI3NzA5MzUxNA==&amp;mid=2664606385&amp;idx=1&amp;sn=0c34ab50665a69af8ecee897078e9d9d&amp;chksm=f04d8754c73a0e4235194b4cce65d01630eb307476682e58f163a9f2caa81f6803a6e71beb8a&amp;scene=27#wechat_redirect&cpage=6' target='_blank' class="article-link">
				<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAMAAABA3o1rAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjk4QUEzQzVDNkNGQjExRTk5NzNBQ0VBMjgzMjY1NjkwIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjk4QUEzQzVENkNGQjExRTk5NzNBQ0VBMjgzMjY1NjkwIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OThBQTNDNUE2Q0ZCMTFFOTk3M0FDRUEyODMyNjU2OTAiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OThBQTNDNUI2Q0ZCMTFFOTk3M0FDRUEyODMyNjU2OTAiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5TKSKsAAAAclBMVEUuLi77+/stLS1VVVXx8fFOTk7s7Ozt7e1qamp5eXlNTU2WlpZFRUU6Ojrq6urn5+d/f3/8/Pw9PT0/Pz+YmJg8PDyZmZlAQECfn5+QkJBBQUFra2vo6OhDQ0OSkpKenp5WVlY+Pj7r6+tpaWksLCz///9o6ILHAAAAJnRSTlP/////////////////////////////////////////////////AKd6gbwAAACNSURBVHjajJHpEoIwDISDVMotcnuCmLz/K9KCdlqO6v7p7Mw3yW4KxG85fnUkIVfZ5J0SsCtqcgRw0HzjQYY2AAOIdRuaK4ReAPJ5nmglL5qICahpU60C0uXguQ9TgIwGJoDnT9z/ABmxt60ot0N2CsDLfb9mvBxs9ql+n5o9bEDBgbif7/1F4g80CjAAqrVAnnsm5f8AAAAASUVORK5CYII=" />
			</a>
		</div>
		<div id="img-content">

                
                <h2 class="rich_media_title" id="activity-name">Linux时间子系统之：timekeeping</h2>
                <div id="meta_content" class="rich_media_meta_list">
                                                                                                            <span class="rich_media_meta rich_media_meta_text">
                                                        linuxer
                                                    </span>
                                                                
                                        <span class="rich_media_meta rich_media_meta_nickname" id="profileBt"><a href="javascript:void(0);">Linux内核之旅</a>
                      <div id="js_profile_qrcode" class="profile_container" style="display:none;">
                          <div class="profile_inner">
                              <strong class="profile_nickname">Linux内核之旅</strong>
                              <img class="profile_avatar" id="js_profile_qrcode_img" src="" alt="">

                              <p class="profile_meta">
                              <label class="profile_meta_label">微信号</label>
                              <span class="profile_meta_value">LinuxKernelTravel</span>
                              </p>

                              <p class="profile_meta">
                              <label class="profile_meta_label">功能介绍</label>
                              <span class="profile_meta_value">Linux内核之旅</span>
                              </p>
                              
                          </div>
                          <span class="profile_arrow_wrp" id="js_profile_arrow_wrp">
                              <i class="profile_arrow arrow_out"></i>
                              <i class="profile_arrow arrow_in"></i>
                          </span>
                      </div>
                    </span>


                    <em id="publish_time" class="rich_media_meta rich_media_meta_text">2019-04-15</em>





                </div>

                
                
                                
                
                
                
                                                
                                                                
                                
                
                <div class="rich_media_content " id="js_content">
                    

                    

                    
                    
                    <p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">一、前言</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">timekeeping模块是一个提供时间服务的基础模块。Linux内核提供各种time&nbsp;line，real&nbsp;time&nbsp;clock，monotonic&nbsp;clock、monotonic&nbsp;raw&nbsp;clock等，timekeeping模块就是负责跟踪、维护这些timeline的，并且向其他模块（timer相关模块、用户空间的时间服务等）提供服务，而timekeeping模块维护timeline的基础是基于clocksource模块和tick模块。通过tick模块的tick事件，可以周期性的更新time&nbsp;line，通过clocksource模块、可以获取tick之间更精准的时间信息。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">本文熟悉介绍timekeeping的一些基础概念，接着会介绍该模块初始化的过程，此后会从上至下介绍该模块提供的服务、该模块如何和tick模块交互以及如何和clocksource模块交互，最后介绍电源管理相关的内容。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">&nbsp;</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">二、timekeeper核心数据定义</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">1、struct timekeeper数据结构解析</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">旧的内核定义了很多零散的全局变量来管理linux&nbsp;kernel中的各种系统clock，现在，内核定义的struct&nbsp;timekeeper数据结构来管理各种系统时钟的跟踪以及控制，定义如下：</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">struct timekeeper {&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct clocksource&nbsp;&nbsp;&nbsp; *clock;－－－－－－－－－－－－－－－－－－－－－－－－（1）&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br  />&nbsp;&nbsp;&nbsp; u32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mult;－－－－－－－－－－－－－－－－－－－－－－－－－－－－－（2）&nbsp;<br  />&nbsp;&nbsp;&nbsp; u32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; shift;</p><p style="padding-bottom: 15px;line-height: 20px;"><br  />&nbsp;&nbsp;&nbsp; cycle_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cycle_interval; －－－－－－－－－－－－－－－－－－－－－－－（3）&nbsp;<br  />&nbsp;&nbsp;&nbsp; cycle_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cycle_last;&nbsp;<br  />&nbsp;&nbsp;&nbsp; u64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xtime_interval;&nbsp;<br  />&nbsp;&nbsp;&nbsp; s64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xtime_remainder;&nbsp;<br  />&nbsp;&nbsp;&nbsp; u32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raw_interval;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; s64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ntp_error;&nbsp;<br  />&nbsp;&nbsp;&nbsp; u32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ntp_error_shift;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; u64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xtime_sec;－－－－－－－－－－－－－－－－－－－－－－－－－－－（4）&nbsp;<br  />&nbsp;&nbsp;&nbsp; u64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xtime_nsec;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; struct timespec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wall_to_monotonic; －－－－－－－－－－－－－－－－－－－（5）&nbsp;<br  />&nbsp;&nbsp;&nbsp; ktime_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offs_real;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct timespec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; total_sleep_time; －－－－－－记录系统睡眠时间&nbsp;<br  />&nbsp;&nbsp;&nbsp; ktime_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offs_boot; －－－－－－－－－－－－记录系统boot time&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct timespec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raw_time; －－－－－－－－－－－－－－－－－－－－－－－（6）&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;<br  />&nbsp;&nbsp;&nbsp; s32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tai_offset; －－－－－－－－－－－－－－－－－－－－－－－－－－－（7）&nbsp;<br  />&nbsp;&nbsp;&nbsp; ktime_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offs_tai;</p><p style="padding-bottom: 15px;line-height: 20px;">};</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（1）timekeeper当前使用的clocksource。这个clock应该系统中最优的那个，如果有好过当前clocksource注册入系统，那么clocksource模块会通知timekeeping模块来切换clocksource。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（2）clock&nbsp;source的cycle值和纳秒转换的facotr，概念和clocksource的mult和shift一致。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（3）NTP相关的成员，这里不详述了，实在是对NTP没有兴趣。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（4）CLOCK_REALTIME类型的系统时钟（其实就是墙上时钟）。我们都知道，时间就像是一条直线（line），不知道起点，也不知道终点，因此我们称之time&nbsp;line。time&nbsp;line有很多种，和如何定义0值的时间以及用什么样的刻度来度量时间相关。人类熟悉的墙上时间和linux&nbsp;kernel中定义的CLOCK_REALTIME都是用来描述time&nbsp;line的，只不过时间原点和如何度量time&nbsp;line上两点距离的刻度不一样。对于人类的时间，0值是耶稣诞生的时间点；对于CLOCK_REALTIME，0值是linux&nbsp;epoch，即1970年1月1日...。对于墙上时间，在度量的时候虽然也是基于秒的，但是人类做了grouping，因此使用了年月日时分秒的概念。这里的秒数是相对与当前分钟值内的秒数。对于linux世界中的CLOCK_REALTIME&nbsp;time，直接使用秒以及纳秒在当前秒内的偏移来表示。<br  />因此，这里xtime_sec用秒这个的刻度单位来度量CLOCK_REALTIME&nbsp;time&nbsp;line上，时间原点到当前点的距离值。当然xtime_sec是一个对current&nbsp;time&nbsp;point的取整值，为了更好的精度，还需要一个纳秒表示的offset，也就是xtime_nsec。<br  />不过为了内核内部计算精度（内核对时间的计算是基于cycle的），并不是保存了时间的纳秒偏移值，而是保存了一个shift之后的值，因此，用户看来，当前时间点的值应该是距离时间原点xtime_sec + (xtime_nsec &lt;&lt; shift)距离的那个时间点值</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（5）CLOCK_MONOTONIC类型的系统时钟。这种系统时钟并没有象墙上时钟一样定义一个相对于linux&nbsp;epoch的值，这个成员定义了monotonic&nbsp;clock到real&nbsp;time&nbsp;clock的偏移，也就是说，这里的wall_to_monotonic和offs_real需要加上real&nbsp;time&nbsp;clock的时间值才能得到monotonic&nbsp;clock的时间值。当然，从这里成员的名字就看出来了。wall_to_monotonic和offs_real的意思是一样的，不过时间的格式不一样，用在不同的场合，以便获取性能的提升。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（6）CLOCK_MONOTONIC_RAW类型的系统时钟</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（7）CLOCK_TAI类型的系统时钟。TAI（international&nbsp;atomic&nbsp;time）是原子钟，在时间的基本概念文档中，我们说过，UTC就是base&nbsp;TAI的，也就是说用铯133的振荡频率来定义秒的那个时钟，当然UTC还有考虑leap&nbsp;second以便方便广大人民群众。CLOCK_TAI类型的系统时钟就是完完全全使用铯133的振荡频率来定义秒的那个时钟，不向人类妥协。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">2、全局变量</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">static struct timekeeper timekeeper;&nbsp;<br  />static DEFINE_RAW_SPINLOCK(timekeeper_lock);&nbsp;<br  />static seqcount_t timekeeper_seq;</p><p style="padding-bottom: 15px;line-height: 20px;">static struct timekeeper shadow_timekeeper;</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">timekeeper维护了系统的所有的clock。一个全局变量（共享资源）没有锁保护怎么行，timekeeper_lock和timekeeper_seq都是用来保护timekeeper的，用在不同的场合。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">shadow_timekeeper主要用在更新系统时间的过程中。在update_wall_time中，首先将时间调整值设定到shadow_timekeeper中，然后一次性的copy到真正的那个timekeeper中。这样的设计主要是可以减少持有timekeeper_seq锁的时间（在更新系统时间的过程中），不过需要注意的是：在其他的过程中（非update_wall_time），需要sync&nbsp;shadow&nbsp;timekeeper。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">&nbsp;</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">三、timekeeping初始化</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">timekeeping初始化的代码位于timekeeping_init函数中，在系统初始化的时候（start_kernel）会调用该函数进行timekeeping的初始化。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">1、从persistent clock获取当前的时间值</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">timekeeping模块中支持若干种system&nbsp;clock，这些system&nbsp;clock的数据保存在ram中，一旦断电，数据就丢失了。因此，在系加电启动后，会从persistent&nbsp;clock中中取出当前时间值（例如RTC，RTC有battery供电，因此系统断电也可以保存数据），根据情况初始化各种system&nbsp;clock。具体代码如下：</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; read_persistent_clock(&amp;now);－－－－－－－－－－－－－－－－－－－－－－（1）&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!timespec_valid_strict(&amp;now))&nbsp;{－－－－－－－－－－－－－－－－－－－－－（2）&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; now.tv_sec = 0;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; now.tv_nsec = 0;&nbsp;<br  />&nbsp;&nbsp;&nbsp; } else if (now.tv_sec || now.tv_nsec)&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; persistent_clock_exist = true; －－－－－－－－－－－－－－－－－－－－－（3）</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; read_boot_clock(&amp;boot);－－－－－－－－－－－概念同上&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!timespec_valid_strict(&amp;boot))&nbsp;{&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boot.tv_sec = 0;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boot.tv_nsec = 0;&nbsp;<br  />&nbsp;&nbsp;&nbsp; }</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（1）read_persistent_clock是一个和architecture相关的函数，具体如何支持可以看具体的architecture相关的代码实现。对于ARM，其实现在linux/arch/arm/kernel/time.c文件中。该函数的功能就是从系统中的HW&nbsp;clock（例如RTC）中获取时间信息。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（2）timespec_valid_strict用来校验一个timespec是否是有效。如何判断从RTC获取的值是有效的呢？要满足timespec中的秒数值要大于等于0，小于KTIME_SEC_MAX，纳秒值要小于NSEC_PER_SEC（10^9）。KTIME_SEC_MAX这个宏定义了ktime_t这种类型的数据可以表示的最大的秒数值，从RTC中读出的秒数值当然不能大于它，KTIME_SEC_MAX定义如下：</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">#define KTIME_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((s64)~((u64)1 &lt;&lt; 63))&nbsp;<br  />#if (BITS_PER_LONG == 64)&nbsp;<br  /># define KTIME_SEC_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (KTIME_MAX / NSEC_PER_SEC)&nbsp;<br  />#else&nbsp;<br  /># define KTIME_SEC_MAX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LONG_MAX&nbsp;<br  />#endif</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">ktime_t这种数据类型占据了64&nbsp;bit的size，对于64&nbsp;bit的CPU和32&nbsp;bit&nbsp;CPU上是不一样的，64&nbsp;bit的CPU上定义为一个signed&nbsp;long&nbsp;long，该值直接表示了纳秒值。对于32bit&nbsp;CPU而言，64&nbsp;bit的数据分成两个signed&nbsp;int类型，分别表示秒数和纳秒数。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（3）设定persistent_clock_exist&nbsp;flag，说明系统中存在RTC的硬件模块，timekeeping模块会和RTC模块进行交互。例如：在suspend的时候，如果该flag是true的话，RTC&nbsp;driver不能sleep，因为timekeeping模块还需要在resume的时候通过RTC的值恢复其时间值呢。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">2、为timekeeping模块设置default的clock source</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">clock = clocksource_default_clock();－－－－－－－－－－－－－－－－－－－－（1）&nbsp;<br  />if (clock-&gt;enable)&nbsp;<br  />&nbsp;&nbsp;&nbsp; clock-&gt;enable(clock);－－－－－enalbe default clocksource&nbsp;<br  />tk_setup_internals(tk, clock);－－－－－－－－－－－－－－－－－－－－－－－－（2）</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（1）在timekeeping初始化的时候，很难选择一个最好的clock&nbsp;source，因为很有可能最好的那个还没有初始化呢。因此，这里的策略就是采用一个在timekeeping初始化时一定是ready的clock&nbsp;source，也就是基于jiffies&nbsp;的那个clocksource。clocksource_default_clock定义在kernel/time/jiffies.c，是一个weak&nbsp;symble，如果你愿意也可以重新定义clocksource_default_clock这个函数。不过，要保证在timekeeping初始化的时候是ready的。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（2）建立default&nbsp;clocksource和timekeeping伙伴关系。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">3、初始化real time clock、monotonic clock和monotonic raw clock</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">tk_set_xtime(tk, &amp;now);－－－－－－－－－－－－－－－－－－－－－－－－－－（1）&nbsp;<br  />tk-&gt;raw_time.tv_sec = 0;－－－－－－－－－－－－－－－－－－－－－－－－－－（2）&nbsp;<br  />tk-&gt;raw_time.tv_nsec = 0;&nbsp;<br  />if (boot.tv_sec == 0 &amp;&amp; boot.tv_nsec == 0)&nbsp;<br  />&nbsp;&nbsp;&nbsp; boot = tk_xtime(tk); －－－如果没有获取到有效的booting time，那么就选择当前的real time clock</p><p style="padding-bottom: 15px;line-height: 20px;">set_normalized_timespec(&amp;tmp, -boot.tv_sec, -boot.tv_nsec);－－－－－－－－－－（3）&nbsp;<br  />tk_set_wall_to_mono(tk, tmp);</p><p style="padding-bottom: 15px;line-height: 20px;">tmp.tv_sec = 0;&nbsp;<br  />tmp.tv_nsec = 0;&nbsp;<br  />tk_set_sleep_time(tk, tmp);－－－－－－初始化sleep time为0</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（1）根据从RTC中获取的时间值来初始化timekeeping中的real&nbsp;time&nbsp;clock，如果没有获取到正确的RTC时间值，那么缺省的real&nbsp;time（wall&nbsp;time）就是linux&nbsp;epoch。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（2）monotonic&nbsp;raw&nbsp;clock被设定为从0开始。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（3）启动时将monotonic&nbsp;clock设定为负的real&nbsp;time&nbsp;clock，timekeeper并没有直接保存monotonic&nbsp;clock，而是保存了一个wall_to_monotonic的值，这个值类似offset，real&nbsp;time&nbsp;clock加上这个offset就可以得到monotonic&nbsp;clock。因此，初始化的时间点上，monotonic&nbsp;clock实际上等于0（如果没有获取到有效的booting&nbsp;time）。当系统运行之后，real&nbsp;time&nbsp;clock+&nbsp;wall_to_monotonic是系统的uptime，而real&nbsp;time&nbsp;clock+&nbsp;wall_to_monotonic&nbsp;+&nbsp;sleep&nbsp;time也就是系统的boot&nbsp;time。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">&nbsp;</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">四、获取和设定当前系统时钟的时间值</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">1、获取monotonic&nbsp;clock的时间值：ktime_get和ktime_get_ts</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">ktime_t ktime_get(void)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct timekeeper *tk = &amp;timekeeper;&nbsp;<br  />&nbsp;&nbsp;&nbsp; unsigned int seq;&nbsp;<br  />&nbsp;&nbsp;&nbsp; s64 secs, nsecs;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; do {&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seq = read_seqcount_begin(&amp;timekeeper_seq);&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; secs = tk-&gt;xtime_sec + tk-&gt;wall_to_monotonic.tv_sec;－－－－－获取monotonic clock的秒值&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nsecs = timekeeping_get_ns(tk) + tk-&gt;wall_to_monotonic.tv_nsec; －－－获取纳秒值</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; } while (read_seqcount_retry(&amp;timekeeper_seq, seq));&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br  />&nbsp;&nbsp;&nbsp; return ktime_add_ns(ktime_set(secs, 0), nsecs);－－－－返回一个ktime类型的时间值&nbsp;<br  />}</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">一般而言，timekeeping模块是在tick到来的时候更新各种系统时钟的时间值，ktime_get调用很有可能发生在两次tick之间，这时候，仅仅依靠当前系统时钟的值精度就不甚理想了，毕竟那个时间值是per&nbsp;tick更新的。因此，为了获得高精度，ns值的获取是通过timekeeping_get_ns完成的，该函数获取了real&nbsp;time&nbsp;clock的当前时刻的纳秒值，而这是通过上一次的tick时候的real&nbsp;time&nbsp;clock的时间值（xtime_nsec）加上当前时刻到上一次tick之间的delta时间值计算得到的。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">ktime_get_ts的概念和ktime_get是一样的，只不过返回的时间值格式不一样而已。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">2、获取real&nbsp;time&nbsp;clock的时间值：ktime_get_real和ktime_get_real_ts</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">这两个函数的具体逻辑动作和获取monotonic&nbsp;clock的时间值函数是完全一样的，大家可以自己看代码分析。这里稍微提一下另外一个函数：current_kernel_time，代码如下：</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">static inline struct timespec tk_xtime(struct timekeeper *tk)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct timespec ts;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; ts.tv_sec = tk-&gt;xtime_sec;&nbsp;<br  />&nbsp;&nbsp;&nbsp; ts.tv_nsec = (long)(tk-&gt;xtime_nsec &gt;&gt; tk-&gt;shift);&nbsp;<br  />&nbsp;&nbsp;&nbsp; return ts;&nbsp;<br  />}</p><p style="padding-bottom: 15px;line-height: 20px;">struct timespec current_kernel_time(void)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct timekeeper *tk = &amp;timekeeper;&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct timespec now;&nbsp;<br  />&nbsp;&nbsp;&nbsp; unsigned long seq;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; do {&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seq = read_seqcount_begin(&amp;timekeeper_seq);</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; now = tk_xtime(tk);&nbsp;<br  />&nbsp;&nbsp;&nbsp; } while (read_seqcount_retry(&amp;timekeeper_seq, seq));</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; return now;&nbsp;<br  />}</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">上面的代码并没有调用clocksource的read函数获取tick之间的delta时间值，因此current_kernel_time是一个粗略版本的real&nbsp;time&nbsp;clock，精度低于ktime_get_real，不过性能要好些。类似的，monotonic&nbsp;clock也有一个get_monotonic_coarse函数，概念类似current_kernel_time。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">3、获取boot&nbsp;clock的时间值：ktime_get_boottime和get_monotonic_boottime</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">ktime_t ktime_get_boottime(void)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct timespec ts;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; get_monotonic_boottime(&amp;ts);&nbsp;<br  />&nbsp;&nbsp;&nbsp; return timespec_to_ktime(ts);&nbsp;<br  />}</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">boot&nbsp;clock这个系统时钟和monotonic&nbsp;clock有什么不同？monotonic&nbsp;clock是从一个固定点开始作为epoch，对于linux，就是启动的时间点，因此，monotonic&nbsp;clock是一个从0开始增加的clock，并且不接受用户的setting，看起来好象适合boot&nbsp;clock是一致的，不过它们之间唯一的差别是对系统进入suspend的处理，对于monotonic&nbsp;clock，它是不记录系统睡眠时间的，因此monotonic&nbsp;clock得到的是一个system&nbsp;uptime。而boot&nbsp;clock计算睡眠时间，直到系统reboot。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">ktime_get_boottime返回ktime的时间值，get_monotonic_boottime函数返回timespec格式的时间值。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">4、获取TAI&nbsp;clock的时间值：ktime_get_clocktai和timekeeping_clocktai</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">原子钟和real&nbsp;time&nbsp;clock（UTC）是类似的，只是有一个偏移而已，记录在tai_offset中。代码非常简单，大家自己阅读即可。ktime_get_clocktai返回ktime的时间值，而timekeeping_clocktai返回timespec格式的时间值。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">5、设定wall time clock</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">int do_settimeofday(const struct timespec *tv)&nbsp;<br  />{</p><p style="padding-bottom: 15px;line-height: 20px;">……</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; timekeeping_forward_now(tk);－－－更新timekeeper至当前时间</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; xt = tk_xtime(tk);&nbsp;<br  />&nbsp;&nbsp;&nbsp; ts_delta.tv_sec = tv-&gt;tv_sec - xt.tv_sec;&nbsp;<br  />&nbsp;&nbsp;&nbsp; ts_delta.tv_nsec = tv-&gt;tv_nsec - xt.tv_nsec; －－－－计算delta</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; tk_set_wall_to_mono(tk, timespec_sub(tk-&gt;wall_to_monotonic, ts_delta)); －－不调mono clock</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; tk_set_xtime(tk, tv); －－－调整wall time clock</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; timekeeping_update(tk, TK_CLEAR_NTP | TK_MIRROR | TK_CLOCK_WAS_SET); －－更tk</p><p style="padding-bottom: 15px;line-height: 20px;">……&nbsp;<br  />}</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">&nbsp;</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">五、和clocksource模块的交互</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">除了直接调用clocksource的read函数之外，timekeeping和clocksource主要的交互就是change&nbsp;clocksource的操作了。当系统中有更高精度的clocksource的时候，会调用timekeeping_notify函数通知timekeeping模块进行clock&nbsp;source的切换，代码如下：</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">int timekeeping_notify(struct clocksource *clock)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct timekeeper *tk = &amp;timekeeper;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; if (tk-&gt;clock == clock)－－－－新的clocksource和旧的一样，不需要切换&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;&nbsp;<br  />&nbsp;&nbsp;&nbsp; stop_machine(change_clocksource, clock, NULL);&nbsp;<br  />&nbsp;&nbsp;&nbsp; tick_clock_notify();－－－－通知tick模块，具体在其他文档中描述&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;tk-&gt;clock&nbsp;==&nbsp;clock&nbsp;?&nbsp;0&nbsp;:&nbsp;-1;&nbsp;<br  />}</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">stop_machine从字面上就可以知道是停掉了所有cpu上的任务（这个machine都不能对外提供服务了），只是执行一个函数，在这个场景下是change_clocksource。（为何不直接调用change_clocksource而是使用stop_machine这样的大招？现在还在思考中……）。change_clocksource主要执行的步骤包括：</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（1）调用timekeeping_forward_now函数。就要更换新的clocksource了，就是旧clocksource最后再发挥一次作用。调用旧的clocksource的read函数，将最后的这段时间间隔（当前到上次read）加到real&nbsp;time&nbsp;system&nbsp;clock以及minitonic&nbsp;raw&nbsp;system&nbsp;clock上去。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（2）调用tk_setup_internals函数设定新的clocksource，disable旧的clocksource。tk_setup_internals函数代码如下：</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">static void tk_setup_internals(struct timekeeper *tk, struct clocksource *clock)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; cycle_t interval;&nbsp;<br  />&nbsp;&nbsp;&nbsp; u64 tmp, ntpinterval;&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct clocksource *old_clock;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; old_clock = tk-&gt;clock;&nbsp;<br  />&nbsp;&nbsp;&nbsp; tk-&gt;clock = clock;－－－更换为新的clocksource&nbsp;<br  />&nbsp;&nbsp;&nbsp; tk-&gt;cycle_last = clock-&gt;cycle_last = clock-&gt;read(clock); －－－－更新last cycle值</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; tmp = NTP_INTERVAL_LENGTH;－－－NTP interval设定的纳秒数&nbsp;<br  />&nbsp;&nbsp;&nbsp; tmp &lt;&lt;= clock-&gt;shift;&nbsp;<br  />&nbsp;&nbsp;&nbsp; ntpinterval = tmp;－－－－计算remainder的时候会用到&nbsp;<br  />&nbsp;&nbsp;&nbsp; tmp += clock-&gt;mult/2;&nbsp;<br  />&nbsp;&nbsp;&nbsp; do_div(tmp, clock-&gt;mult);－－－－－－将NTP interval的纳秒值转成新clocksource的cycle值&nbsp;<br  />&nbsp;&nbsp;&nbsp; if (tmp == 0)&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tmp = 1;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; interval = (cycle_t) tmp;&nbsp;<br  />&nbsp;&nbsp;&nbsp; tk-&gt;cycle_interval = interval; －－－设定新的NTP interval的cycle值</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; tk-&gt;xtime_interval = (u64) interval * clock-&gt;mult;－－－－将NTP interval的cycle值转成ns&nbsp;<br  />&nbsp;&nbsp;&nbsp; tk-&gt;xtime_remainder = ntpinterval - tk-&gt;xtime_interval;－－－计算remainder&nbsp;<br  />&nbsp;&nbsp;&nbsp; tk-&gt;raw_interval =&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((u64) interval * clock-&gt;mult) &gt;&gt; clock-&gt;shift; －－－－－NTP interval的ns值</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp;&nbsp; if (old_clock) {－－－－－－xtime_nsec保存的是不是实际的ns值而是一个没有执行shift版本的&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int shift_change = clock-&gt;shift - old_clock-&gt;shift;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (shift_change &lt; 0)－－－－－如果新旧的shift值不一样，那么当前的xtime_nsec要修正&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tk-&gt;xtime_nsec &gt;&gt;= -shift_change;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tk-&gt;xtime_nsec &lt;&lt;= shift_change;&nbsp;<br  />&nbsp;&nbsp;&nbsp; }&nbsp;<br  />&nbsp;&nbsp;&nbsp; tk-&gt;shift = clock-&gt;shift; －－－－－更换新的shift factor</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; tk-&gt;ntp_error = 0;&nbsp;<br  />&nbsp;&nbsp;&nbsp; tk-&gt;ntp_error_shift = NTP_SCALE_SHIFT - clock-&gt;shift;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; tk-&gt;mult = clock-&gt;mult;－－－－－更换新的mult factor&nbsp;<br  />}</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">由于更换了新的clocksource，一般而言，新旧clocksource的工作参数不一样，就要就导致timekeeper的一些内部的数据成员要进行更新，例如NTP&nbsp;interval、multi和shift&nbsp;facotr数值等。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（3）调用timekeeping_update函数。由于更新了clocksource，因此timekeeping模块要更新其内部数据。TK_CLEAR_NTP控制clear&nbsp;旧的NTP的状态数据。TK_MIRROR用来更新shadow&nbsp;timekeeper，主要是为了保持和real&nbsp;timekeeper同步。TK_CLOCK_WAS_SET用在paravirtual&nbsp;clock场景中，这里就不详细描述了。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">&nbsp;</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">六、和tick device模块的接口</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">1、periodic tick</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">当系统采用periodic&nbsp;tick机制的时候，tick&nbsp;device模块会在周期性tick到来的时候，调用tick_periodic来进行下面的动作：</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（1）如果是global&nbsp;tick，需要调用do_timer来修改jiffies，计算系统负荷。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（2）如果是global&nbsp;tick，需要调用update_wall_time来更新系统时间。timekeeping模块是按照自己的节奏来更新系统时间的，更新一般是发生在周期性tick到来的时候。如果HZ＝100的话，那么每10ms就会有一个tick事件（clockevent事件），跟的太紧，会浪费CPU，跟的太松会损失一些精度。timekeeper中的cycle_interval成员就是周期性tick的cycle&nbsp;interval，如果距离上次的更新还不到一个tick的时间，那么就不再更新系统时间，直接退出。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（3）调用update_process_times和profile_tick，分别更新进程时间和进行内核剖析相关的操作。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">2、dynamic tick</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">TODO</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">&nbsp;</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">七、timekeeping模的电源管理</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">1、初始化</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">static struct syscore_ops timekeeping_syscore_ops = {&nbsp;<br  />&nbsp;&nbsp;&nbsp; .resume&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = timekeeping_resume,&nbsp;<br  />&nbsp;&nbsp;&nbsp; .suspend&nbsp;&nbsp;&nbsp; = timekeeping_suspend,&nbsp;<br  />};</p><p style="padding-bottom: 15px;line-height: 20px;">static int __init timekeeping_init_ops(void)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; register_syscore_ops(&amp;timekeeping_syscore_ops);&nbsp;<br  />&nbsp;&nbsp;&nbsp; return 0;&nbsp;<br  />}</p><p style="padding-bottom: 15px;line-height: 20px;">device_initcall(timekeeping_init_ops);</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">在系统初始化的过程中，会调用&nbsp;timekeeping_init_ops来注册和timekeeping相关的system&nbsp;core&nbsp;operations。在旧的内核中，这部分的功能是通过sysdev&nbsp;class和sysdev实现的。通过sysdev&nbsp;class和sysdev实现的suspend和resume看起来比较笨重而且效率低，因此新的内核为某些core&nbsp;subsystem设计了新的基于syscore_ops&nbsp;的接口。而注册的这些callback函数会在系统suspend和resume的时候，在适当的时机执行（在system&nbsp;suspend过程中，syscore&nbsp;suspend的执行非常的靠后，在那些普通的总线设备之后，对应的，system&nbsp;resume过程中，非常早的醒来进入工作状态）。当然，这属于电源管理子系统的内容，这篇文章就不描述了，大家可以参考suspend_enter函数。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">2、suspned 回调函数</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">static int timekeeping_suspend(void)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct timekeeper *tk = &amp;timekeeper;&nbsp;<br  />&nbsp;&nbsp;&nbsp; unsigned long flags;&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct timespec&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delta, delta_delta;&nbsp;<br  />&nbsp;&nbsp;&nbsp; static struct timespec&nbsp;&nbsp;&nbsp; old_delta;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; read_persistent_clock(&amp;timekeeping_suspend_time); －－－－－－－－－－－－（1）&nbsp;<br  />&nbsp;&nbsp;&nbsp; if (timekeeping_suspend_time.tv_sec || timekeeping_suspend_time.tv_nsec)&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; persistent_clock_exist = true;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; raw_spin_lock_irqsave(&amp;timekeeper_lock, flags);&nbsp;<br  />&nbsp;&nbsp;&nbsp; write_seqcount_begin(&amp;timekeeper_seq);&nbsp;<br  />&nbsp;&nbsp;&nbsp; timekeeping_forward_now(tk);－－－－－－－－－－－－－－－－－－－－－－（2）&nbsp;<br  />&nbsp;&nbsp;&nbsp; timekeeping_suspended = 1; －－－－－－－－－－－－－－－－－－－－－－（3）</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; delta = timespec_sub(tk_xtime(tk), timekeeping_suspend_time);－－－－－－－（4）&nbsp;<br  />&nbsp;&nbsp;&nbsp; delta_delta = timespec_sub(delta, old_delta);&nbsp;<br  />&nbsp;&nbsp;&nbsp; if (abs(delta_delta.tv_sec)&nbsp; &gt;= 2) {&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_delta = delta;&nbsp;<br  />&nbsp;&nbsp;&nbsp; } else {&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timekeeping_suspend_time =&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; timespec_add(timekeeping_suspend_time, delta_delta);&nbsp;<br  />&nbsp;&nbsp;&nbsp; }</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; timekeeping_update(tk, TK_MIRROR);－－－－更新shadow timekeeper&nbsp;<br  />&nbsp;&nbsp;&nbsp; write_seqcount_end(&amp;timekeeper_seq);&nbsp;<br  />&nbsp;&nbsp;&nbsp; raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; clockevents_notify(CLOCK_EVT_NOTIFY_SUSPEND, NULL);－－－－－－－－（5）&nbsp;<br  />&nbsp;&nbsp;&nbsp; clocksource_suspend();－－－suspend系统中所有的clocksource设备&nbsp;<br  />&nbsp;&nbsp;&nbsp; clockevents_suspend(); －－－suspend系统中所有的clockevent设备</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; return 0;&nbsp;<br  />}</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（1）一般而言，在整机suspend之后，clocksource和clockevent所依赖的底层硬件会被推入深度睡眠甚至是断电状态（当然，也有一些例外，有些clocksource会标记CLOCK_SOURCE_SUSPEND_NONSTOP&nbsp;flag），这时候，有些有计时能力的硬件（persistent&nbsp;clock），例如RTC，仍然是running状态。虽然RTC的精度不是很好，但是time&nbsp;keeping的动作在suspend中的时候也要继续，需要记录这一段时间的流逝。因此，这里调用read_persistent_clock将suspend时间点信息记录到timekeeping_suspend_time变量中。persistent_clock_exist变量标识系统中是否有RTC的硬件，按理说应该在timekeeping初始化的时候设定，不过也有可能在那个时刻，系统中RTC驱动还没有初始化，因此，如果这里能得到一个有效的时间值的话，也相应的更新persistent_clock_exist变量。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（2）timekeeping&nbsp;subsystem马上就睡下去了，临睡前，最后一次更新timekeeper的系统时钟的数据，此后，底层的硬件会停掉，硬件counter和硬件timer都会停止工作了。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（3）标记timekeeping&nbsp;subsystem进入suspend过程。在这个过程中的获取时间操作应该被禁止。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（4）persistent&nbsp;clock的精度一般没有那么好，可能只是以秒的精度在计时。因此，一次suspend/resume的过程中，read&nbsp;persistent&nbsp;clock会引入半秒的误差。为了防止连续的suspend/resume引起时间偏移，这里也考虑了real&nbsp;time&nbsp;clock和persistent&nbsp;clock之间的delta值。delta是本次real&nbsp;time&nbsp;clock和persistent&nbsp;clock之间的差值，delta_delta是两次suspend之间delta的差值，如果delta_delta大于2秒，</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（5）调用clockevents_notify函数通知clockevent模块系统suspend事件。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">3、resume回调函数</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">static void timekeeping_resume(void)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct timekeeper *tk = &amp;timekeeper;&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct clocksource *clock = tk-&gt;clock;&nbsp;<br  />&nbsp;&nbsp;&nbsp; unsigned long flags;&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct timespec ts_new, ts_delta;&nbsp;<br  />&nbsp;&nbsp;&nbsp; cycle_t cycle_now, cycle_delta;&nbsp;<br  />&nbsp;&nbsp;&nbsp; bool suspendtime_found = false;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; read_persistent_clock(&amp;ts_new); －－－－－－通过persistent clock记录醒来的时间点</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; clockevents_resume();－－－－－－－－－－－resume系统中所有的clockevent设备&nbsp;<br  />&nbsp;&nbsp;&nbsp; clocksource_resume(); －－－－－－－－－－resume系统中所有的clocksource设备</p><p style="padding-bottom: 15px;line-height: 20px;"><br  />&nbsp;&nbsp;&nbsp; cycle_now = clock-&gt;read(clock);&nbsp;<br  />&nbsp;&nbsp;&nbsp; if ((clock-&gt;flags &amp; CLOCK_SOURCE_SUSPEND_NONSTOP) &amp;&amp;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cycle_now &gt; clock-&gt;cycle_last) {－－－－－－－－－－－－－－－－－－－－－－（1）&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u64 num, max = ULLONG_MAX;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u32 mult = clock-&gt;mult;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; u32 shift = clock-&gt;shift;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s64 nsec = 0;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cycle_delta = (cycle_now - clock-&gt;cycle_last) &amp; clock-&gt;mask; －－－本次suspend的时间&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do_div(max, mult);&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (cycle_delta &gt; max) {&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num = div64_u64(cycle_delta, max);&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nsec = (((u64) max * mult) &gt;&gt; shift) * num;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cycle_delta -= num * max;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nsec += ((u64) cycle_delta * mult) &gt;&gt; shift; －－－－将suspend时间从cycle转换成ns</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ts_delta = ns_to_timespec(nsec);－－－－将suspend时间从ns转换成timespec&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; suspendtime_found = true;&nbsp;<br  />&nbsp;&nbsp;&nbsp; } else if (timespec_compare(&amp;ts_new, &amp;timekeeping_suspend_time) &gt; 0) {－－－－－（2）&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ts_delta = timespec_sub(ts_new, timekeeping_suspend_time);&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; suspendtime_found = true;&nbsp;<br  />&nbsp;&nbsp;&nbsp; }</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; if (suspendtime_found)&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __timekeeping_inject_sleeptime(tk, &amp;ts_delta); －－－－－－－－－－－－－－－－（3）</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; tk-&gt;cycle_last = clock-&gt;cycle_last = cycle_now; －－－更新last cycle的值&nbsp;<br  />&nbsp;&nbsp;&nbsp; tk-&gt;ntp_error = 0;&nbsp;<br  />&nbsp;&nbsp;&nbsp; timekeeping_suspended = 0; －－－－标记完成了suspend/resume过程&nbsp;<br  />&nbsp;&nbsp;&nbsp; timekeeping_update(tk, TK_MIRROR | TK_CLOCK_WAS_SET); －－更新shadow timerkeeper&nbsp;<br  />&nbsp;&nbsp;&nbsp; write_seqcount_end(&amp;timekeeper_seq);&nbsp;<br  />&nbsp;&nbsp;&nbsp; raw_spin_unlock_irqrestore(&amp;timekeeper_lock, flags);</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; touch_softlockup_watchdog();</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; clockevents_notify(CLOCK_EVT_NOTIFY_RESUME, NULL); －－－通知resume信息到clockevent&nbsp;<br  />&nbsp;&nbsp;&nbsp; hrtimers_resume(); －－－高精度timer相关，另文描述&nbsp;<br  />}</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（1）如果timekeeper当前的clocksource在suspend的时候没有stop，那么有机会使用精度更高的clocksource而不是persistent&nbsp;clock。前提是clocksource没有溢出，因此才有了cycle_now&nbsp;&gt;&nbsp;clock-&gt;cycle_last的判断（不过，这里要求clocksource应该有一个很长的overflow的时间）。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（2）如果没有suspend&nbsp;nonstop的clock，也没有关系，可以用persistent&nbsp;clock的时间值。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（3）调用__timekeeping_inject_sleeptime函数，具体如下：</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">static void __timekeeping_inject_sleeptime(struct timekeeper *tk,&nbsp; struct timespec *delta)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; tk_xtime_add(tk, delta);－－－－－－将suspend的时间加到real time clock上去&nbsp;<br  />&nbsp;&nbsp;&nbsp; tk_set_wall_to_mono(tk, timespec_sub(tk-&gt;wall_to_monotonic, *delta));&nbsp;<br  />&nbsp;&nbsp;&nbsp; tk_set_sleep_time(tk, timespec_add(tk-&gt;total_sleep_time, *delta));&nbsp;<br  />&nbsp;&nbsp;&nbsp; tk_debug_account_sleep_time(delta);&nbsp;<br  />}</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">monotonic&nbsp;clock不计sleep时间，因此wall_to_monotonic要减去suspend的时间值。total_sleep_time当然需要加上suspend的时间值。</p><p><em style="caret-color: rgb(0, 82, 255);color: rgb(0, 82, 255);white-space: normal;">本文转自蜗窝科技</em></p>
                </div>
                

                
  <div class="ct_mpda_wrp" id="js_sponsor_ad_area" style="display: none;"></div>


                
                <div class="read-more__area" id="js_more_read_area" style="display:none;">
                    
                </div>

                
                                <div class="reward_area tc reward_area_primary" id="js_preview_reward_author" style="display:none;">
                    <div class="reward-avatar" style="display: none;" id="js_preview_reward_author_avatar">
                        <img src="" alt="" id="js_preview_reward_author_head">
                    </div>
                    
                                        <div class="reward-author" id="js_preview_reward_author_name">linuxer</div>
                                        <p class="reward_tips" id="js_preview_reward_author_wording" style="display:none;"></p>
                    <p class="reward_button_wrp">
                    
                      <span class="reward_pop_panel">
                        <img src="https://res.wx.qq.com/mpres/zh_CN/htmledition/pages/home/index/pic_mp_app4290ba.png" alt="">
                        <strong>扫一扫下载订阅号助手，用手机发文章</strong>
                      </span>
                        <a class="reward_button" id='js_preview_reward_author_link' href="##"><span id="js_preview_reward_link_text">赞赏</span></a>
                    </p>
                </div>

                <div class="reward_qrcode_area reward_area tc" id="js_preview_reward_qrcode" style="display:none;">
                    <p class="tips_global">长按二维码向我转账</p>
                    <p id="js_preview_reward_ios_wording" class="reward_tips" style="display:none;"></p>
                    <span class="reward_qrcode_img_wrp"><img class="reward_qrcode_img" src="res.wx.qq.com/mmbizwap/zh_CN/htmledition/images/pic/appmsg/pic_reward_qrcode.2x42f400.png"></span>
                    <p class="tips_global">受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。</p>
                </div>
                            </div>
		<div class="comment">
			<h3 style="margin:26px 0;font-weight:100;padding-bottom:4px;border-bottom:1px solid #ccc;">精选留言</h3>
		    暂无...
		</div>
	</div>
	<div class='dy_all'>
		<a href='http://www.wowotech.net/timer_subsystem/timekeeping.html' target='_blank'>
			阅读全文
		</a>
	</div>
</body>