<!DOCTYPE html>
<head>
	<meta http-equiv='Content-Type' content='text/html;charset=utf-8'>
	<meta name='viewport' content='width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no'>
	<title>
		Linux时间子系统之：POSIX Clock
	</title>
	<script src='https://cdn.bootcss.com/jquery/1.10.2/jquery.min.js'>
	</script>
	<style>
		a {color: #607fa6;text-decoration:none;word-wrap:break-word;word-break:break-all;}.rich_media_title{padding-bottom:10px;margin-bottom:14px;border-bottom:1px solid #e7e7eb;font-weight:400;} .rich_media_meta_list{font-size:14px;margin-bottom: 22px;}
		.rich_media_meta{display:inline-block;vertical-align:middle;margin-right:8px;margin-bottom:10px;font-size:14px;}.rich_media_meta_text{color:#8c8c8c;color:rgba(0, 0, 0, 0.3)}.rich_media_meta_list
		em {font-style: normal;}@media screen and (max-width:768px){.rich_media{position:
		relative;padding: 20px 15px 15px;background-color: #fff;}}.rich_media_content{text-align:justify;} .rich_media_content * {max-width:100%!important;box-sizing: border-box!important;-webkit-box-sizing:
		border-box!important;word-wrap: break-word!important;}.rich_media_content
		blockquote {margin: 0;padding-left: 10px;border-left: 3px solid #dbdbdb;}.rich_media_content
		.list-paddingleft-2 {padding-left: 2.2em;}a.rich_media_meta_nickname{display: none;}@media screen and (min-width:1025px){.rich_media{position:relative;}a.rich_media_meta_nickname{display:inline-block!important;}span.rich_media_meta_nickname
		{display: inline-block!important;}.rich_media {width:677px;margin-left:auto;margin-right:auto;}}a.fwjm{font-size: 12px;color: #ececec;}.tenvideo_player {position: relative;width:
		100 %;height: 100 %;margin: auto;background: #000;}* {margin:0px;padding:0px;} body{line-height: 1.6;letter-spacing: .034em;}
		.dy_all {text-align: center;margin: 30px 0;} .dy_all a {display: inline-block;height:
		38px;line-height: 38px;padding: 0 18px;background-color: #009688;color:
		#fff;white-space: nowrap;font-size: 14px;border: none;border-radius: 2px;cursor:
		pointer;text-align: center;outline: 0;-webkit-appearance: none;transition:
		all .3s;-webkit-transition: all .3s;box-sizing: border-box;} img{max-width: 677px!important;}

		.crawler-info{padding: 8px 0;} .article-link>img{margin-left: 20px;width: 16px;}
		.comment-item::before,.comment-item::after{content:'';display:block;height:0;visibility:hidden;clear:both;*zoom:1;} .comment-item{margin-bottom:30px;}
		.avatar{width:12%; padding-right:10px;float:left;box-sizing:border-box;} .avatar img{width:100%;}
		.comment-body{float:left;width:88%;} .comment-body .comment-info{color:#b3b3b3;margin-bottom:4px;margin-top: -5px;} .comment-body .comment-info>span:last-child{float:right;} 
		.comment-author{border-left:4px solid green;padding-left:6px;margin:8px 0;}

		@media screen and (max-width: 420px) {.article-link>img {margin-left: 0px;}}
		@media screen and (min-width: 480px) {.avatar {width: 9%;}.comment-body {width: 91%;}}
	</style>
</head>
<body>
	<div id='js_article' class='rich_media'>
		<div class="crawler-info">
			<a href='https://www.52pojie.cn' class='fwjm' target='_blank'>
				提供的爬取软件来源于：52pojie.cn@夜泉 免费下载使用
			</a>
			<a href='https://mp.weixin.qq.com/s?__biz=MzI3NzA5MzUxNA==&amp;mid=2664606390&amp;idx=1&amp;sn=139ea28b8ee08e3bac6bcdf1d9209989&amp;chksm=f04d8753c73a0e453cb2ca382eee7f31d56f63d9e004138a9803c1f7789a22d07e9f937c1787&amp;scene=27#wechat_redirect&cpage=6' target='_blank' class="article-link">
				<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAMAAABA3o1rAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjk4QUEzQzVDNkNGQjExRTk5NzNBQ0VBMjgzMjY1NjkwIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjk4QUEzQzVENkNGQjExRTk5NzNBQ0VBMjgzMjY1NjkwIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6OThBQTNDNUE2Q0ZCMTFFOTk3M0FDRUEyODMyNjU2OTAiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6OThBQTNDNUI2Q0ZCMTFFOTk3M0FDRUEyODMyNjU2OTAiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5TKSKsAAAAclBMVEUuLi77+/stLS1VVVXx8fFOTk7s7Ozt7e1qamp5eXlNTU2WlpZFRUU6Ojrq6urn5+d/f3/8/Pw9PT0/Pz+YmJg8PDyZmZlAQECfn5+QkJBBQUFra2vo6OhDQ0OSkpKenp5WVlY+Pj7r6+tpaWksLCz///9o6ILHAAAAJnRSTlP/////////////////////////////////////////////////AKd6gbwAAACNSURBVHjajJHpEoIwDISDVMotcnuCmLz/K9KCdlqO6v7p7Mw3yW4KxG85fnUkIVfZ5J0SsCtqcgRw0HzjQYY2AAOIdRuaK4ReAPJ5nmglL5qICahpU60C0uXguQ9TgIwGJoDnT9z/ABmxt60ot0N2CsDLfb9mvBxs9ql+n5o9bEDBgbif7/1F4g80CjAAqrVAnnsm5f8AAAAASUVORK5CYII=" />
			</a>
		</div>
		<div id="img-content">

                
                <h2 class="rich_media_title" id="activity-name">Linux时间子系统之：POSIX Clock</h2>
                <div id="meta_content" class="rich_media_meta_list">
                                                                                                            <span class="rich_media_meta rich_media_meta_text">
                                                        linuxer
                                                    </span>
                                                                
                                        <span class="rich_media_meta rich_media_meta_nickname" id="profileBt"><a href="javascript:void(0);">Linux内核之旅</a>
                      <div id="js_profile_qrcode" class="profile_container" style="display:none;">
                          <div class="profile_inner">
                              <strong class="profile_nickname">Linux内核之旅</strong>
                              <img class="profile_avatar" id="js_profile_qrcode_img" src="" alt="">

                              <p class="profile_meta">
                              <label class="profile_meta_label">微信号</label>
                              <span class="profile_meta_value">LinuxKernelTravel</span>
                              </p>

                              <p class="profile_meta">
                              <label class="profile_meta_label">功能介绍</label>
                              <span class="profile_meta_value">Linux内核之旅</span>
                              </p>
                              
                          </div>
                          <span class="profile_arrow_wrp" id="js_profile_arrow_wrp">
                              <i class="profile_arrow arrow_out"></i>
                              <i class="profile_arrow arrow_in"></i>
                          </span>
                      </div>
                    </span>


                    <em id="publish_time" class="rich_media_meta rich_media_meta_text">2019-04-17</em>





                </div>

                
                
                                
                
                
                
                                                
                                                                
                                
                
                <div class="rich_media_content " id="js_content">
                    

                    

                    
                    
                    <p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">一、前言</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">clock是timer的基础，任何一个timer都需要运作在一个指定的clock上来。内核中维护了若干的clock。根据计时的特点，clock分成两种：一种是真实世界的时间概念，另外一个是仅仅计算CPU执行时间&nbsp;。从clock的生命周期来看，可以分成静态和动态的posix&nbsp;clock，静态是一直存在于内核中的，而动态clock有创建和销毁的概念。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">&nbsp;</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">二、基本概念</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">1、核心数据结构</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">所谓clock，实际上就是一种计时工具，可能是硬件，也可能是软件，当然对于POSIX&nbsp;clock而言，当然是指软件抽象了。clock能够记录一段时间的流逝，这段时间可能是真实的墙上时间，也可能是虚拟的时间，例如基于某个进程或者线程的CPU执行时间。在linux&nbsp;kernel中，用struct&nbsp;k_clock来抽象，具体定义如下：</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">struct k_clock {&nbsp;<br  />&nbsp;&nbsp;&nbsp; int (*clock_getres) (const clockid_t which_clock, struct timespec *tp);&nbsp;<br  />&nbsp;&nbsp;&nbsp; int (*clock_set) (const clockid_t which_clock, const struct timespec *tp);&nbsp;<br  />&nbsp;&nbsp;&nbsp; int (*clock_get) (const clockid_t which_clock, struct timespec * tp);&nbsp;<br  />&nbsp;&nbsp;&nbsp; int (*clock_adj) (const clockid_t which_clock, struct timex *tx);&nbsp;<br  />&nbsp;&nbsp;&nbsp; int (*timer_create) (struct k_itimer *timer);&nbsp;<br  />&nbsp;&nbsp;&nbsp; int (*nsleep) (const clockid_t which_clock, int flags, struct timespec *, struct timespec __user *);&nbsp;<br  />&nbsp;&nbsp;&nbsp; long (*nsleep_restart) (struct restart_block *restart_block);&nbsp;<br  />&nbsp;&nbsp;&nbsp; int (*timer_set) (struct k_itimer * timr, int flags, struct itimerspec * new_setting,&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct itimerspec * old_setting);&nbsp;<br  />&nbsp;&nbsp;&nbsp; int (*timer_del) (struct k_itimer * timr);&nbsp;<br  />&nbsp;&nbsp;&nbsp; void (*timer_get) (struct k_itimer * timr, struct itimerspec * cur_setting);&nbsp;<br  />};</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">clock作为一个计时工具当然有计时精度，通过clock_getres函数可以获取该clock的时间精度，需要说明的是这个精度是和timer相关的，用于将用户设定的timer超时时间规整到clock精度允许的数值上。clock_get和clock_set函数可以分别获取和设定当前的时间，这个时间值是一个绝对时间值（对于时间轴而言，这个绝对时间也是相对的，是相对于该timeline的epoch而言），标记了当前时间点。clock计时有可能是不准确的，例如基于系统晶振的clock。一方面本身晶振的精度有限，时间累积长了会出现较大误差。另外，晶振也会随着使用时间的推移、温度的变化等等因素而导致误差。clock_adj函数允许系统根据外部的精确时间信息对本clock进行调整。nsleep和nsleep_restart这两个成员函数可以让进程sleep一段时间。timer_xxx系列函数是和POSIX&nbsp;interval&nbsp;timer相关，具体会在POSIX&nbsp;timer文档中描述。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">2、静态定义的clock</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">static struct k_clock posix_clocks[MAX_CLOCKS];</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">posix_clocks数组定义了系统支持的所有的clock，相关的定义如下：</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">#define CLOCK_REALTIME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;<br  />#define CLOCK_MONOTONIC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;<br  />#define CLOCK_PROCESS_CPUTIME_ID&nbsp;&nbsp;&nbsp; 2&nbsp;<br  />#define CLOCK_THREAD_CPUTIME_ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;<br  />#define CLOCK_MONOTONIC_RAW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;<br  />#define CLOCK_REALTIME_COARSE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;<br  />#define CLOCK_MONOTONIC_COARSE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;<br  />#define CLOCK_BOOTTIME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;<br  />#define CLOCK_REALTIME_ALARM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;<br  />#define CLOCK_BOOTTIME_ALARM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9&nbsp;<br  />#define CLOCK_SGI_CYCLE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; /* Hardware specific */&nbsp;<br  />#define CLOCK_TAI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11</p><p style="padding-bottom: 15px;line-height: 20px;">#define MAX_CLOCKS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">POSIX标准定义了4种类型的clock，CLOCK_REALTIME、CLOCK_MONOTONIC、CLOCK_PROCESS_CPUTIME_ID和CLOCK_THREAD_CPUTIME_ID，其他是linux&nbsp;specific。如果一个clock的timeline是基于CPU运行时间的，那么我们称之CPU-time&nbsp;clock。CPU-time&nbsp;clock主要是用来为某个进程或者线程的执行时间进行计时的，一旦线程（进程）被切换，那么该clock就停掉了，直到下次调度器切换回该线程（进程）执行。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">各个具体的操作系统实现可以定义自己特有的clock，对于Linux&nbsp;kernel，我们定义了若干种clock。CLOCK_MONOTONIC_RAW启动时间点被设成0，此后一直不断累加，而且能设定，不会随NTP调整。CLOCK_REALTIME_COARSE、CLOCK_MONOTONIC_COARSE的概念和CLOCK_REALTIME、CLOCK_MONOTONIC的概念是类似的，只不过是精度是比较粗的版本。有时候，timer没有必要要求那么高的精度，那么我们可以使用这种clock，从而可以获取更好的性能。CLOCK_BOOTTIME和CLOCK_MONOTONIC类似，也是单调上述，在系统初始化的时候设定的基准数值是0，不过CLOCK_BOOTTIME计算系统suspend的时间，也就是说，不论是running还是suspend（这些都算是启动时间），CLOCK_BOOTTIME都会累积计时，直到系统reset或者shutdown。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">CLOCK_REALTIME_ALARM和CLOCK_BOOTTIME_ALARM主要用于Alarmtimer，这种timer是基于RTC的，更详细的内容请参考本站Alarmtimer的文档。CLOCK_TAI是原子钟的时间，和基于UTC的CLOCK_REALTIME类似，不过没有leap&nbsp;second。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">用户空间的clock_xxx函数会传递clock&nbsp;id的参数，在内核态，根据id作为index在posix_clocks数组中可以索引到对应的clock，然后调用clock对应的callback函数就OK了。当然基本意思就是这样，具体实现如下：</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">static struct k_clock *clockid_to_kclock(const clockid_t id)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; if (id &lt; 0)&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(id&nbsp;&amp;&nbsp;CLOCKFD_MASK)&nbsp;==&nbsp;CLOCKFD&nbsp;?&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;clock_posix_dynamic&nbsp;:&nbsp;&amp;clock_posix_cpu;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(id&nbsp;&gt;=&nbsp;MAX_CLOCKS&nbsp;||&nbsp;!posix_clocks[id].clock_getres)&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;&nbsp;<br  />&nbsp;&nbsp;&nbsp; return &amp;posix_clocks[id];&nbsp;<br  />}</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">clockid_to_kclock这个函数用来将clock&nbsp;id和具体的posix&nbsp;clock的k_clock&nbsp;数据结构对应起来。在linux平台上，clockid是int类型的数据，共32个bit，高29个bit用来保存一个pid（用于CPU-time&nbsp;clock）或者fd（动态分配的clock），bit&nbsp;2用来说明该CPU-time&nbsp;clock是一个进程clock还是线程clock。bit&nbsp;1和bit&nbsp;0用来说明该clock&nbsp;id的类型：PROF=0,&nbsp;VIRT=1,&nbsp;SCHED=2,&nbsp;or&nbsp;FD=3。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">当clock&nbsp;id小于0的时候，要么是CPU-time&nbsp;clock，要么是动态分配的clock，可以根据clock&nbsp;id的类型来判断。CPU-time&nbsp;clock和动态分配的clock后面会具体介绍。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">&nbsp;</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">三、各种real timeclock的定义</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">系统初始化的时候会调用init_posix_timers函数对各种静态定义的real&nbsp;time&nbsp;clock进行注册。注：monotonic&nbsp;clock也是real&nbsp;time&nbsp;clock的一种，全称是monotonic&nbsp;real&nbsp;time&nbsp;clock。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">1、real&nbsp;time&nbsp;clock的定义如下（timer相关内容不在本文描述）：</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">struct k_clock clock_realtime = {&nbsp;<br  />&nbsp;&nbsp;&nbsp; .clock_getres&nbsp;&nbsp;&nbsp; = hrtimer_get_res,&nbsp;<br  />&nbsp;&nbsp;&nbsp; .clock_get&nbsp;&nbsp;&nbsp; = posix_clock_realtime_get,&nbsp;<br  />&nbsp;&nbsp;&nbsp; .clock_set&nbsp;&nbsp;&nbsp; = posix_clock_realtime_set,&nbsp;<br  />&nbsp;&nbsp;&nbsp; .clock_adj&nbsp;&nbsp;&nbsp; = posix_clock_realtime_adj,&nbsp;<br  />&nbsp;&nbsp;&nbsp; .nsleep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = common_nsleep,&nbsp;<br  />&nbsp;&nbsp;&nbsp; .nsleep_restart&nbsp;&nbsp;&nbsp; = hrtimer_nanosleep_restart,&nbsp;<br  />};</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">real&nbsp;time&nbsp;clock需要调用timekeeping模块的接口来获取和设定当前时间值。对于获取当前时间值的函数posix_clock_realtime_get而言，是调用ktime_get_real_ts函数，该函数是timekeeping模块的接口函数，以timespec的格式回了real&nbsp;time&nbsp;clock的当前值。posix_clock_realtime_set函数主要是调用do_settimeofday这个timekeeping模块的接口函数。posix_clock_realtime_adj是调用do_adjtimex接口函数来实现具体的功能。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">纳秒级别的sleep是通过高精度timer实现的，real&nbsp;time&nbsp;clock的精度和hrtimer相关，具体可以参考hrtimer相关文档。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">2、monotonic&nbsp;clock的定义如下：</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">struct k_clock clock_monotonic = {&nbsp;<br  />&nbsp;&nbsp;&nbsp; .clock_getres&nbsp;&nbsp;&nbsp; = hrtimer_get_res,&nbsp;<br  />&nbsp;&nbsp;&nbsp; .clock_get&nbsp;&nbsp;&nbsp; = posix_ktime_get_ts,&nbsp;<br  />&nbsp;&nbsp;&nbsp; .nsleep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = common_nsleep,&nbsp;<br  />&nbsp;&nbsp;&nbsp; .nsleep_restart&nbsp;&nbsp;&nbsp; = hrtimer_nanosleep_restart,&nbsp;<br  />};</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">monotonic&nbsp;clock没有clock_set函数，不能被设定。通过ktime_get_ts这个timekeeping模块的接口可以获得monotonic&nbsp;clock的当前值。纳秒级别的sleep以及精度的获取函数和real&nbsp;time&nbsp;clock一样。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">3、monotonic&nbsp;raw&nbsp;clock的定义如下：</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">struct k_clock clock_monotonic_raw = {&nbsp;<br  />&nbsp;&nbsp;&nbsp; .clock_getres&nbsp;&nbsp;&nbsp; = hrtimer_get_res,&nbsp;<br  />&nbsp;&nbsp;&nbsp; .clock_get&nbsp;&nbsp;&nbsp; = posix_get_monotonic_raw,&nbsp;<br  />};</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">posix_get_monotonic_raw函数是调用timekeeping模块getrawmonotonic接口函数实现获取monotonic&nbsp;raw&nbsp;clock当前时间数值的。和monotonic&nbsp;clock一样，不能设定。和monotonic&nbsp;clock不同的是该clock没有timer相关的callback函数。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">4、coarse clock</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">struct k_clock clock_realtime_coarse = {&nbsp;<br  />&nbsp;&nbsp;&nbsp; .clock_getres&nbsp;&nbsp;&nbsp; = posix_get_coarse_res,&nbsp;<br  />&nbsp;&nbsp;&nbsp; .clock_get&nbsp;&nbsp;&nbsp; = posix_get_realtime_coarse,&nbsp;<br  />};&nbsp;<br  />struct k_clock clock_monotonic_coarse = {&nbsp;<br  />&nbsp;&nbsp;&nbsp; .clock_getres&nbsp;&nbsp;&nbsp; = posix_get_coarse_res,&nbsp;<br  />&nbsp;&nbsp;&nbsp; .clock_get&nbsp;&nbsp;&nbsp; = posix_get_monotonic_coarse,&nbsp;<br  />};</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">这两个clock的精度都是和tick相关的，KTIME_LOW_RES定义就是tick的纳秒数值。clock_get函数分别调用current_kernel_time和get_monotonic_coarse获取当前时间点的值。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">CLOCK_BOOTTIME和CLOCK_TAI的clock实现非常简单，大家自行阅读代码就OK了。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">&nbsp;</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">四、CPU-time clock</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">1、概述</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">从用户空间的角度看，有两种CPU-time&nbsp;clock的应用场景：</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（1）调用clock_xxx函数并传递CLOCK_PROCESS_CPUTIME_ID或者CLOCK_THREAD_CPUTIME_ID给该函数</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（2）调用clock_getcpuclockid或者pthread_getcpuclockid函数来获取指定进程或者线程的clock id，之后调用clock_xxx函数并传递该clock id参数</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">应对第一种场景，系统初始化的时候会调用init_posix_cpu_timers函数对静态定义的CPU-time&nbsp;clock进行注册。对于第二种场景，内核静态定义了一个clock_posix_cpu的clock来应对这种需求。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">2、指定进程或者线程的CPU-time clock</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">内核静态定义了一个clock如下（去掉了timer的callback函数）：</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">struct k_clock clock_posix_cpu = {&nbsp;<br  />&nbsp;&nbsp;&nbsp; .clock_getres&nbsp;&nbsp;&nbsp; = posix_cpu_clock_getres,&nbsp;<br  />&nbsp;&nbsp;&nbsp; .clock_set&nbsp;&nbsp;&nbsp; = posix_cpu_clock_set,&nbsp;<br  />&nbsp;&nbsp;&nbsp; .clock_get&nbsp;&nbsp;&nbsp; = posix_cpu_clock_get,&nbsp;<br  />&nbsp;&nbsp;&nbsp; .nsleep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = posix_cpu_nsleep,&nbsp;<br  />&nbsp;&nbsp;&nbsp; .nsleep_restart&nbsp;&nbsp;&nbsp; = posix_cpu_nsleep_restart,&nbsp;<br  />};</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（1）获取精度信息</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">static int posix_cpu_clock_getres(const clockid_t which_clock, struct timespec *tp)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; int error = check_clock(which_clock);－－－－－－－－参数校验&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!error)&nbsp;{&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tp-&gt;tv_sec = 0;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tp-&gt;tv_nsec = ((NSEC_PER_SEC + HZ - 1) / HZ);&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tp-&gt;tv_nsec = 1;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br  />&nbsp;&nbsp;&nbsp; }&nbsp;<br  />&nbsp;&nbsp;&nbsp; return error;&nbsp;<br  />}</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">该函数的执行逻辑分成两个部分，一部分是参数校验，一部分是返回精度。参数校验需要检查的包括：</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（a）clock&nbsp;id中的高29个bit包含了pid，获取pid的代码如下：</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">#define CPUCLOCK_PID(clock)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((pid_t) ~((clock) &gt;&gt; 3))</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">从代码可知，实际上并不是将pid放到高29个bit，而是将反码保存到了高29个bit。为何保存反码？这样做为了确保clock&nbsp;id是一个负数（MSB是1），还记得clockid_to_kclock的实现吗？要获取该clock&nbsp;id的精度，要确保该pid的task存在</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（b）如果该clock&nbsp;id是一个进程相关的（调用clock_getcpuclockid获得），那么这个进程id应该是一个实实在在的进程id。在linux&nbsp;kernel中，pid实际上是线程ID，POSIX标准的进程ID，也就是PID在内核中被成为线程组ID。因此，所谓一个“实实在在的进程id”就是说该线程的id（pid）和tgid一样，该pid标识的线程是线程组leader。当然，就是获取精度而已，实际上要求并不要那么严格，也许该pid标识的线程leader会退出，因此实际上要求该pid标识的task有thread&nbsp;group&nbsp;leader就OK了。（这里有可能理解有误，TODO）</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（c）如果该clock&nbsp;id是一个线程相关的（调用pthread_getcpuclockid获得），那么调用者必须和该线程（clock&nbsp;id中指明的那个线程）属于一个进程（线程组）。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">返回精度部分的代码逻辑很简单，对于PROF和VIRT类型的CPU-time&nbsp;clock，其精度是tick，对于SCHED类型，精度是1ns。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（2）获取当前时间值</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">同样的，首先需要从clock&nbsp;id中获取pid的值，然后根据pid的值获取对应的task&nbsp;sturct，如果pid等于0，那么不需要费劲去寻找。得到task&nbsp;struct之后，可以调用posix_cpu_clock_get_task函数获取时间值：</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">static int posix_cpu_clock_get_task(struct task_struct *tsk,&nbsp;&nbsp; const clockid_t which_clock,&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct timespec *tp)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; int err = -EINVAL;&nbsp;<br  />&nbsp;&nbsp;&nbsp; unsigned long long rtn;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; if (CPUCLOCK_PERTHREAD(which_clock)) {－－－per 线程的cpu clock&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (same_thread_group(tsk, current))－－－必须和调用者是同一个线程组，也就是同一个进程&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err = cpu_clock_sample(which_clock, tsk, &amp;rtn);&nbsp;<br  />&nbsp;&nbsp;&nbsp; } else {</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tsk == current || thread_group_leader(tsk))－－－进程的cpu clock&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err = cpu_clock_sample_group(which_clock, tsk, &amp;rtn);&nbsp;&nbsp;<br  />&nbsp;&nbsp;&nbsp; }</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!err)&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sample_to_timespec(which_clock, rtn, tp); －－－给返回值赋值</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; return err;&nbsp;<br  />}</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">这里仍然存在校验问题，也就是说是否允许调用者获取该task的CPU-time&nbsp;clock。对于进程，只允许调用者进程获取自己的CPU-time&nbsp;clock，在多线程环境下，主线程（线程组leader）可以获取整个进程的CPU-time&nbsp;clock信息。对于per线程的操作，必须和调用者是同一个线程组，也就是同一个进程。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（a）获取线程的clock信息</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">static int cpu_clock_sample(const clockid_t which_clock, struct task_struct *p,&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long long *sample)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; switch (CPUCLOCK_WHICH(which_clock)) {&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -EINVAL;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;CPUCLOCK_PROF:&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *sample = prof_ticks(p);－－－－获取该task在用户空间加上在kernel space的执行时间&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;CPUCLOCK_VIRT:&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *sample = virt_ticks(p);－－－－获取该task在用户空间的执行时间&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;CPUCLOCK_SCHED:&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *sample = task_sched_runtime(p);－－－－和调度器相关的cpu clock&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;<br  />&nbsp;&nbsp;&nbsp; }&nbsp;<br  />&nbsp;&nbsp;&nbsp; return 0;&nbsp;<br  />}</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">计算进程或者线程在cpu上的执行时间是一个挺烦人的事，一方面想要精度高，另外一方面又不想计算量大。因此，实际上CPU-time&nbsp;clock有三种，CPUCLOCK_PROF和CPUCLOCK_VIRT这两种都是比较粗略估计CPU执行时间的clock，它的工作原理就是在周期性tick中进行进程cpu&nbsp;time的统计，如果该tick是用户态（timer中断了用户态程序的执行），那么整个tick的时间都是该进程的用户态执行时间。如果该tick是内核态，并且是用户程序进行系统调用而陷入内核，那么整个tick的时间都是该进程的系统态执行时间。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">CPUCLOCK_SCHED&nbsp;clock和上面的方法不一样，它的精度是纳秒级别的，是在调度器上进行计算进程时间。具体的计算方法还是留到调度器文章中再描述吧。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（b）cpu_clock_sample_group函数概念类似，不过是统计一个进程上所有线程的时间而已。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">3、CLOCK_PROCESS_CPUTIME_ID 类型的clock</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">struct k_clock process = {&nbsp;<br  />&nbsp;&nbsp;&nbsp; .clock_getres&nbsp;&nbsp;&nbsp; = process_cpu_clock_getres,&nbsp;<br  />&nbsp;&nbsp;&nbsp; .clock_get&nbsp;&nbsp;&nbsp; = process_cpu_clock_get,&nbsp;<br  />&nbsp;&nbsp;&nbsp; .nsleep&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = process_cpu_nsleep,&nbsp;<br  />&nbsp;&nbsp;&nbsp; .nsleep_restart&nbsp;&nbsp;&nbsp; = process_cpu_nsleep_restart,&nbsp;<br  />};</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">process_cpu_clock_getres用来获取时间精度，该函数实际是调用posix_cpu_clock_getres(PROCESS_CLOCK,&nbsp;tp)来完成的。process_cpu_clock_get用来获取当前时间值，实际上是通过调用posix_cpu_clock_get完成。posix_cpu_clock_xxx函数在上一节中已经描述。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">4、CLOCK_THREAD_CPUTIME_ID类型的clock</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">很简单，大家自行学习吧。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">&nbsp;</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">五、动态分配clock</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">1、源由</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">某些硬件提供了计时的能力，可以实现成一个posix&nbsp;clock，同时，这些硬件又类似USB设备那样可以热拔插，这也就意味着该posix&nbsp;clock不能静态定义。此外，除了标准的timer和clock相关的操作，这些提供计时能力的硬件还需要一些其他的类似字符设备界面的控制接口，在这样的需求推动下，内核提供了dynamic&nbsp;posix&nbsp;clock。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">2、dynamic posix clock</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">系统中的每一个dynamic&nbsp;posix&nbsp;clock用struct&nbsp;posix_clock来抽象，如下：</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">struct posix_clock {&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct posix_clock_operations ops;－－－－－－－－－－－－－－（1）&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct cdev cdev;－－－－－－－－－－－－－－－－－－－－－－（2）&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct kref kref;&nbsp;<br  />&nbsp;&nbsp;&nbsp; struct rw_semaphore rwsem;&nbsp;<br  />&nbsp;&nbsp;&nbsp; bool zombie;－－－－－－－－－－－－－－－－－－－－－－－－（3）&nbsp;<br  />&nbsp;&nbsp;&nbsp; void (*release)(struct posix_clock *clk);－－－－－－－－－－－－－（4）&nbsp;<br  />};</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（1）ops是该dynamic&nbsp;posix&nbsp;clock的操作函数集，分成两个group，一个是timer（例如：timer_create、timer_delete等）以及clock操作相关（例如clock_gettime、clock_settime等），另外一个是普通字符设备的操作函数（例如：open、read、write等）。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（2）该dynamic&nbsp;posix&nbsp;clock对应的cdev数据结构。在struct&nbsp;posix_clock_operations中有一个owner，其实在cdev中也有一个指向moudle的owner成员，看起来似乎是重复定义了。同样的疑问也存在与kref成员，因为在cdev中有kobject成员，kobject抽象了内核最基础的对象类别，包括名字、引用计数等，因此，我觉得只要struct&nbsp;posix_clock包括了cdev成员，struct&nbsp;posix_clock_operations中的owner以及struct&nbsp;posix_clock中的kref应该没有存在的必要了。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（3）zombie记录了底层硬件的状态，对于hotplug的外设，有可能硬件被拔除。rwsem用来保护该状态信息</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">（4）当reference&nbsp;count等于0的时候会调用release函数释放dynamic&nbsp;posix&nbsp;clock占用的资源。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">3、注册和注销</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">底层的有计时能力的硬件driver可以调用posix_clock_register和posix_clock_unregister来注册或者注销一个posix&nbsp;clock，注册代码如下：</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">int posix_clock_register(struct posix_clock *clk, dev_t devid)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; int err;</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; kref_init(&amp;clk-&gt;kref);&nbsp;<br  />&nbsp;&nbsp;&nbsp; init_rwsem(&amp;clk-&gt;rwsem);</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; cdev_init(&amp;clk-&gt;cdev, &amp;posix_clock_file_operations);－－－－－VFS接口的操作函数集合&nbsp;<br  />&nbsp;&nbsp;&nbsp; clk-&gt;cdev.owner = clk-&gt;ops.owner;&nbsp;<br  />&nbsp;&nbsp;&nbsp; err = cdev_add(&amp;clk-&gt;cdev, devid, 1);</p><p style="padding-bottom: 15px;line-height: 20px;">&nbsp;&nbsp;&nbsp; return err;&nbsp;<br  />}</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">VFS接口的操作函数集合都非常简单，基本上都是struct&nbsp;posix_clock_operations上的字符设备操作函数集合上。这样，用户空间的程序可以通过标准的文件描述符进行设备操作。</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">4、clock和timer接口</p><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">通过clock_xxx或者timer_xxx函数可以指定clock&nbsp;id，对于dynamic&nbsp;posix&nbsp;clock可以通过下面的操作来生成一个dynamic&nbsp;posix&nbsp;clock&nbsp;ID：</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">#define FD_TO_CLOCKID(fd)&nbsp;&nbsp;&nbsp; ((~(clockid_t) (fd) &lt;&lt; 3) | CLOCKFD)</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">其中fd是通过设备节点打开的那个有计时能力的硬件。在内核态会通过clockid_to_kclock操作将clock&nbsp;id转换成</p><blockquote style="white-space: normal;margin: 0px 20px 20px;padding: 25px 20px;background-color: rgb(239, 239, 239);border-left-width: 5px;border-left-color: rgb(105, 105, 105);border-right-width: 5px;border-right-style: solid;border-right-color: rgb(105, 105, 105);caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;"><p style="padding-bottom: 15px;line-height: 20px;">static struct k_clock *clockid_to_kclock(const clockid_t id)&nbsp;<br  />{&nbsp;<br  />&nbsp;&nbsp;&nbsp; if (id &lt; 0)&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(id&nbsp;&amp;&nbsp;CLOCKFD_MASK)&nbsp;==&nbsp;CLOCKFD&nbsp;?&nbsp;<br  />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;clock_posix_dynamic&nbsp;:&nbsp;&amp;clock_posix_cpu;</p><p style="padding-bottom: 15px;line-height: 20px;">……&nbsp;<br  />}</p></blockquote><p style="white-space: normal;padding-bottom: 15px;line-height: 20px;caret-color: rgb(50, 50, 50);color: rgb(50, 50, 50);font-family: Arial, Helvetica, sans-serif;font-size: 13px;text-align: left;">clock_posix_dynamic可以将dynamic&nbsp;posix&nbsp;clock&nbsp;ID转换成对应的posix_clock，然后调用struct&nbsp;posix_clock_operations上的time和clock相关的函数即可。</p><p><em style="white-space: normal;caret-color: rgb(0, 82, 255);color: rgb(0, 82, 255);">本文转自蜗窝科技</em></p>
                </div>
                

                
  <div class="ct_mpda_wrp" id="js_sponsor_ad_area" style="display: none;"></div>


                
                <div class="read-more__area" id="js_more_read_area" style="display:none;">
                    
                </div>

                
                                <div class="reward_area tc reward_area_primary" id="js_preview_reward_author" style="display:none;">
                    <div class="reward-avatar" style="display: none;" id="js_preview_reward_author_avatar">
                        <img src="" alt="" id="js_preview_reward_author_head">
                    </div>
                    
                                        <div class="reward-author" id="js_preview_reward_author_name">linuxer</div>
                                        <p class="reward_tips" id="js_preview_reward_author_wording" style="display:none;"></p>
                    <p class="reward_button_wrp">
                    
                      <span class="reward_pop_panel">
                        <img src="https://res.wx.qq.com/mpres/zh_CN/htmledition/pages/home/index/pic_mp_app4290ba.png" alt="">
                        <strong>扫一扫下载订阅号助手，用手机发文章</strong>
                      </span>
                        <a class="reward_button" id='js_preview_reward_author_link' href="##"><span id="js_preview_reward_link_text">赞赏</span></a>
                    </p>
                </div>

                <div class="reward_qrcode_area reward_area tc" id="js_preview_reward_qrcode" style="display:none;">
                    <p class="tips_global">长按二维码向我转账</p>
                    <p id="js_preview_reward_ios_wording" class="reward_tips" style="display:none;"></p>
                    <span class="reward_qrcode_img_wrp"><img class="reward_qrcode_img" src="res.wx.qq.com/mmbizwap/zh_CN/htmledition/images/pic/appmsg/pic_reward_qrcode.2x42f400.png"></span>
                    <p class="tips_global">受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。</p>
                </div>
                            </div>
		<div class="comment">
			<h3 style="margin:26px 0;font-weight:100;padding-bottom:4px;border-bottom:1px solid #ccc;">精选留言</h3>
		    暂无...
		</div>
	</div>
	<div class='dy_all'>
		<a href='http://www.wowotech.net/timer_subsystem/posix-clock.html' target='_blank'>
			阅读全文
		</a>
	</div>
</body>